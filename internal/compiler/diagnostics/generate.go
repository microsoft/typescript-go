//go:build ignore

package main

import (
	"bytes"
	"cmp"
	"encoding/json"
	"flag"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/microsoft/typescript-go/internal/repo"
)

type diagnosticMessage struct {
	Category                     string `json:"category"`
	Code                         int    `json:"code"`
	ReportsUnnecessary           bool   `json:"reportsUnnecessary"`
	ReportsDeprecated            bool   `json:"reportsDeprecated"`
	ElidedInCompatabilityPyramid bool   `json:"elidedInCompatabilityPyramid"`

	key string
}

const header = `// GENERATED BY generate.go; DO NOT EDIT
package diagnostics

type Category int32

const (
	CategoryWarning Category = iota
	CategoryError
	CategorySuggestion
	CategoryMessage
)

type Message struct {
	code                         int32
	category                     Category
	key                          string
	text                         string
	reportsUnnecessary           bool
	elidedInCompatabilityPyramid bool
	reportsDeprecated            bool
}

func (m *Message) Code() int32                        { return m.code }
func (m *Message) Category() Category                 { return m.category }
func (m *Message) Key() string                        { return m.key }
func (m *Message) Message() string                    { return m.text }
func (m *Message) ReportsUnnecessary() bool           { return m.reportsUnnecessary }
func (m *Message) ElidedInCompatabilityPyramid() bool { return m.elidedInCompatabilityPyramid }
func (m *Message) ReportsDeprecated() bool            { return m.reportsDeprecated }
`

func main() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)

	input := filepath.Join(repo.TypeScriptSubmodulePath, "src", "compiler", "diagnosticMessages.json")
	if _, err := os.Stat(input); err != nil {
		log.Fatalf("failed to find input file: %v", err)
		return
	}

	output := flag.String("output", "", "path to the output diagnostics_generated.go file")
	flag.Parse()

	if *output == "" {
		flag.Usage()
		return
	}

	inputFile, err := os.Open(input)
	if err != nil {
		log.Fatalf("failed to open input file: %v", err)
		return
	}
	defer inputFile.Close()

	var rawDiagnosticMessages map[string]*diagnosticMessage
	if err := json.NewDecoder(inputFile).Decode(&rawDiagnosticMessages); err != nil {
		log.Fatalf("failed to decode input file: %v", err)
		return
	}

	diagnosticMessages := make([]*diagnosticMessage, 0, len(rawDiagnosticMessages))
	for k, v := range rawDiagnosticMessages {
		v.key = k
		diagnosticMessages = append(diagnosticMessages, v)
	}

	slices.SortFunc(diagnosticMessages, func(a *diagnosticMessage, b *diagnosticMessage) int {
		return cmp.Compare(a.Code, b.Code)
	})

	var buf bytes.Buffer

	buf.WriteString(header)
	buf.WriteString("\n")

	for _, m := range diagnosticMessages {
		propName, key := convertPropertyName(m.key, m.Code)

		buf.WriteString(`var `)
		buf.WriteString(propName)
		buf.WriteString(` = &Message{code: `)
		buf.WriteString(strconv.Itoa(m.Code))
		buf.WriteString(`, category: Category`)
		buf.WriteString(m.Category)
		buf.WriteString(`, key: "`)
		buf.WriteString(key)
		buf.WriteString(`", text: `)
		buf.WriteString(toJSONString(m.key))
		// buf.WriteString(`, reportsUnnecessary: `)
		// buf.WriteString(strconv.FormatBool(m.ReportsUnnecessary))
		// buf.WriteString(`, elidedInCompatabilityPyramid: `)
		// buf.WriteString(strconv.FormatBool(m.ElidedInCompatabilityPyramid))
		// buf.WriteString(`, reportsDeprecated: `)
		// buf.WriteString(strconv.FormatBool(m.ReportsDeprecated))
		buf.WriteString(``)
		if m.ReportsUnnecessary {
			buf.WriteString(`, reportsUnnecessary: true`)
		}
		if m.ElidedInCompatabilityPyramid {
			buf.WriteString(`, elidedInCompatabilityPyramid: true`)
		}
		if m.ReportsDeprecated {
			buf.WriteString(`, reportsDeprecated: true`)
		}
		buf.WriteString(`}`)
		buf.WriteString("\n")
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("failed to format output: %v", err)
		return
	}

	if err := os.WriteFile(*output, formatted, 0o666); err != nil {
		log.Fatalf("failed to write output: %v", err)
		return
	}
}

var (
	multipleUnderscoreRegexp           = regexp.MustCompile(`_+`)
	leadingUnderscoreUnlessDigitRegexp = regexp.MustCompile(`^_+(\D)`)
	trailingUnderscoreRegexp           = regexp.MustCompile(`_$`)
)

func convertPropertyName(origName string, code int) (propName string, key string) {
	var b strings.Builder
	b.Grow(len(origName))

	for _, r := range origName {
		switch r {
		case '*':
			b.WriteString("_Asterisk")
		case '/':
			b.WriteString("_Slash")
		case ':':
			b.WriteString("_Colon")
		default:
			if !unicode.IsLetter(r) && !unicode.IsDigit(r) {
				b.WriteRune('_')
			} else {
				b.WriteRune(r)
			}
		}
	}

	propName = b.String()
	// get rid of all multi-underscores
	propName = multipleUnderscoreRegexp.ReplaceAllString(propName, "_")
	// remove any leading underscore, unless it is followed by a number.
	propName = leadingUnderscoreUnlessDigitRegexp.ReplaceAllString(propName, "$1")
	// get rid of all trailing underscores.
	propName = trailingUnderscoreRegexp.ReplaceAllString(propName, "")

	key = propName
	if len(key) > 100 {
		key = key[:100]
	}
	key = key + "_" + strconv.Itoa(code)

	// Ensure the first character is uppercase so the variable is exported.
	first, _ := utf8.DecodeRuneInString(propName)
	if !unicode.IsUpper(first) {
		var b strings.Builder
		b.Grow(len(propName) + 2)
		if first == '_' {
			b.WriteString("X")
		} else {
			b.WriteString("X_")
		}
		b.WriteString(propName)
		propName = b.String()
	}

	return propName, key
}

func toJSONString(s string) string {
	var buf bytes.Buffer
	var enc = json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode(s); err != nil {
		log.Fatalf("failed to encode text: %v", err)
	}
	return strings.TrimSpace(buf.String())
}
