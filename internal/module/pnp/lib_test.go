package pnp

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"testing"

	"github.com/go-json-experiment/json"
	"github.com/microsoft/typescript-go/internal/repo"
	"github.com/microsoft/typescript-go/internal/tspath"
)

type TestSuite struct {
	Manifest Manifest   `json:"manifest"`
	Tests    []TestCase `json:"tests"`
}

type TestCase struct {
	Imported string `json:"imported"`
	Importer string `json:"importer"`
	Expected string `json:"expected"`
	It       string `json:"it"`
}

func TestResolveToUnqualifiedExample(t *testing.T) {
	t.Parallel()
	pnpPath := filepath.Join(repo.TestDataPath, "fixtures", "pnp", "pnp-yarn-v3.cjs")
	m, err := LoadPNPManifest(pnpPath)
	if err != nil {
		log.Fatalf("Expected to load the .pnp.cjs file generated by Yarn 3: %v", err)
	}

	host := PNPResolutionHost{
		FindPNPManifest: func(_ string) (*Manifest, error) {
			return &m, nil
		},
	}
	cfg := &ResolutionConfig{Host: host}

	parentPath, err := filepath.Abs("/path/to/file")
	if err != nil {
		log.Fatalf("failed to filepath.Abs: %v", err)
	}

	t.Run("Example", func(t *testing.T) {
		t.Parallel()
		res, resolutionErr := ResolveToUnqualified("lodash/cloneDeep", parentPath, cfg)
		if resolutionErr != nil {
			log.Printf("resolution error: %v", err)
			return
		}

		switch res.Kind {
		case ResolutionResolved:
			sub := ""
			if res.ModulePath != nil {
				sub = *res.ModulePath
			}
			log.Printf("Resolved: path=%s subpath=%s", res.Path, sub)

		case ResolutionSkipped:
			log.Printf("Skipped by PnP resolver; use default resolver")
		}
	})
}

func TestLoadPnPManifest(t *testing.T) {
	t.Parallel()
	cases := []struct {
		path string
		msg  string
	}{
		{filepath.Join(repo.TestDataPath, "fixtures", "pnp", "pnp-yarn-v3.cjs"), "Expected to load the .pnp.cjs file generated by Yarn 3"},
		{filepath.Join(repo.TestDataPath, "fixtures", "pnp", "pnp-yarn-v4.cjs"), "Expected to load the .pnp.cjs file generated by Yarn 4"},
	}

	for _, tc := range cases {
		t.Run(tc.path, func(t *testing.T) {
			t.Parallel()
			if _, err := LoadPNPManifest(tc.path); err != nil {
				t.Fatalf("%s: %v", tc.msg, err)
			}
		})
	}
}

func TestResolveUnqualified(t *testing.T) {
	t.Parallel()
	expectationsPath := filepath.Join(repo.TestDataPath, "fixtures", "pnp", "test-expectations.json")

	content, err := os.ReadFile(expectationsPath)
	if err != nil {
		t.Fatalf("Assertion failed: Expected the expectations to be found: %v", err)
	}

	var suites []TestSuite
	if err = json.Unmarshal(content, &suites); err != nil {
		t.Fatalf("Assertion failed: Expected the expectations to be loaded: %v", err)
	}

	for si := range suites {
		if si != 0 {
			continue
		}
		testSuite := &suites[si]

		manifest := &testSuite.Manifest
		err := InitPNPManifest(manifest, "/path/to/project/.pnp.cjs")
		if err != nil {
			t.Fatalf("failed to init pnp manifest: %v", err)
		}

		for _, tc := range testSuite.Tests {
			parent := filepath.Join(tc.Importer, "fooo")
			manifestCopy := *manifest

			host := PNPResolutionHost{
				FindPNPManifest: func(_ string) (*Manifest, error) {
					cp := manifestCopy
					return &cp, nil
				},
			}
			cfg := &ResolutionConfig{Host: host}

			t.Run(tc.It, func(t *testing.T) {
				t.Parallel()
				res, unqualifiedErr := ResolveToUnqualified(tc.Imported, parent, cfg)

				switch {
				case unqualifiedErr == nil && res.Kind == ResolutionResolved:
					if res.Path != tc.Expected {
						t.Fatalf("'%s': expected resolved path %q, got %q", tc.It, tc.Expected, res.Path)
					}
				case unqualifiedErr == nil && res.Kind == ResolutionSkipped:
					if tc.Imported != tc.Expected {
						t.Fatalf("'%s': expected skipped specifier %q, got %q", tc.It, tc.Expected, tc.Imported)
					}
				case unqualifiedErr != nil:
					if tc.Expected != "error!" {
						t.Fatalf("'%s': unexpected error: %v (expected=%q)", tc.It, err, tc.Expected)
					}
				default:
					t.Fatalf("'%s': unreachable state", tc.It)
				}
			})
		}
	}
}

func TestParseSinglePackageName(t *testing.T) {
	t.Parallel()
	name, sub, err := ParseBareIdentifier("pkg")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if name != "pkg" {
		t.Fatalf("expected name %q, got %q", "pkg", name)
	}
	if sub != nil {
		t.Fatalf("expected subpath=nil, got %v", *sub)
	}
}

func TestParseScopedPackageName(t *testing.T) {
	t.Parallel()
	name, sub, err := ParseBareIdentifier("@scope/pkg")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if name != "@scope/pkg" {
		t.Fatalf("expected name %q, got %q", "@scope/pkg", name)
	}
	if sub != nil {
		t.Fatalf("expected subpath=nil, got %v", *sub)
	}
}

func TestParsePackageNameWithLongSubpath(t *testing.T) {
	t.Parallel()
	name, sub, err := ParseBareIdentifier("pkg/a/b/c/index.js")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if name != "pkg" {
		t.Fatalf("expected name %q, got %q", "pkg", name)
	}
	if sub == nil || *sub != "a/b/c/index.js" {
		if sub == nil {
			t.Fatalf("expected subpath=%q, got nil", "a/b/c/index.js")
		}
		t.Fatalf("expected subpath=%q, got %q", "a/b/c/index.js", *sub)
	}
}

func TestParseScopedPackageWithLongSubpath(t *testing.T) {
	t.Parallel()
	name, sub, err := ParseBareIdentifier("@scope/pkg/a/b/c/index.js")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if name != "@scope/pkg" {
		t.Fatalf("expected name %q, got %q", "@scope/pkg", name)
	}
	if sub == nil || *sub != "a/b/c/index.js" {
		if sub == nil {
			t.Fatalf("expected subpath=%q, got nil", "a/b/c/index.js")
		}
		t.Fatalf("expected subpath=%q, got %q", "a/b/c/index.js", *sub)
	}
}

// need fixtures to be yarn install and make global cache
func TestGlobalCache(t *testing.T) {
	t.Parallel()
	t.Skip("skipping global cache test")

	pnpPath := filepath.Join(repo.TestDataPath, "fixtures", "pnp", "global-cache", ".pnp.cjs")
	manifest, err := LoadPNPManifest(pnpPath)
	if err != nil {
		t.Fatalf("failed to load pnp manifest: %v", err)
	}

	home, err := os.UserHomeDir()
	if err != nil {
		t.Fatalf("failed to get home dir: %v", err)
	}

	var globalCache string
	if runtime.GOOS == "windows" {
		globalCache = filepath.Join(home, "AppData", "Local", "Yarn", "Berry", "cache")
	} else {
		globalCache = filepath.Join(home, ".yarn", "berry", "cache")
	}

	issuer := filepath.Join(
		globalCache,
		"source-map-support-npm-0.5.21-09ca99e250-10c0.zip",
		"node_modules",
		"source-map-support",
	)

	res, err := ResolveToUnqualifiedViaManifest(&manifest, "source-map", issuer)
	fmt.Println("res", res.Path)
	if err != nil {
		t.Fatalf("resolve failed: %v", err)
	}
	if res.Kind != ResolutionResolved {
		t.Fatalf("unexpected resolution kind: %v", res.Kind)
	}

	got := tspath.NormalizePath(res.Path)
	expected := tspath.NormalizePath(filepath.Join(
		globalCache,
		"source-map-npm-0.6.1-1a3621db16-10c0.zip",
		"node_modules",
		"source-map",
	)) + "/"

	if got != expected {
		t.Fatalf("expected resolved path %q, got %q", expected, got)
	}
	if res.ModulePath != nil {
		t.Fatalf("expected subpath=\"\", got %q", *res.ModulePath)
	}
}
