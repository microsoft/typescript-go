package estransforms

import (
	"github.com/microsoft/typescript-go/internal/ast"
	"github.com/microsoft/typescript-go/internal/checker"
	"github.com/microsoft/typescript-go/internal/collections"
	"github.com/microsoft/typescript-go/internal/core"
	"github.com/microsoft/typescript-go/internal/printer"
	"github.com/microsoft/typescript-go/internal/transformers"
)

type hierarchyFacts int

const (
	hierarchyFactsNone hierarchyFacts = 0

	// Ancestor facts
	hierarchyFactsHasLexicalThis     hierarchyFacts = 1 << 0
	hierarchyFactsIterationContainer hierarchyFacts = 1 << 1

	hierarchyFactsAncestorFactsMask = (hierarchyFactsIterationContainer << 1) - 1

	hierarchyFactsSourceFileExcludes           = hierarchyFactsIterationContainer
	hierarchyFactsStrictModeSourceFileIncludes = hierarchyFactsNone

	hierarchyFactsClassOrFunctionIncludes = hierarchyFactsHasLexicalThis
	hierarchyFactsClassOrFunctionExcludes = hierarchyFactsIterationContainer

	hierarchyFactsArrowFunctionIncludes = hierarchyFactsNone
	hierarchyFactsArrowFunctionExcludes = hierarchyFactsClassOrFunctionExcludes

	hierarchyFactsIterationStatementIncludes = hierarchyFactsIterationContainer
	hierarchyFactsIterationStatementExcludes = hierarchyFactsNone
)

type forawaitTransformer struct {
	transformers.Transformer
	compilerOptions *core.CompilerOptions

	enclosingFunctionFlags    checker.FunctionFlags
	hierarchyFacts            hierarchyFacts
	capturedSuperProperties   *collections.Set[string]
	hasSuperElementAccess     bool
	exportedVariableStatement bool
}

func (tx *forawaitTransformer) visit(node *ast.Node) *ast.Node {
	return tx.visitorWorker(node, false)
}

func (tx *forawaitTransformer) visitWithUnusedExpressionResult(node *ast.Node) *ast.Node {
	return tx.visitorWorker(node, true)
}

func (tx *forawaitTransformer) visitorWorker(node *ast.Node, expressionResultIsUnused bool) *ast.Node {
	if node.SubtreeFacts()&ast.SubtreeContainsForAwaitOrAsyncGenerator == 0 {
		return node
	}
	switch node.Kind {
	case ast.KindSourceFile:
		return tx.visitSourceFile(node.AsSourceFile())
	case ast.KindAwaitExpression:
		return tx.visitAwaitExpression(node.AsAwaitExpression())
	case ast.KindYieldExpression:
		return tx.visitYieldExpression(node.AsYieldExpression())
	case ast.KindReturnStatement:
		return tx.visitReturnStatement(node.AsReturnStatement())
	case ast.KindLabeledStatement:
		return tx.visitLabeledStatement(node.AsLabeledStatement())
	case ast.KindForOfStatement:
		return tx.visitForOfStatement(node.AsForInOrOfStatement(), nil)
	case ast.KindForStatement:
		return tx.doWithHierarchyFacts(tx.visitForStatement, node, hierarchyFactsIterationStatementExcludes, hierarchyFactsIterationStatementIncludes)
	case ast.KindDoStatement, ast.KindWhileStatement, ast.KindForInStatement:
		return tx.doWithHierarchyFacts(tx.visitDefault, node, hierarchyFactsIterationStatementExcludes, hierarchyFactsIterationStatementIncludes)
	case ast.KindVoidExpression:
		return tx.visitVoidExpression(node)
	case ast.KindConstructor:
		return tx.doWithHierarchyFacts(tx.visitConstructorDeclaration, node, hierarchyFactsClassOrFunctionExcludes, hierarchyFactsClassOrFunctionIncludes)
	case ast.KindMethodDeclaration:
		return tx.doWithHierarchyFacts(tx.visitMethodDeclaration, node, hierarchyFactsClassOrFunctionExcludes, hierarchyFactsClassOrFunctionIncludes)
	case ast.KindGetAccessor:
		return tx.doWithHierarchyFacts(tx.visitGetAccessorDeclaration, node, hierarchyFactsClassOrFunctionExcludes, hierarchyFactsClassOrFunctionIncludes)
	case ast.KindSetAccessor:
		return tx.doWithHierarchyFacts(tx.visitSetAccessorDeclaration, node, hierarchyFactsClassOrFunctionExcludes, hierarchyFactsClassOrFunctionIncludes)
	case ast.KindFunctionDeclaration:
		return tx.doWithHierarchyFacts(tx.visitFunctionDeclaration, node, hierarchyFactsClassOrFunctionExcludes, hierarchyFactsClassOrFunctionIncludes)
	case ast.KindFunctionExpression:
		return tx.doWithHierarchyFacts(tx.visitFunctionExpression, node, hierarchyFactsClassOrFunctionExcludes, hierarchyFactsClassOrFunctionIncludes)
	case ast.KindArrowFunction:
		return tx.doWithHierarchyFacts(tx.visitArrowFunction, node, hierarchyFactsArrowFunctionExcludes, hierarchyFactsArrowFunctionIncludes)
	case ast.KindExpressionStatement:
		return tx.visitExpressionStatement(node)
	case ast.KindParenthesizedExpression:
		return tx.visitParenthesizedExpression(node, expressionResultIsUnused)
	case ast.KindPropertyAccessExpression:
		if tx.capturedSuperProperties != nil && node.Expression().Kind == ast.KindSuperKeyword {
			tx.capturedSuperProperties.Add(node.Name().Text())
		}
		return tx.Visitor().VisitEachChild(node)
	case ast.KindElementAccessExpression:
		if tx.capturedSuperProperties != nil && node.Expression().Kind == ast.KindSuperKeyword {
			tx.hasSuperElementAccess = true
		}
		return tx.Visitor().VisitEachChild(node)
	case ast.KindClassDeclaration, ast.KindClassExpression:
		return tx.doWithHierarchyFacts(tx.visitDefault, node, hierarchyFactsClassOrFunctionExcludes, hierarchyFactsClassOrFunctionIncludes)
	default:
		return tx.Visitor().VisitEachChild(node)
	}
}

func (tx *forawaitTransformer) affectsSubtree(excludeFacts hierarchyFacts, includeFacts hierarchyFacts) bool {
	return tx.hierarchyFacts != (tx.hierarchyFacts&^excludeFacts | includeFacts)
}

func (tx *forawaitTransformer) enterSubtree(excludeFacts hierarchyFacts, includeFacts hierarchyFacts) hierarchyFacts {
	ancestorFacts := tx.hierarchyFacts
	tx.hierarchyFacts = (tx.hierarchyFacts&^excludeFacts | includeFacts) & hierarchyFactsAncestorFactsMask
	return ancestorFacts
}

func (tx *forawaitTransformer) exitSubtree(ancestorFacts hierarchyFacts) {
	tx.hierarchyFacts = ancestorFacts
}

func (tx *forawaitTransformer) doWithHierarchyFacts(cb func(*ast.Node) *ast.Node, node *ast.Node, excludeFacts hierarchyFacts, includeFacts hierarchyFacts) *ast.Node {
	if tx.affectsSubtree(excludeFacts, includeFacts) {
		ancestorFacts := tx.enterSubtree(excludeFacts, includeFacts)
		result := cb(node)
		tx.exitSubtree(ancestorFacts)
		return result
	}
	return cb(node)
}

func (tx *forawaitTransformer) visitDefault(node *ast.Node) *ast.Node {
	return tx.Visitor().VisitEachChild(node)
}

func (tx *forawaitTransformer) visitSourceFile(node *ast.SourceFile) *ast.Node {
	ancestorFacts := tx.enterSubtree(
		hierarchyFactsSourceFileExcludes,
		hierarchyFactsStrictModeSourceFileIncludes,
	)
	tx.exportedVariableStatement = false
	visited := tx.Visitor().VisitEachChild(node.AsNode())
	tx.EmitContext().AddEmitHelper(visited, tx.EmitContext().ReadEmitHelpers()...)
	tx.exitSubtree(ancestorFacts)
	return visited
}

func (tx *forawaitTransformer) visitForStatement(node *ast.Node) *ast.Node {
	n := node.AsForStatement()
	return tx.Factory().UpdateForStatement(
		n,
		tx.unusedExpressionResultVisitor().VisitNode(n.Initializer),
		tx.Visitor().VisitNode(n.Condition),
		tx.unusedExpressionResultVisitor().VisitNode(n.Incrementor),
		tx.Visitor().VisitEmbeddedStatement(n.Statement),
	)
}

func (tx *forawaitTransformer) visitVoidExpression(node *ast.Node) *ast.Node {
	return tx.unusedExpressionResultVisitor().VisitEachChild(node)
}

func (tx *forawaitTransformer) visitExpressionStatement(node *ast.Node) *ast.Node {
	return tx.unusedExpressionResultVisitor().VisitEachChild(node)
}

func (tx *forawaitTransformer) visitParenthesizedExpression(node *ast.Node, expressionResultIsUnused bool) *ast.Node {
	if expressionResultIsUnused {
		return tx.unusedExpressionResultVisitor().VisitEachChild(node)
	}
	return tx.Visitor().VisitEachChild(node)
}

func (tx *forawaitTransformer) unusedExpressionResultVisitor() *ast.NodeVisitor {
	return tx.EmitContext().NewNodeVisitor(tx.visitWithUnusedExpressionResult)
}

func (tx *forawaitTransformer) visitAwaitExpression(node *ast.AwaitExpression) *ast.Node {
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 && tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		result := tx.Factory().NewYieldExpression(
			nil, /*asteriskToken*/
			tx.Factory().NewAwaitHelper(tx.Visitor().VisitNode(node.Expression)),
		)
		result.Loc = node.Loc
		tx.EmitContext().SetOriginal(result, node.AsNode())
		return result
	}
	return tx.Visitor().VisitEachChild(node.AsNode())
}

func (tx *forawaitTransformer) visitYieldExpression(node *ast.YieldExpression) *ast.Node {
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 && tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		if node.AsteriskToken != nil {
			expression := tx.Visitor().VisitNode(node.Expression)

			asyncValuesResult := tx.Factory().NewAsyncValuesHelper(expression)
			asyncValuesResult.Loc = expression.Loc

			asyncDelegatorResult := tx.Factory().NewAsyncDelegatorHelper(asyncValuesResult)
			asyncDelegatorResult.Loc = expression.Loc

			innerYield := tx.Factory().UpdateYieldExpression(
				node,
				node.AsteriskToken,
				asyncDelegatorResult,
			)

			awaitedYield := tx.Factory().NewAwaitHelper(innerYield)

			result := tx.Factory().NewYieldExpression(
				nil, /*asteriskToken*/
				awaitedYield,
			)
			result.Loc = node.Loc
			tx.EmitContext().SetOriginal(result, node.AsNode())
			return result
		}

		var innerExpression *ast.Node
		if node.Expression != nil {
			innerExpression = tx.Visitor().VisitNode(node.Expression)
		} else {
			innerExpression = tx.Factory().NewVoidZeroExpression()
		}

		result := tx.Factory().NewYieldExpression(
			nil, /*asteriskToken*/
			tx.createDownlevelAwait(innerExpression),
		)
		result.Loc = node.Loc
		tx.EmitContext().SetOriginal(result, node.AsNode())
		return result
	}

	return tx.Visitor().VisitEachChild(node.AsNode())
}

func (tx *forawaitTransformer) visitReturnStatement(node *ast.ReturnStatement) *ast.Node {
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 && tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		var expression *ast.Node
		if node.Expression != nil {
			expression = tx.Visitor().VisitNode(node.Expression)
		} else {
			expression = tx.Factory().NewVoidZeroExpression()
		}
		return tx.Factory().UpdateReturnStatement(
			node,
			tx.createDownlevelAwait(expression),
		)
	}

	return tx.Visitor().VisitEachChild(node.AsNode())
}

func (tx *forawaitTransformer) visitLabeledStatement(node *ast.LabeledStatement) *ast.Node {
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 {
		statement := unwrapInnermostStatementOfLabel(node)
		if statement.Kind == ast.KindForOfStatement && statement.AsForInOrOfStatement().AwaitModifier != nil {
			return tx.visitForOfStatement(statement.AsForInOrOfStatement(), node)
		}
		return tx.restoreEnclosingLabel(tx.Visitor().VisitNode(statement), node)
	}
	return tx.Visitor().VisitEachChild(node.AsNode())
}

// unwrapInnermostStatementOfLabel follows LabeledStatement chains to find the innermost statement.
func unwrapInnermostStatementOfLabel(node *ast.LabeledStatement) *ast.Node {
	for {
		if node.Statement.Kind != ast.KindLabeledStatement {
			return node.Statement
		}
		node = node.Statement.AsLabeledStatement()
	}
}

// restoreEnclosingLabel re-wraps a statement with its original label chain.
func (tx *forawaitTransformer) restoreEnclosingLabel(node *ast.Node, outermostLabeledStatement *ast.LabeledStatement) *ast.Node {
	if outermostLabeledStatement == nil {
		return node
	}
	innerLabel := node
	if ast.IsLabeledStatement(outermostLabeledStatement.Statement) {
		innerLabel = tx.restoreEnclosingLabel(node, outermostLabeledStatement.Statement.AsLabeledStatement())
	}
	return tx.Factory().UpdateLabeledStatement(
		outermostLabeledStatement,
		outermostLabeledStatement.Label,
		innerLabel,
	)
}

func (tx *forawaitTransformer) visitForOfStatement(node *ast.ForInOrOfStatement, outermostLabeledStatement *ast.LabeledStatement) *ast.Node {
	ancestorFacts := tx.enterSubtree(hierarchyFactsIterationStatementExcludes, hierarchyFactsIterationStatementIncludes)
	var result *ast.Node
	if node.AwaitModifier != nil {
		result = tx.transformForAwaitOfStatement(node, outermostLabeledStatement, ancestorFacts)
	} else {
		result = tx.restoreEnclosingLabel(tx.Visitor().VisitEachChild(node.AsNode()), outermostLabeledStatement)
	}
	tx.exitSubtree(ancestorFacts)
	return result
}

func (tx *forawaitTransformer) createDownlevelAwait(expression *ast.Node) *ast.Node {
	if tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		return tx.Factory().NewYieldExpression(
			nil, /*asteriskToken*/
			tx.Factory().NewAwaitHelper(expression),
		)
	}
	return tx.Factory().NewAwaitExpression(expression)
}

func (tx *forawaitTransformer) convertForOfStatementHead(node *ast.ForInOrOfStatement, boundValue *ast.Node, nonUserCode *ast.Node) *ast.Node {
	f := tx.Factory()
	value := f.NewTempVariable()
	tx.EmitContext().AddVariableDeclaration(value)
	iteratorValueExpression := f.NewAssignmentExpression(value, boundValue)
	iteratorValueStatement := f.NewExpressionStatement(iteratorValueExpression)
	tx.EmitContext().SetSourceMapRange(iteratorValueStatement, node.Expression.Loc)

	exitNonUserCodeExpression := f.NewAssignmentExpression(nonUserCode, f.NewKeywordExpression(ast.KindFalseKeyword))
	exitNonUserCodeStatement := f.NewExpressionStatement(exitNonUserCodeExpression)
	tx.EmitContext().SetSourceMapRange(exitNonUserCodeStatement, node.Expression.Loc)

	statements := []*ast.Node{iteratorValueStatement, exitNonUserCodeStatement}
	binding := tx.createForOfBindingStatement(node.Initializer, value)
	statements = append(statements, tx.Visitor().VisitNode(binding))

	var bodyLocation core.TextRange
	var statementsLocation core.TextRange
	statement := tx.Visitor().VisitEmbeddedStatement(node.Statement)
	if ast.IsBlock(statement) {
		statements = append(statements, statement.Statements()...)
		bodyLocation = statement.Loc
		statementsLocation = statement.StatementList().Loc
	} else {
		statements = append(statements, statement)
	}

	stmtList := f.NewNodeList(statements)
	stmtList.Loc = statementsLocation
	block := f.NewBlock(stmtList, true)
	block.Loc = bodyLocation
	return block
}

// createForOfBindingStatement creates a statement to bind the iteration value.
func (tx *forawaitTransformer) createForOfBindingStatement(node *ast.Node, boundValue *ast.Node) *ast.Node {
	f := tx.Factory()
	if ast.IsVariableDeclarationList(node) {
		firstDeclaration := node.AsVariableDeclarationList().Declarations.Nodes[0]
		updatedDeclaration := f.UpdateVariableDeclaration(
			firstDeclaration.AsVariableDeclaration(),
			firstDeclaration.Name(),
			nil, /*exclamationToken*/
			nil, /*type*/
			boundValue,
		)
		statement := f.NewVariableStatement(
			nil,
			f.UpdateVariableDeclarationList(
				node.AsVariableDeclarationList(),
				f.NewNodeList([]*ast.Node{updatedDeclaration}),
			),
		)
		statement.Loc = node.Loc
		return statement
	}
	updatedExpression := f.NewAssignmentExpression(node, boundValue)
	updatedExpression.Loc = node.Loc
	statement := f.NewExpressionStatement(updatedExpression)
	statement.Loc = node.Loc
	return statement
}

func (tx *forawaitTransformer) transformForAwaitOfStatement(node *ast.ForInOrOfStatement, outermostLabeledStatement *ast.LabeledStatement, ancestorFacts hierarchyFacts) *ast.Node {
	f := tx.Factory()
	expression := tx.Visitor().VisitNode(node.Expression)

	var iterator *ast.Node
	if ast.IsIdentifier(expression) {
		iterator = f.NewGeneratedNameForNode(expression)
	} else {
		iterator = f.NewTempVariable()
	}

	var result *ast.Node
	if ast.IsIdentifier(expression) {
		result = f.NewGeneratedNameForNode(iterator)
	} else {
		result = f.NewTempVariable()
	}

	nonUserCode := f.NewTempVariable()
	done := f.NewTempVariable()
	tx.EmitContext().AddVariableDeclaration(done)
	errorRecord := f.NewUniqueName("e")
	catchVariable := f.NewGeneratedNameForNode(errorRecord)
	returnMethod := f.NewTempVariable()
	callValues := f.NewAsyncValuesHelper(expression)
	callValues.Loc = node.Expression.Loc
	callNext := f.NewCallExpression(
		f.NewPropertyAccessExpression(iterator, nil, f.NewIdentifier("next"), ast.NodeFlagsNone),
		nil, nil,
		f.NewNodeList([]*ast.Node{}),
		ast.NodeFlagsNone,
	)
	getDone := f.NewPropertyAccessExpression(result, nil, f.NewIdentifier("done"), ast.NodeFlagsNone)
	getValue := f.NewPropertyAccessExpression(result, nil, f.NewIdentifier("value"), ast.NodeFlagsNone)
	callReturn := f.NewFunctionCallCall(returnMethod, iterator, []*ast.Node{})

	tx.EmitContext().AddVariableDeclaration(errorRecord)
	tx.EmitContext().AddVariableDeclaration(returnMethod)

	// if we are enclosed in an outer loop ensure we reset 'errorRecord' per each iteration
	var initializer *ast.Node
	if ancestorFacts&hierarchyFactsIterationContainer != 0 {
		initializer = f.InlineExpressions([]*ast.Node{
			f.NewAssignmentExpression(errorRecord, f.NewVoidZeroExpression()),
			callValues,
		})
	} else {
		initializer = callValues
	}

	// Build the for statement
	varDeclList := f.NewVariableDeclarationList(ast.NodeFlagsNone, f.NewNodeList([]*ast.Node{
		f.NewVariableDeclaration(nonUserCode, nil, nil, f.NewKeywordExpression(ast.KindTrueKeyword)),
		f.NewVariableDeclaration(iterator, nil, nil, initializer),
		f.NewVariableDeclaration(result, nil, nil, nil),
	}))
	varDeclList.Loc = node.Expression.Loc
	tx.EmitContext().AddEmitFlags(varDeclList, printer.EFNoHoisting)

	condition := f.InlineExpressions([]*ast.Node{
		f.NewAssignmentExpression(result, tx.createDownlevelAwait(callNext)),
		f.NewAssignmentExpression(done, getDone),
		f.NewPrefixUnaryExpression(ast.KindExclamationToken, done),
	})

	incrementor := f.NewAssignmentExpression(nonUserCode, f.NewKeywordExpression(ast.KindTrueKeyword))

	forStatement := f.NewForStatement(
		varDeclList,
		condition,
		incrementor,
		tx.convertForOfStatementHead(node, getValue, nonUserCode),
	)
	forStatement.Loc = node.Loc
	tx.EmitContext().AddEmitFlags(forStatement, printer.EFNoTokenTrailingSourceMaps)
	tx.EmitContext().SetOriginal(forStatement, node.AsNode())

	// Build the try/catch/finally
	tryBlock := f.NewBlock(f.NewNodeList([]*ast.Node{
		tx.restoreEnclosingLabel(forStatement, outermostLabeledStatement),
	}), true)

	// catch clause: { e_1 = { error: e_2 }; }
	catchBody := f.NewBlock(f.NewNodeList([]*ast.Node{
		f.NewExpressionStatement(
			f.NewAssignmentExpression(
				errorRecord,
				f.NewObjectLiteralExpression(f.NewNodeList([]*ast.Node{
					f.NewPropertyAssignment(nil, f.NewIdentifier("error"), nil, nil, catchVariable),
				}), false),
			),
		),
	}), false)
	tx.EmitContext().AddEmitFlags(catchBody, printer.EFSingleLine)
	catchClause := f.NewCatchClause(
		f.NewVariableDeclaration(catchVariable, nil, nil, nil),
		catchBody,
	)

	// finally block
	// inner try: if (!nonUserCode && !done && (returnMethod = iterator.return)) await returnMethod.call(iterator);
	innerIfCondition := f.NewBinaryExpression(
		nil,
		f.NewBinaryExpression(
			nil,
			f.NewPrefixUnaryExpression(ast.KindExclamationToken, nonUserCode),
			nil,
			f.NewToken(ast.KindAmpersandAmpersandToken),
			f.NewPrefixUnaryExpression(ast.KindExclamationToken, done),
		),
		nil,
		f.NewToken(ast.KindAmpersandAmpersandToken),
		f.NewAssignmentExpression(
			returnMethod,
			f.NewPropertyAccessExpression(iterator, nil, f.NewIdentifier("return"), ast.NodeFlagsNone),
		),
	)
	innerIfStatement := f.NewIfStatement(
		innerIfCondition,
		f.NewExpressionStatement(tx.createDownlevelAwait(callReturn)),
		nil,
	)
	tx.EmitContext().AddEmitFlags(innerIfStatement, printer.EFSingleLine)

	innerTryBlock := f.NewBlock(f.NewNodeList([]*ast.Node{innerIfStatement}), false)

	// inner finally: if (errorRecord) throw errorRecord.error;
	innerFinallyIf := f.NewIfStatement(
		errorRecord,
		f.NewThrowStatement(
			f.NewPropertyAccessExpression(errorRecord, nil, f.NewIdentifier("error"), ast.NodeFlagsNone),
		),
		nil,
	)
	tx.EmitContext().AddEmitFlags(innerFinallyIf, printer.EFSingleLine)
	innerFinallyBlock := f.NewBlock(f.NewNodeList([]*ast.Node{innerFinallyIf}), false)
	tx.EmitContext().AddEmitFlags(innerFinallyBlock, printer.EFSingleLine)

	innerTryStatement := f.NewTryStatement(innerTryBlock, nil, innerFinallyBlock)
	finallyBlock := f.NewBlock(f.NewNodeList([]*ast.Node{innerTryStatement}), true)

	return f.NewTryStatement(tryBlock, catchClause, finallyBlock)
}

func (tx *forawaitTransformer) visitConstructorDeclaration(node *ast.Node) *ast.Node {
	decl := node.AsConstructorDeclaration()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)
	updated := tx.Factory().UpdateConstructorDeclaration(
		decl,
		decl.Modifiers(),
		nil, /*typeParameters*/
		tx.Visitor().VisitNodes(decl.Parameters),
		nil, /*returnType*/
		nil, /*fullSignature*/
		tx.transformFunctionBody(node),
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) visitMethodDeclaration(node *ast.Node) *ast.Node {
	decl := node.AsMethodDeclaration()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)

	var modifiers *ast.ModifierList
	if tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		modifiers = tx.visitorNoAsyncModifier().VisitModifiers(decl.Modifiers())
	} else {
		modifiers = decl.Modifiers()
	}

	var asteriskToken *ast.TokenNode
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 {
		asteriskToken = nil
	} else {
		asteriskToken = decl.AsteriskToken
	}

	var parameters *ast.NodeList
	var body *ast.Node
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 && tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		parameters = tx.transformAsyncGeneratorFunctionParameterList(node)
		body = tx.transformAsyncGeneratorFunctionBody(node)
	} else {
		parameters = tx.Visitor().VisitNodes(decl.Parameters)
		body = tx.transformFunctionBody(node)
	}

	updated := tx.Factory().UpdateMethodDeclaration(
		decl,
		modifiers,
		asteriskToken,
		tx.Visitor().VisitNode(decl.Name()),
		nil, /*postfixToken*/
		nil, /*typeParameters*/
		parameters,
		nil, /*returnType*/
		nil, /*fullSignature*/
		body,
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) visitGetAccessorDeclaration(node *ast.Node) *ast.Node {
	decl := node.AsGetAccessorDeclaration()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)
	updated := tx.Factory().UpdateGetAccessorDeclaration(
		decl,
		decl.Modifiers(),
		tx.Visitor().VisitNode(decl.Name()),
		nil, /*typeParameters*/
		tx.Visitor().VisitNodes(decl.Parameters),
		nil, /*returnType*/
		nil, /*fullSignature*/
		tx.transformFunctionBody(node),
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) visitSetAccessorDeclaration(node *ast.Node) *ast.Node {
	decl := node.AsSetAccessorDeclaration()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)
	updated := tx.Factory().UpdateSetAccessorDeclaration(
		decl,
		decl.Modifiers(),
		tx.Visitor().VisitNode(decl.Name()),
		nil, /*typeParameters*/
		tx.Visitor().VisitNodes(decl.Parameters),
		nil, /*returnType*/
		nil, /*fullSignature*/
		tx.transformFunctionBody(node),
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) visitFunctionDeclaration(node *ast.Node) *ast.Node {
	decl := node.AsFunctionDeclaration()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)

	var modifiers *ast.ModifierList
	if tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		modifiers = tx.visitorNoAsyncModifier().VisitModifiers(decl.Modifiers())
	} else {
		modifiers = decl.Modifiers()
	}

	var asteriskToken *ast.TokenNode
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 {
		asteriskToken = nil
	} else {
		asteriskToken = decl.AsteriskToken
	}

	var parameters *ast.NodeList
	var body *ast.Node
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 && tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		parameters = tx.transformAsyncGeneratorFunctionParameterList(node)
		body = tx.transformAsyncGeneratorFunctionBody(node)
	} else {
		parameters = tx.Visitor().VisitNodes(decl.Parameters)
		body = tx.transformFunctionBody(node)
	}

	updated := tx.Factory().UpdateFunctionDeclaration(
		decl,
		modifiers,
		asteriskToken,
		decl.Name(),
		nil, /*typeParameters*/
		parameters,
		nil, /*returnType*/
		nil, /*fullSignature*/
		body,
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) visitArrowFunction(node *ast.Node) *ast.Node {
	decl := node.AsArrowFunction()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)
	updated := tx.Factory().UpdateArrowFunction(
		decl,
		decl.Modifiers(),
		nil, /*typeParameters*/
		tx.Visitor().VisitNodes(decl.Parameters),
		nil, /*returnType*/
		nil, /*fullSignature*/
		decl.EqualsGreaterThanToken,
		tx.transformFunctionBody(node),
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) visitFunctionExpression(node *ast.Node) *ast.Node {
	decl := node.AsFunctionExpression()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)

	var modifiers *ast.ModifierList
	if tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		modifiers = tx.visitorNoAsyncModifier().VisitModifiers(decl.Modifiers())
	} else {
		modifiers = decl.Modifiers()
	}

	var asteriskToken *ast.TokenNode
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 {
		asteriskToken = nil
	} else {
		asteriskToken = decl.AsteriskToken
	}

	var parameters *ast.NodeList
	var body *ast.Node
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 && tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		parameters = tx.transformAsyncGeneratorFunctionParameterList(node)
		body = tx.transformAsyncGeneratorFunctionBody(node)
	} else {
		parameters = tx.Visitor().VisitNodes(decl.Parameters)
		body = tx.transformFunctionBody(node)
	}

	updated := tx.Factory().UpdateFunctionExpression(
		decl,
		modifiers,
		asteriskToken,
		decl.Name(),
		nil, /*typeParameters*/
		parameters,
		nil, /*returnType*/
		nil, /*fullSignature*/
		body,
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) transformAsyncGeneratorFunctionParameterList(node *ast.Node) *ast.NodeList {
	if isSimpleParameterList(node.Parameters()) {
		return tx.Visitor().VisitNodes(node.ParameterList())
	}
	// Add fixed parameters to preserve the function's `length` property.
	var newParameters []*ast.Node
	for _, parameter := range node.Parameters() {
		param := parameter.AsParameterDeclaration()
		if param.Initializer != nil || param.DotDotDotToken != nil {
			break
		}
		newParameter := tx.Factory().NewParameterDeclaration(
			nil,
			nil,
			tx.Factory().NewGeneratedNameForNodeEx(param.Name(), printer.AutoGenerateOptions{Flags: printer.GeneratedIdentifierFlagsReservedInNestedScopes}),
			nil,
			nil,
			nil,
		)
		newParameters = append(newParameters, newParameter)
	}
	newParametersArray := tx.Factory().NewNodeList(newParameters)
	newParametersArray.Loc = node.ParameterList().Loc
	return newParametersArray
}

func (tx *forawaitTransformer) transformAsyncGeneratorFunctionBody(node *ast.Node) *ast.Node {
	f := tx.Factory()
	innerParameters := (*ast.NodeList)(nil)
	if !isSimpleParameterList(node.Parameters()) {
		innerParameters = tx.Visitor().VisitNodes(node.ParameterList())
	}
	tx.EmitContext().StartVariableEnvironment()

	savedCapturedSuperProperties := tx.capturedSuperProperties
	savedHasSuperElementAccess := tx.hasSuperElementAccess
	tx.capturedSuperProperties = &collections.Set[string]{}
	tx.hasSuperElementAccess = false

	asyncBody := f.UpdateBlock(
		node.Body().AsBlock(),
		tx.Visitor().VisitNodes(node.Body().StatementList()),
	)
	asyncBody = f.UpdateBlock(
		asyncBody.AsBlock(),
		tx.EmitContext().EndAndMergeVariableEnvironmentList(asyncBody.StatementList()),
	)

	var innerParams *ast.NodeList
	if innerParameters != nil {
		innerParams = innerParameters
	} else {
		innerParams = f.NewNodeList([]*ast.Node{})
	}

	var name *ast.Node
	if node.Name() != nil {
		name = f.NewGeneratedNameForNode(node.Name())
	}

	generatorFunc := f.NewFunctionExpression(
		nil, /*modifiers*/
		f.NewToken(ast.KindAsteriskToken),
		name,
		nil, /*typeParameters*/
		innerParams,
		nil, /*returnType*/
		nil, /*fullSignature*/
		asyncBody,
	)

	returnStatement := f.NewReturnStatement(
		f.NewAsyncGeneratorHelper(
			generatorFunc,
			tx.hierarchyFacts&hierarchyFactsHasLexicalThis != 0,
		),
	)

	outerStatements := []*ast.Node{returnStatement}

	block := f.UpdateBlock(node.Body().AsBlock(), f.NewNodeList(outerStatements))

	tx.capturedSuperProperties = savedCapturedSuperProperties
	tx.hasSuperElementAccess = savedHasSuperElementAccess

	return block
}

func (tx *forawaitTransformer) transformFunctionBody(node *ast.Node) *ast.Node {
	tx.EmitContext().StartVariableEnvironment()
	body := tx.Visitor().VisitNode(node.Body())
	extras := tx.EmitContext().EndVariableEnvironment()
	if body == nil {
		body = tx.Factory().NewBlock(tx.Factory().NewNodeList([]*ast.Node{}), true)
	}
	if len(extras) == 0 {
		return body
	}
	if !ast.IsBlock(body) {
		ret := tx.Factory().NewReturnStatement(body)
		ret.Loc = body.Loc
		body = tx.Factory().NewBlock(tx.Factory().NewNodeList([]*ast.Node{ret}), true)
		body.Loc = node.Body().Loc
	}
	block := body.AsBlock()
	prologue, rest := tx.Factory().SplitStandardPrologue(block.Statements.Nodes)
	newStatements := append(prologue, append(extras, rest...)...)
	return tx.Factory().UpdateBlock(block, tx.Factory().NewNodeList(newStatements))
}

func (tx *forawaitTransformer) visitorNoAsyncModifier() *ast.NodeVisitor {
	return tx.EmitContext().NewNodeVisitor(func(node *ast.Node) *ast.Node {
		if node.Kind == ast.KindAsyncKeyword {
			return nil
		}
		return node
	})
}

func newforawaitTransformer(opts *transformers.TransformOptions) *transformers.Transformer {
	tx := &forawaitTransformer{
		compilerOptions: opts.CompilerOptions,
	}
	return tx.NewTransformer(tx.visit, opts.Context)
}
