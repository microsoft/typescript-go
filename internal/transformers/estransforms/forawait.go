package estransforms

import (
	"slices"

	"github.com/microsoft/typescript-go/internal/ast"
	"github.com/microsoft/typescript-go/internal/checker"
	"github.com/microsoft/typescript-go/internal/collections"
	"github.com/microsoft/typescript-go/internal/core"
	"github.com/microsoft/typescript-go/internal/printer"
	"github.com/microsoft/typescript-go/internal/transformers"
)

// Facts we track as we traverse the tree
type forAwaitHierarchyFacts int

const (
	forAwaitHierarchyFactsNone forAwaitHierarchyFacts = 0

	//
	// Ancestor facts
	//

	forAwaitHierarchyFactsHasLexicalThis     forAwaitHierarchyFacts = 1 << 0
	forAwaitHierarchyFactsIterationContainer forAwaitHierarchyFacts = 1 << 1
	// NOTE: do not add more ancestor flags without also updating AncestorFactsMask below.

	//
	// Ancestor masks
	//

	forAwaitHierarchyFactsAncestorFactsMask = (forAwaitHierarchyFactsIterationContainer << 1) - 1

	forAwaitHierarchyFactsSourceFileExcludes           = forAwaitHierarchyFactsIterationContainer
	forAwaitHierarchyFactsStrictModeSourceFileIncludes = forAwaitHierarchyFactsNone

	forAwaitHierarchyFactsClassOrFunctionIncludes = forAwaitHierarchyFactsHasLexicalThis
	forAwaitHierarchyFactsClassOrFunctionExcludes = forAwaitHierarchyFactsIterationContainer

	forAwaitHierarchyFactsArrowFunctionIncludes = forAwaitHierarchyFactsNone
	forAwaitHierarchyFactsArrowFunctionExcludes = forAwaitHierarchyFactsClassOrFunctionExcludes

	forAwaitHierarchyFactsIterationStatementIncludes = forAwaitHierarchyFactsIterationContainer
	forAwaitHierarchyFactsIterationStatementExcludes = forAwaitHierarchyFactsNone
)

type forawaitTransformer struct {
	transformers.Transformer
	compilerOptions *core.CompilerOptions

	enclosingFunctionFlags checker.FunctionFlags
	forAwaitHierarchyFacts forAwaitHierarchyFacts
	// Keeps track of property names accessed on super (`super.x`) within async functions.
	capturedSuperProperties *collections.Set[string]
	// Whether the async function contains an element access on super (`super[x]`).
	hasSuperElementAccess      bool
	hasSuperPropertyAssignment bool
	superBinding               *ast.IdentifierNode
	superIndexBinding          *ast.IdentifierNode
	exportedVariableStatement  bool
}

func (tx *forawaitTransformer) visit(node *ast.Node) *ast.Node {
	if node.SubtreeFacts()&ast.SubtreeContainsForAwaitOrAsyncGenerator == 0 {
		if tx.capturedSuperProperties != nil {
			return tx.superPropertyVisitor(node)
		}
		return node
	}
	switch node.Kind {
	case ast.KindSourceFile:
		return tx.visitSourceFile(node.AsSourceFile())
	case ast.KindAwaitExpression:
		return tx.visitAwaitExpression(node.AsAwaitExpression())
	case ast.KindYieldExpression:
		return tx.visitYieldExpression(node.AsYieldExpression())
	case ast.KindReturnStatement:
		return tx.visitReturnStatement(node.AsReturnStatement())
	case ast.KindLabeledStatement:
		return tx.visitLabeledStatement(node.AsLabeledStatement())
	case ast.KindForOfStatement:
		return tx.visitForOfStatement(node.AsForInOrOfStatement(), nil)
	case ast.KindForStatement, ast.KindDoStatement, ast.KindWhileStatement, ast.KindForInStatement:
		return tx.doWithHierarchyFacts(tx.visitDefault, node, forAwaitHierarchyFactsIterationStatementExcludes, forAwaitHierarchyFactsIterationStatementIncludes)
	case ast.KindConstructor:
		return tx.doWithHierarchyFacts(tx.visitConstructorDeclaration, node, forAwaitHierarchyFactsClassOrFunctionExcludes, forAwaitHierarchyFactsClassOrFunctionIncludes)
	case ast.KindMethodDeclaration:
		return tx.doWithHierarchyFacts(tx.visitMethodDeclaration, node, forAwaitHierarchyFactsClassOrFunctionExcludes, forAwaitHierarchyFactsClassOrFunctionIncludes)
	case ast.KindGetAccessor:
		return tx.doWithHierarchyFacts(tx.visitGetAccessorDeclaration, node, forAwaitHierarchyFactsClassOrFunctionExcludes, forAwaitHierarchyFactsClassOrFunctionIncludes)
	case ast.KindSetAccessor:
		return tx.doWithHierarchyFacts(tx.visitSetAccessorDeclaration, node, forAwaitHierarchyFactsClassOrFunctionExcludes, forAwaitHierarchyFactsClassOrFunctionIncludes)
	case ast.KindFunctionDeclaration:
		return tx.doWithHierarchyFacts(tx.visitFunctionDeclaration, node, forAwaitHierarchyFactsClassOrFunctionExcludes, forAwaitHierarchyFactsClassOrFunctionIncludes)
	case ast.KindFunctionExpression:
		return tx.doWithHierarchyFacts(tx.visitFunctionExpression, node, forAwaitHierarchyFactsClassOrFunctionExcludes, forAwaitHierarchyFactsClassOrFunctionIncludes)
	case ast.KindArrowFunction:
		return tx.doWithHierarchyFacts(tx.visitArrowFunction, node, forAwaitHierarchyFactsArrowFunctionExcludes, forAwaitHierarchyFactsArrowFunctionIncludes)
	case ast.KindPropertyAccessExpression:
		if tx.capturedSuperProperties != nil && node.Expression().Kind == ast.KindSuperKeyword {
			tx.capturedSuperProperties.Add(node.Name().Text())
		}
		return tx.Visitor().VisitEachChild(node)
	case ast.KindElementAccessExpression:
		if tx.capturedSuperProperties != nil && node.Expression().Kind == ast.KindSuperKeyword {
			tx.hasSuperElementAccess = true
		}
		return tx.Visitor().VisitEachChild(node)
	case ast.KindBinaryExpression:
		if tx.capturedSuperProperties != nil && ast.IsAssignmentOperator(node.AsBinaryExpression().OperatorToken.Kind) && assignmentTargetContainsSuperProperty(node.AsBinaryExpression().Left) {
			tx.hasSuperPropertyAssignment = true
		}
		return tx.Visitor().VisitEachChild(node)
	case ast.KindPrefixUnaryExpression:
		if tx.capturedSuperProperties != nil && isUpdateExpression(node) && assignmentTargetContainsSuperProperty(node.AsPrefixUnaryExpression().Operand) {
			tx.hasSuperPropertyAssignment = true
		}
		return tx.Visitor().VisitEachChild(node)
	case ast.KindPostfixUnaryExpression:
		if tx.capturedSuperProperties != nil && isUpdateExpression(node) && assignmentTargetContainsSuperProperty(node.AsPostfixUnaryExpression().Operand) {
			tx.hasSuperPropertyAssignment = true
		}
		return tx.Visitor().VisitEachChild(node)
	case ast.KindClassDeclaration, ast.KindClassExpression:
		return tx.doWithHierarchyFacts(tx.visitDefault, node, forAwaitHierarchyFactsClassOrFunctionExcludes, forAwaitHierarchyFactsClassOrFunctionIncludes)
	default:
		return tx.Visitor().VisitEachChild(node)
	}
}

func (tx *forawaitTransformer) affectsSubtree(excludeFacts forAwaitHierarchyFacts, includeFacts forAwaitHierarchyFacts) bool {
	return tx.forAwaitHierarchyFacts != (tx.forAwaitHierarchyFacts&^excludeFacts | includeFacts)
}

// enterSubtree sets the HierarchyFacts for this node prior to visiting this node's subtree,
// returning the facts set prior to modification.
func (tx *forawaitTransformer) enterSubtree(excludeFacts forAwaitHierarchyFacts, includeFacts forAwaitHierarchyFacts) forAwaitHierarchyFacts {
	ancestorFacts := tx.forAwaitHierarchyFacts
	tx.forAwaitHierarchyFacts = (tx.forAwaitHierarchyFacts&^excludeFacts | includeFacts) & forAwaitHierarchyFactsAncestorFactsMask
	return ancestorFacts
}

// exitSubtree restores the HierarchyFacts for this node's ancestor after visiting this node's
// subtree.
func (tx *forawaitTransformer) exitSubtree(ancestorFacts forAwaitHierarchyFacts) {
	tx.forAwaitHierarchyFacts = ancestorFacts
}

func (tx *forawaitTransformer) doWithHierarchyFacts(cb func(*ast.Node) *ast.Node, node *ast.Node, excludeFacts forAwaitHierarchyFacts, includeFacts forAwaitHierarchyFacts) *ast.Node {
	if tx.affectsSubtree(excludeFacts, includeFacts) {
		ancestorFacts := tx.enterSubtree(excludeFacts, includeFacts)
		result := cb(node)
		tx.exitSubtree(ancestorFacts)
		return result
	}
	return cb(node)
}

func (tx *forawaitTransformer) visitDefault(node *ast.Node) *ast.Node {
	return tx.Visitor().VisitEachChild(node)
}

func (tx *forawaitTransformer) visitSourceFile(node *ast.SourceFile) *ast.Node {
	ancestorFacts := tx.enterSubtree(
		forAwaitHierarchyFactsSourceFileExcludes,
		forAwaitHierarchyFactsStrictModeSourceFileIncludes,
	)
	tx.exportedVariableStatement = false
	visited := tx.Visitor().VisitEachChild(node.AsNode())
	tx.EmitContext().AddEmitHelper(visited, tx.EmitContext().ReadEmitHelpers()...)
	tx.exitSubtree(ancestorFacts)
	return visited
}

func (tx *forawaitTransformer) visitAwaitExpression(node *ast.AwaitExpression) *ast.Node {
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 && tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		result := tx.Factory().NewYieldExpression(
			nil, /*asteriskToken*/
			tx.Factory().NewAwaitHelper(tx.Visitor().VisitNode(node.Expression)),
		)
		result.Loc = node.Loc
		tx.EmitContext().SetOriginal(result, node.AsNode())
		return result
	}
	return tx.Visitor().VisitEachChild(node.AsNode())
}

func (tx *forawaitTransformer) visitYieldExpression(node *ast.YieldExpression) *ast.Node {
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 && tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		if node.AsteriskToken != nil {
			expression := tx.Visitor().VisitNode(node.Expression)

			asyncValuesResult := tx.Factory().NewAsyncValuesHelper(expression)
			asyncValuesResult.Loc = expression.Loc

			asyncDelegatorResult := tx.Factory().NewAsyncDelegatorHelper(asyncValuesResult)
			asyncDelegatorResult.Loc = expression.Loc

			innerYield := tx.Factory().UpdateYieldExpression(
				node,
				node.AsteriskToken,
				asyncDelegatorResult,
			)

			awaitedYield := tx.Factory().NewAwaitHelper(innerYield)

			result := tx.Factory().NewYieldExpression(
				nil, /*asteriskToken*/
				awaitedYield,
			)
			result.Loc = node.Loc
			tx.EmitContext().SetOriginal(result, node.AsNode())
			return result
		}

		var innerExpression *ast.Node
		if node.Expression != nil {
			innerExpression = tx.Visitor().VisitNode(node.Expression)
		} else {
			innerExpression = tx.Factory().NewVoidZeroExpression()
		}

		result := tx.Factory().NewYieldExpression(
			nil, /*asteriskToken*/
			tx.createDownlevelAwait(innerExpression),
		)
		result.Loc = node.Loc
		tx.EmitContext().SetOriginal(result, node.AsNode())
		return result
	}

	return tx.Visitor().VisitEachChild(node.AsNode())
}

func (tx *forawaitTransformer) visitReturnStatement(node *ast.ReturnStatement) *ast.Node {
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 && tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		var expression *ast.Node
		if node.Expression != nil {
			expression = tx.Visitor().VisitNode(node.Expression)
		} else {
			expression = tx.Factory().NewVoidZeroExpression()
		}
		return tx.Factory().UpdateReturnStatement(
			node,
			tx.createDownlevelAwait(expression),
		)
	}

	return tx.Visitor().VisitEachChild(node.AsNode())
}

func (tx *forawaitTransformer) visitLabeledStatement(node *ast.LabeledStatement) *ast.Node {
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 {
		statement := unwrapInnermostStatementOfLabel(node)
		if statement.Kind == ast.KindForOfStatement && statement.AsForInOrOfStatement().AwaitModifier != nil {
			return tx.visitForOfStatement(statement.AsForInOrOfStatement(), node)
		}
		return tx.restoreEnclosingLabel(tx.Visitor().VisitNode(statement), node)
	}
	return tx.Visitor().VisitEachChild(node.AsNode())
}

// unwrapInnermostStatementOfLabel follows LabeledStatement chains to find the innermost statement.
func unwrapInnermostStatementOfLabel(node *ast.LabeledStatement) *ast.Node {
	for {
		if node.Statement.Kind != ast.KindLabeledStatement {
			return node.Statement
		}
		node = node.Statement.AsLabeledStatement()
	}
}

// restoreEnclosingLabel re-wraps a statement with its original label chain.
func (tx *forawaitTransformer) restoreEnclosingLabel(node *ast.Node, outermostLabeledStatement *ast.LabeledStatement) *ast.Node {
	if outermostLabeledStatement == nil {
		return node
	}
	innerLabel := node
	if ast.IsLabeledStatement(outermostLabeledStatement.Statement) {
		innerLabel = tx.restoreEnclosingLabel(node, outermostLabeledStatement.Statement.AsLabeledStatement())
	}
	return tx.Factory().UpdateLabeledStatement(
		outermostLabeledStatement,
		outermostLabeledStatement.Label,
		innerLabel,
	)
}

// visitForOfStatement visits a ForOfStatement and converts it into a ES2015-compatible ForOfStatement.
func (tx *forawaitTransformer) visitForOfStatement(node *ast.ForInOrOfStatement, outermostLabeledStatement *ast.LabeledStatement) *ast.Node {
	ancestorFacts := tx.enterSubtree(forAwaitHierarchyFactsIterationStatementExcludes, forAwaitHierarchyFactsIterationStatementIncludes)
	var result *ast.Node
	if node.AwaitModifier != nil {
		result = tx.transformForAwaitOfStatement(node, outermostLabeledStatement, ancestorFacts)
	} else {
		result = tx.restoreEnclosingLabel(tx.Visitor().VisitEachChild(node.AsNode()), outermostLabeledStatement)
	}
	tx.exitSubtree(ancestorFacts)
	return result
}

func (tx *forawaitTransformer) createDownlevelAwait(expression *ast.Node) *ast.Node {
	if tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		return tx.Factory().NewYieldExpression(
			nil, /*asteriskToken*/
			tx.Factory().NewAwaitHelper(expression),
		)
	}
	return tx.Factory().NewAwaitExpression(expression)
}

func (tx *forawaitTransformer) convertForOfStatementHead(node *ast.ForInOrOfStatement, boundValue *ast.Node, nonUserCode *ast.Node) *ast.Node {
	f := tx.Factory()
	value := f.NewTempVariable()
	tx.EmitContext().AddVariableDeclaration(value)
	iteratorValueExpression := f.NewAssignmentExpression(value, boundValue)
	iteratorValueStatement := f.NewExpressionStatement(iteratorValueExpression)
	tx.EmitContext().SetSourceMapRange(iteratorValueStatement, node.Expression.Loc)

	exitNonUserCodeExpression := f.NewAssignmentExpression(nonUserCode, f.NewKeywordExpression(ast.KindFalseKeyword))
	exitNonUserCodeStatement := f.NewExpressionStatement(exitNonUserCodeExpression)
	tx.EmitContext().SetSourceMapRange(exitNonUserCodeStatement, node.Expression.Loc)

	statements := []*ast.Node{iteratorValueStatement, exitNonUserCodeStatement}
	binding := tx.createForOfBindingStatement(node.Initializer, value)
	statements = append(statements, tx.Visitor().VisitNode(binding))

	var bodyLocation core.TextRange
	var statementsLocation core.TextRange
	statement := tx.Visitor().VisitEmbeddedStatement(node.Statement)
	if ast.IsBlock(statement) {
		statements = append(statements, statement.Statements()...)
		bodyLocation = statement.Loc
		statementsLocation = statement.StatementList().Loc
	} else {
		statements = append(statements, statement)
	}

	stmtList := f.NewNodeList(statements)
	stmtList.Loc = statementsLocation
	block := f.NewBlock(stmtList, true)
	block.Loc = bodyLocation
	return block
}

// createForOfBindingStatement creates a statement to bind the iteration value.
func (tx *forawaitTransformer) createForOfBindingStatement(node *ast.Node, boundValue *ast.Node) *ast.Node {
	f := tx.Factory()
	if ast.IsVariableDeclarationList(node) {
		firstDeclaration := node.AsVariableDeclarationList().Declarations.Nodes[0]
		updatedDeclaration := f.UpdateVariableDeclaration(
			firstDeclaration.AsVariableDeclaration(),
			firstDeclaration.Name(),
			nil, /*exclamationToken*/
			nil, /*type*/
			boundValue,
		)
		statement := f.NewVariableStatement(
			nil,
			f.UpdateVariableDeclarationList(
				node.AsVariableDeclarationList(),
				f.NewNodeList([]*ast.Node{updatedDeclaration}),
			),
		)
		statement.Loc = node.Loc
		return statement
	}
	updatedExpression := f.NewAssignmentExpression(node, boundValue)
	updatedExpression.Loc = node.Loc
	statement := f.NewExpressionStatement(updatedExpression)
	statement.Loc = node.Loc
	return statement
}

func (tx *forawaitTransformer) transformForAwaitOfStatement(node *ast.ForInOrOfStatement, outermostLabeledStatement *ast.LabeledStatement, ancestorFacts forAwaitHierarchyFacts) *ast.Node {
	f := tx.Factory()
	expression := tx.Visitor().VisitNode(node.Expression)

	var iterator *ast.Node
	if ast.IsIdentifier(expression) {
		iterator = f.NewGeneratedNameForNode(expression)
	} else {
		iterator = f.NewTempVariable()
	}

	var result *ast.Node
	if ast.IsIdentifier(expression) {
		result = f.NewGeneratedNameForNode(iterator)
	} else {
		result = f.NewTempVariable()
	}

	nonUserCode := f.NewTempVariable()
	done := f.NewTempVariable()
	tx.EmitContext().AddVariableDeclaration(done)
	errorRecord := f.NewUniqueName("e")
	catchVariable := f.NewGeneratedNameForNode(errorRecord)
	returnMethod := f.NewTempVariable()
	callValues := f.NewAsyncValuesHelper(expression)
	callValues.Loc = node.Expression.Loc
	callNext := f.NewCallExpression(
		f.NewPropertyAccessExpression(iterator, nil, f.NewIdentifier("next"), ast.NodeFlagsNone),
		nil, nil,
		f.NewNodeList([]*ast.Node{}),
		ast.NodeFlagsNone,
	)
	getDone := f.NewPropertyAccessExpression(result, nil, f.NewIdentifier("done"), ast.NodeFlagsNone)
	getValue := f.NewPropertyAccessExpression(result, nil, f.NewIdentifier("value"), ast.NodeFlagsNone)
	callReturn := f.NewFunctionCallCall(returnMethod, iterator, []*ast.Node{})

	tx.EmitContext().AddVariableDeclaration(errorRecord)
	tx.EmitContext().AddVariableDeclaration(returnMethod)

	// if we are enclosed in an outer loop ensure we reset 'errorRecord' per each iteration
	var initializer *ast.Node
	if ancestorFacts&forAwaitHierarchyFactsIterationContainer != 0 {
		initializer = f.InlineExpressions([]*ast.Node{
			f.NewAssignmentExpression(errorRecord, f.NewVoidZeroExpression()),
			callValues,
		})
	} else {
		initializer = callValues
	}

	// Build the for statement
	iteratorDecl := f.NewVariableDeclaration(iterator, nil, nil, initializer)
	iteratorDecl.Loc = node.Expression.Loc
	varDeclList := f.NewVariableDeclarationList(ast.NodeFlagsNone, f.NewNodeList([]*ast.Node{
		f.NewVariableDeclaration(nonUserCode, nil, nil, f.NewKeywordExpression(ast.KindTrueKeyword)),
		iteratorDecl,
		f.NewVariableDeclaration(result, nil, nil, nil),
	}))
	varDeclList.Loc = node.Expression.Loc
	tx.EmitContext().AddEmitFlags(varDeclList, printer.EFNoHoisting)

	condition := f.InlineExpressions([]*ast.Node{
		f.NewAssignmentExpression(result, tx.createDownlevelAwait(callNext)),
		f.NewAssignmentExpression(done, getDone),
		f.NewPrefixUnaryExpression(ast.KindExclamationToken, done),
	})

	incrementor := f.NewAssignmentExpression(nonUserCode, f.NewKeywordExpression(ast.KindTrueKeyword))

	forStatement := f.NewForStatement(
		varDeclList,
		condition,
		incrementor,
		tx.convertForOfStatementHead(node, getValue, nonUserCode),
	)
	forStatement.Loc = node.Loc
	tx.EmitContext().AddEmitFlags(forStatement, printer.EFNoTokenTrailingSourceMaps)
	tx.EmitContext().SetOriginal(forStatement, node.AsNode())

	// Build the try/catch/finally
	tryBlock := f.NewBlock(f.NewNodeList([]*ast.Node{
		tx.restoreEnclosingLabel(forStatement, outermostLabeledStatement),
	}), true)

	// catch clause: { e_1 = { error: e_2 }; }
	catchBody := f.NewBlock(f.NewNodeList([]*ast.Node{
		f.NewExpressionStatement(
			f.NewAssignmentExpression(
				errorRecord,
				f.NewObjectLiteralExpression(f.NewNodeList([]*ast.Node{
					f.NewPropertyAssignment(nil, f.NewIdentifier("error"), nil, nil, catchVariable),
				}), false),
			),
		),
	}), false)
	tx.EmitContext().AddEmitFlags(catchBody, printer.EFSingleLine)
	catchClause := f.NewCatchClause(
		f.NewVariableDeclaration(catchVariable, nil, nil, nil),
		catchBody,
	)

	// finally block
	// inner try: if (!nonUserCode && !done && (returnMethod = iterator.return)) await returnMethod.call(iterator);
	innerIfCondition := f.NewBinaryExpression(
		nil,
		f.NewBinaryExpression(
			nil,
			f.NewPrefixUnaryExpression(ast.KindExclamationToken, nonUserCode),
			nil,
			f.NewToken(ast.KindAmpersandAmpersandToken),
			f.NewPrefixUnaryExpression(ast.KindExclamationToken, done),
		),
		nil,
		f.NewToken(ast.KindAmpersandAmpersandToken),
		f.NewAssignmentExpression(
			returnMethod,
			f.NewPropertyAccessExpression(iterator, nil, f.NewIdentifier("return"), ast.NodeFlagsNone),
		),
	)
	innerIfStatement := f.NewIfStatement(
		innerIfCondition,
		f.NewExpressionStatement(tx.createDownlevelAwait(callReturn)),
		nil,
	)
	tx.EmitContext().AddEmitFlags(innerIfStatement, printer.EFSingleLine)

	innerTryBlock := f.NewBlock(f.NewNodeList([]*ast.Node{innerIfStatement}), false)

	// inner finally: if (errorRecord) throw errorRecord.error;
	innerFinallyIf := f.NewIfStatement(
		errorRecord,
		f.NewThrowStatement(
			f.NewPropertyAccessExpression(errorRecord, nil, f.NewIdentifier("error"), ast.NodeFlagsNone),
		),
		nil,
	)
	tx.EmitContext().AddEmitFlags(innerFinallyIf, printer.EFSingleLine)
	innerFinallyBlock := f.NewBlock(f.NewNodeList([]*ast.Node{innerFinallyIf}), false)
	tx.EmitContext().AddEmitFlags(innerFinallyBlock, printer.EFSingleLine)

	innerTryStatement := f.NewTryStatement(innerTryBlock, nil, innerFinallyBlock)
	finallyBlock := f.NewBlock(f.NewNodeList([]*ast.Node{innerTryStatement}), true)

	return f.NewTryStatement(tryBlock, catchClause, finallyBlock)
}

func (tx *forawaitTransformer) visitConstructorDeclaration(node *ast.Node) *ast.Node {
	decl := node.AsConstructorDeclaration()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)
	updated := tx.Factory().UpdateConstructorDeclaration(
		decl,
		decl.Modifiers(),
		nil, /*typeParameters*/
		tx.EmitContext().VisitParameters(decl.Parameters, tx.Visitor()),
		nil, /*returnType*/
		nil, /*fullSignature*/
		tx.EmitContext().VisitFunctionBody(node.Body(), tx.Visitor()),
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) visitMethodDeclaration(node *ast.Node) *ast.Node {
	decl := node.AsMethodDeclaration()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)

	var modifiers *ast.ModifierList
	if tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		modifiers = tx.visitorNoAsyncModifier().VisitModifiers(decl.Modifiers())
	} else {
		modifiers = decl.Modifiers()
	}

	var asteriskToken *ast.TokenNode
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 {
		asteriskToken = nil
	} else {
		asteriskToken = decl.AsteriskToken
	}

	var parameters *ast.NodeList
	var body *ast.Node
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 && tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		parameters = tx.transformAsyncGeneratorFunctionParameterList(node)
		body = tx.transformAsyncGeneratorFunctionBody(node)
	} else {
		parameters = tx.EmitContext().VisitParameters(decl.Parameters, tx.Visitor())
		body = tx.EmitContext().VisitFunctionBody(node.Body(), tx.Visitor())
	}

	updated := tx.Factory().UpdateMethodDeclaration(
		decl,
		modifiers,
		asteriskToken,
		tx.Visitor().VisitNode(decl.Name()),
		nil, /*postfixToken*/
		nil, /*typeParameters*/
		parameters,
		nil, /*returnType*/
		nil, /*fullSignature*/
		body,
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) visitGetAccessorDeclaration(node *ast.Node) *ast.Node {
	decl := node.AsGetAccessorDeclaration()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)
	updated := tx.Factory().UpdateGetAccessorDeclaration(
		decl,
		decl.Modifiers(),
		tx.Visitor().VisitNode(decl.Name()),
		nil, /*typeParameters*/
		tx.EmitContext().VisitParameters(decl.Parameters, tx.Visitor()),
		nil, /*returnType*/
		nil, /*fullSignature*/
		tx.EmitContext().VisitFunctionBody(node.Body(), tx.Visitor()),
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) visitSetAccessorDeclaration(node *ast.Node) *ast.Node {
	decl := node.AsSetAccessorDeclaration()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)
	updated := tx.Factory().UpdateSetAccessorDeclaration(
		decl,
		decl.Modifiers(),
		tx.Visitor().VisitNode(decl.Name()),
		nil, /*typeParameters*/
		tx.EmitContext().VisitParameters(decl.Parameters, tx.Visitor()),
		nil, /*returnType*/
		nil, /*fullSignature*/
		tx.EmitContext().VisitFunctionBody(node.Body(), tx.Visitor()),
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) visitFunctionDeclaration(node *ast.Node) *ast.Node {
	decl := node.AsFunctionDeclaration()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)

	var modifiers *ast.ModifierList
	if tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		modifiers = tx.visitorNoAsyncModifier().VisitModifiers(decl.Modifiers())
	} else {
		modifiers = decl.Modifiers()
	}

	var asteriskToken *ast.TokenNode
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 {
		asteriskToken = nil
	} else {
		asteriskToken = decl.AsteriskToken
	}

	var parameters *ast.NodeList
	var body *ast.Node
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 && tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		parameters = tx.transformAsyncGeneratorFunctionParameterList(node)
		body = tx.transformAsyncGeneratorFunctionBody(node)
	} else {
		parameters = tx.EmitContext().VisitParameters(decl.Parameters, tx.Visitor())
		body = tx.EmitContext().VisitFunctionBody(node.Body(), tx.Visitor())
	}

	updated := tx.Factory().UpdateFunctionDeclaration(
		decl,
		modifiers,
		asteriskToken,
		decl.Name(),
		nil, /*typeParameters*/
		parameters,
		nil, /*returnType*/
		nil, /*fullSignature*/
		body,
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) visitArrowFunction(node *ast.Node) *ast.Node {
	decl := node.AsArrowFunction()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)
	updated := tx.Factory().UpdateArrowFunction(
		decl,
		decl.Modifiers(),
		nil, /*typeParameters*/
		tx.EmitContext().VisitParameters(decl.Parameters, tx.Visitor()),
		nil, /*returnType*/
		nil, /*fullSignature*/
		decl.EqualsGreaterThanToken,
		tx.EmitContext().VisitFunctionBody(node.Body(), tx.Visitor()),
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) visitFunctionExpression(node *ast.Node) *ast.Node {
	decl := node.AsFunctionExpression()
	savedEnclosingFunctionFlags := tx.enclosingFunctionFlags
	tx.enclosingFunctionFlags = getFunctionFlags(node)

	var modifiers *ast.ModifierList
	if tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		modifiers = tx.visitorNoAsyncModifier().VisitModifiers(decl.Modifiers())
	} else {
		modifiers = decl.Modifiers()
	}

	var asteriskToken *ast.TokenNode
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 {
		asteriskToken = nil
	} else {
		asteriskToken = decl.AsteriskToken
	}

	var parameters *ast.NodeList
	var body *ast.Node
	if tx.enclosingFunctionFlags&checker.FunctionFlagsAsync != 0 && tx.enclosingFunctionFlags&checker.FunctionFlagsGenerator != 0 {
		parameters = tx.transformAsyncGeneratorFunctionParameterList(node)
		body = tx.transformAsyncGeneratorFunctionBody(node)
	} else {
		parameters = tx.EmitContext().VisitParameters(decl.Parameters, tx.Visitor())
		body = tx.EmitContext().VisitFunctionBody(node.Body(), tx.Visitor())
	}

	updated := tx.Factory().UpdateFunctionExpression(
		decl,
		modifiers,
		asteriskToken,
		decl.Name(),
		nil, /*typeParameters*/
		parameters,
		nil, /*returnType*/
		nil, /*fullSignature*/
		body,
	)
	tx.enclosingFunctionFlags = savedEnclosingFunctionFlags
	return updated
}

func (tx *forawaitTransformer) transformAsyncGeneratorFunctionParameterList(node *ast.Node) *ast.NodeList {
	if isSimpleParameterList(node.Parameters()) {
		return tx.Visitor().VisitNodes(node.ParameterList())
	}
	// Add fixed parameters to preserve the function's `length` property.
	var newParameters []*ast.Node
	for _, parameter := range node.Parameters() {
		param := parameter.AsParameterDeclaration()
		if param.Initializer != nil || param.DotDotDotToken != nil {
			break
		}
		newParameter := tx.Factory().NewParameterDeclaration(
			nil,
			nil,
			tx.Factory().NewGeneratedNameForNodeEx(param.Name(), printer.AutoGenerateOptions{Flags: printer.GeneratedIdentifierFlagsReservedInNestedScopes}),
			nil,
			nil,
			nil,
		)
		newParameters = append(newParameters, newParameter)
	}
	newParametersArray := tx.Factory().NewNodeList(newParameters)
	newParametersArray.Loc = node.ParameterList().Loc
	return newParametersArray
}

func (tx *forawaitTransformer) transformAsyncGeneratorFunctionBody(node *ast.Node) *ast.Node {
	f := tx.Factory()
	innerParameters := (*ast.NodeList)(nil)
	if !isSimpleParameterList(node.Parameters()) {
		innerParameters = tx.Visitor().VisitNodes(node.ParameterList())
	}
	tx.EmitContext().StartVariableEnvironment()

	savedCapturedSuperProperties := tx.capturedSuperProperties
	savedHasSuperElementAccess := tx.hasSuperElementAccess
	savedHasSuperPropertyAssignment := tx.hasSuperPropertyAssignment
	savedSuperBinding := tx.superBinding
	savedSuperIndexBinding := tx.superIndexBinding
	tx.capturedSuperProperties = &collections.Set[string]{}
	tx.hasSuperElementAccess = false
	tx.hasSuperPropertyAssignment = false
	tx.superBinding = f.NewUniqueNameEx("_super", printer.AutoGenerateOptions{Flags: printer.GeneratedIdentifierFlagsOptimistic | printer.GeneratedIdentifierFlagsFileLevel})
	tx.superIndexBinding = f.NewUniqueNameEx("_superIndex", printer.AutoGenerateOptions{Flags: printer.GeneratedIdentifierFlagsOptimistic | printer.GeneratedIdentifierFlagsFileLevel})

	asyncBody := f.UpdateBlock(
		node.Body().AsBlock(),
		tx.Visitor().VisitNodes(node.Body().StatementList()),
	)
	asyncBody = f.UpdateBlock(
		asyncBody.AsBlock(),
		tx.EmitContext().EndAndMergeVariableEnvironmentList(asyncBody.StatementList()),
	)

	// Substitute super property accesses with _super/_superIndex helpers
	emitSuperHelpers := tx.capturedSuperProperties.Len() > 0 || tx.hasSuperElementAccess
	if emitSuperHelpers {
		asyncBody = tx.substituteSuperAccessesInBody(asyncBody)
	}

	var innerParams *ast.NodeList
	if innerParameters != nil {
		innerParams = innerParameters
	} else {
		innerParams = f.NewNodeList([]*ast.Node{})
	}

	var name *ast.Node
	if node.Name() != nil {
		name = f.NewGeneratedNameForNode(node.Name())
	}

	generatorFunc := f.NewFunctionExpression(
		nil, /*modifiers*/
		f.NewToken(ast.KindAsteriskToken),
		name,
		nil, /*typeParameters*/
		innerParams,
		nil, /*returnType*/
		nil, /*fullSignature*/
		asyncBody,
	)

	returnStatement := f.NewReturnStatement(
		f.NewAsyncGeneratorHelper(
			generatorFunc,
			tx.forAwaitHierarchyFacts&forAwaitHierarchyFactsHasLexicalThis != 0,
		),
	)

	tx.EmitContext().StartVariableEnvironment()
	if emitSuperHelpers {
		if tx.capturedSuperProperties.Len() > 0 {
			tx.EmitContext().AddInitializationStatement(tx.createSuperAccessVariableStatement())
		}
	}

	outerStatements := []*ast.Node{returnStatement}

	block := f.UpdateBlock(
		node.Body().AsBlock(),
		tx.EmitContext().EndAndMergeVariableEnvironmentList(f.NewNodeList(outerStatements)),
	)

	if emitSuperHelpers && tx.hasSuperElementAccess {
		if tx.hasSuperPropertyAssignment {
			tx.EmitContext().AddEmitHelper(block, printer.AdvancedAsyncSuperHelper)
		} else {
			tx.EmitContext().AddEmitHelper(block, printer.AsyncSuperHelper)
		}
	}

	tx.capturedSuperProperties = savedCapturedSuperProperties
	tx.hasSuperElementAccess = savedHasSuperElementAccess
	tx.hasSuperPropertyAssignment = savedHasSuperPropertyAssignment
	tx.superBinding = savedSuperBinding
	tx.superIndexBinding = savedSuperIndexBinding

	return block
}

func (tx *forawaitTransformer) visitorNoAsyncModifier() *ast.NodeVisitor {
	return tx.EmitContext().NewNodeVisitor(func(node *ast.Node) *ast.Node {
		if node.Kind == ast.KindAsyncKeyword {
			return nil
		}
		return node
	})
}

func (tx *forawaitTransformer) superPropertyVisitor(node *ast.Node) *ast.Node {
	switch node.Kind {
	case ast.KindFunctionExpression, ast.KindFunctionDeclaration,
		ast.KindMethodDeclaration, ast.KindGetAccessor, ast.KindSetAccessor,
		ast.KindConstructor:
		return node
	case ast.KindPropertyAccessExpression:
		if node.Expression().Kind == ast.KindSuperKeyword {
			tx.capturedSuperProperties.Add(node.Name().Text())
		}
	case ast.KindElementAccessExpression:
		if node.Expression().Kind == ast.KindSuperKeyword {
			tx.hasSuperElementAccess = true
		}
	case ast.KindBinaryExpression:
		if ast.IsAssignmentOperator(node.AsBinaryExpression().OperatorToken.Kind) && assignmentTargetContainsSuperProperty(node.AsBinaryExpression().Left) {
			tx.hasSuperPropertyAssignment = true
		}
	case ast.KindPrefixUnaryExpression:
		if isUpdateExpression(node) && assignmentTargetContainsSuperProperty(node.AsPrefixUnaryExpression().Operand) {
			tx.hasSuperPropertyAssignment = true
		}
	case ast.KindPostfixUnaryExpression:
		if isUpdateExpression(node) && assignmentTargetContainsSuperProperty(node.AsPostfixUnaryExpression().Operand) {
			tx.hasSuperPropertyAssignment = true
		}
	}
	return tx.Visitor().VisitEachChild(node)
}

// substituteSuperAccessesInBody walks the async generator body and replaces super property/element
// accesses with _super/_superIndex references. This is necessary because the async generator body
// ends up inside a generator function where `super` is not valid.
func (tx *forawaitTransformer) substituteSuperAccessesInBody(body *ast.Node) *ast.Node {
	var visitor *ast.NodeVisitor
	var doVisit func(node *ast.Node) *ast.Node
	doVisit = func(node *ast.Node) *ast.Node {
		switch node.Kind {
		case ast.KindCallExpression:
			call := node.AsCallExpression()
			if isSuperProperty(call.Expression) {
				return tx.substituteCallExpressionWithSuperAccess(call, visitor)
			}
			return visitor.VisitEachChild(node)
		case ast.KindPropertyAccessExpression:
			if node.Expression().Kind == ast.KindSuperKeyword {
				return tx.Factory().NewPropertyAccessExpression(
					tx.superBinding, nil, node.Name(), ast.NodeFlagsNone,
				)
			}
			return visitor.VisitEachChild(node)
		case ast.KindElementAccessExpression:
			if node.Expression().Kind == ast.KindSuperKeyword {
				return tx.createSuperElementAccessInAsyncMethod(
					node.AsElementAccessExpression().ArgumentExpression,
				)
			}
			return visitor.VisitEachChild(node)
		case ast.KindFunctionExpression, ast.KindFunctionDeclaration,
			ast.KindMethodDeclaration, ast.KindGetAccessor, ast.KindSetAccessor,
			ast.KindConstructor, ast.KindClassDeclaration, ast.KindClassExpression:
			return node
		default:
			return visitor.VisitEachChild(node)
		}
	}
	visitor = tx.EmitContext().NewNodeVisitor(doVisit)
	return visitor.VisitNode(body)
}

func (tx *forawaitTransformer) substituteCallExpressionWithSuperAccess(call *ast.CallExpression, visitor *ast.NodeVisitor) *ast.Node {
	expression := call.Expression
	var target *ast.Node

	if ast.IsPropertyAccessExpression(expression) {
		target = tx.Factory().NewPropertyAccessExpression(
			tx.superBinding, nil,
			expression.AsPropertyAccessExpression().Name(), ast.NodeFlagsNone,
		)
	} else if ast.IsElementAccessExpression(expression) {
		target = tx.createSuperElementAccessInAsyncMethod(
			expression.AsElementAccessExpression().ArgumentExpression,
		)
	} else {
		return visitor.VisitEachChild(call.AsNode())
	}

	callTarget := tx.Factory().NewPropertyAccessExpression(
		target, nil,
		tx.Factory().NewIdentifier("call"), ast.NodeFlagsNone,
	)

	var allArgs []*ast.Node
	allArgs = append(allArgs, tx.Factory().NewThisExpression())
	if call.Arguments != nil {
		visitedArgs := visitor.VisitNodes(call.Arguments)
		if visitedArgs != nil {
			allArgs = append(allArgs, visitedArgs.Nodes...)
		}
	}

	result := tx.Factory().NewCallExpression(
		callTarget, nil, nil,
		tx.Factory().NewNodeList(allArgs), ast.NodeFlagsNone,
	)
	result.Loc = call.Loc
	return result
}

func (tx *forawaitTransformer) createSuperElementAccessInAsyncMethod(argumentExpression *ast.Node) *ast.Node {
	superIndexCall := tx.Factory().NewCallExpression(
		tx.superIndexBinding, nil, nil,
		tx.Factory().NewNodeList([]*ast.Node{argumentExpression}),
		ast.NodeFlagsNone,
	)
	if tx.hasSuperPropertyAssignment {
		return tx.Factory().NewPropertyAccessExpression(
			superIndexCall, nil,
			tx.Factory().NewIdentifier("value"), ast.NodeFlagsNone,
		)
	}
	return superIndexCall
}

func (tx *forawaitTransformer) createSuperAccessVariableStatement() *ast.Node {
	f := tx.Factory()
	var accessors []*ast.Node

	var sortedNames []string
	for name := range tx.capturedSuperProperties.Keys() {
		sortedNames = append(sortedNames, name)
	}
	slices.Sort(sortedNames)

	for _, name := range sortedNames {
		var descriptorProperties []*ast.Node

		getterBody := f.NewPropertyAccessExpression(
			f.NewKeywordExpression(ast.KindSuperKeyword), nil,
			f.NewIdentifier(name), ast.NodeFlagsNone,
		)
		getterArrow := f.NewArrowFunction(
			nil, nil,
			f.NewNodeList([]*ast.Node{}),
			nil, nil,
			f.NewToken(ast.KindEqualsGreaterThanToken),
			getterBody,
		)
		getter := f.NewPropertyAssignment(nil, f.NewIdentifier("get"), nil, nil, getterArrow)
		descriptorProperties = append(descriptorProperties, getter)

		if tx.hasSuperPropertyAssignment {
			vParam := f.NewParameterDeclaration(nil, nil, f.NewIdentifier("v"), nil, nil, nil)
			superProp := f.NewPropertyAccessExpression(
				f.NewKeywordExpression(ast.KindSuperKeyword), nil,
				f.NewIdentifier(name), ast.NodeFlagsNone,
			)
			assignExpr := f.NewAssignmentExpression(superProp, f.NewIdentifier("v"))
			setterArrow := f.NewArrowFunction(
				nil, nil,
				f.NewNodeList([]*ast.Node{vParam}),
				nil, nil,
				f.NewToken(ast.KindEqualsGreaterThanToken),
				assignExpr,
			)
			setter := f.NewPropertyAssignment(nil, f.NewIdentifier("set"), nil, nil, setterArrow)
			descriptorProperties = append(descriptorProperties, setter)
		}

		descriptor := f.NewObjectLiteralExpression(f.NewNodeList(descriptorProperties), false)
		accessor := f.NewPropertyAssignment(nil, f.NewIdentifier(name), nil, nil, descriptor)
		accessors = append(accessors, accessor)
	}

	descriptorsObject := f.NewObjectLiteralExpression(f.NewNodeList(accessors), true)

	objectCreateCall := f.NewCallExpression(
		f.NewPropertyAccessExpression(
			f.NewIdentifier("Object"), nil,
			f.NewIdentifier("create"), ast.NodeFlagsNone,
		), nil, nil,
		f.NewNodeList([]*ast.Node{
			f.NewKeywordExpression(ast.KindNullKeyword),
			descriptorsObject,
		}),
		ast.NodeFlagsNone,
	)

	decl := f.NewVariableDeclaration(tx.superBinding, nil, nil, objectCreateCall)
	declList := f.NewVariableDeclarationList(ast.NodeFlagsConst, f.NewNodeList([]*ast.Node{decl}))
	return f.NewVariableStatement(nil, declList)
}

func newforawaitTransformer(opts *transformers.TransformOptions) *transformers.Transformer {
	tx := &forawaitTransformer{
		compilerOptions: opts.CompilerOptions,
	}
	return tx.NewTransformer(tx.visit, opts.Context)
}
