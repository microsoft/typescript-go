// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package projecttestutil

import (
	"sync"

	"github.com/microsoft/typescript-go/internal/lsp/lsproto"
	"github.com/microsoft/typescript-go/internal/project"
)

// Ensure, that ClientMock does implement project.Client.
// If this is not the case, regenerate this file with moq.
var _ project.Client = &ClientMock{}

// ClientMock is a mock implementation of project.Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked project.Client
//		mockedClient := &ClientMock{
//			RefreshDiagnosticsFunc: func() error {
//				panic("mock out the RefreshDiagnostics method")
//			},
//			UnwatchFilesFunc: func(handle project.WatcherHandle) error {
//				panic("mock out the UnwatchFiles method")
//			},
//			WatchFilesFunc: func(watchers []*lsproto.FileSystemWatcher) (project.WatcherHandle, error) {
//				panic("mock out the WatchFiles method")
//			},
//		}
//
//		// use mockedClient in code that requires project.Client
//		// and then make assertions.
//
//	}
type ClientMock struct {
	// RefreshDiagnosticsFunc mocks the RefreshDiagnostics method.
	RefreshDiagnosticsFunc func() error

	// UnwatchFilesFunc mocks the UnwatchFiles method.
	UnwatchFilesFunc func(handle project.WatcherHandle) error

	// WatchFilesFunc mocks the WatchFiles method.
	WatchFilesFunc func(watchers []*lsproto.FileSystemWatcher) (project.WatcherHandle, error)

	// calls tracks calls to the methods.
	calls struct {
		// RefreshDiagnostics holds details about calls to the RefreshDiagnostics method.
		RefreshDiagnostics []struct {
		}
		// UnwatchFiles holds details about calls to the UnwatchFiles method.
		UnwatchFiles []struct {
			// Handle is the handle argument value.
			Handle project.WatcherHandle
		}
		// WatchFiles holds details about calls to the WatchFiles method.
		WatchFiles []struct {
			// Watchers is the watchers argument value.
			Watchers []*lsproto.FileSystemWatcher
		}
	}
	lockRefreshDiagnostics sync.RWMutex
	lockUnwatchFiles       sync.RWMutex
	lockWatchFiles         sync.RWMutex
}

// RefreshDiagnostics calls RefreshDiagnosticsFunc.
func (mock *ClientMock) RefreshDiagnostics() error {
	callInfo := struct {
	}{}
	mock.lockRefreshDiagnostics.Lock()
	mock.calls.RefreshDiagnostics = append(mock.calls.RefreshDiagnostics, callInfo)
	mock.lockRefreshDiagnostics.Unlock()
	if mock.RefreshDiagnosticsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.RefreshDiagnosticsFunc()
}

// RefreshDiagnosticsCalls gets all the calls that were made to RefreshDiagnostics.
// Check the length with:
//
//	len(mockedClient.RefreshDiagnosticsCalls())
func (mock *ClientMock) RefreshDiagnosticsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRefreshDiagnostics.RLock()
	calls = mock.calls.RefreshDiagnostics
	mock.lockRefreshDiagnostics.RUnlock()
	return calls
}

// UnwatchFiles calls UnwatchFilesFunc.
func (mock *ClientMock) UnwatchFiles(handle project.WatcherHandle) error {
	callInfo := struct {
		Handle project.WatcherHandle
	}{
		Handle: handle,
	}
	mock.lockUnwatchFiles.Lock()
	mock.calls.UnwatchFiles = append(mock.calls.UnwatchFiles, callInfo)
	mock.lockUnwatchFiles.Unlock()
	if mock.UnwatchFilesFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UnwatchFilesFunc(handle)
}

// UnwatchFilesCalls gets all the calls that were made to UnwatchFiles.
// Check the length with:
//
//	len(mockedClient.UnwatchFilesCalls())
func (mock *ClientMock) UnwatchFilesCalls() []struct {
	Handle project.WatcherHandle
} {
	var calls []struct {
		Handle project.WatcherHandle
	}
	mock.lockUnwatchFiles.RLock()
	calls = mock.calls.UnwatchFiles
	mock.lockUnwatchFiles.RUnlock()
	return calls
}

// WatchFiles calls WatchFilesFunc.
func (mock *ClientMock) WatchFiles(watchers []*lsproto.FileSystemWatcher) (project.WatcherHandle, error) {
	callInfo := struct {
		Watchers []*lsproto.FileSystemWatcher
	}{
		Watchers: watchers,
	}
	mock.lockWatchFiles.Lock()
	mock.calls.WatchFiles = append(mock.calls.WatchFiles, callInfo)
	mock.lockWatchFiles.Unlock()
	if mock.WatchFilesFunc == nil {
		var (
			watcherHandleOut project.WatcherHandle
			errOut           error
		)
		return watcherHandleOut, errOut
	}
	return mock.WatchFilesFunc(watchers)
}

// WatchFilesCalls gets all the calls that were made to WatchFiles.
// Check the length with:
//
//	len(mockedClient.WatchFilesCalls())
func (mock *ClientMock) WatchFilesCalls() []struct {
	Watchers []*lsproto.FileSystemWatcher
} {
	var calls []struct {
		Watchers []*lsproto.FileSystemWatcher
	}
	mock.lockWatchFiles.RLock()
	calls = mock.calls.WatchFiles
	mock.lockWatchFiles.RUnlock()
	return calls
}
