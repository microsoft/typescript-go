// Code generated by generate.mts; DO NOT EDIT.

package lsproto

import (
	"fmt"

	"github.com/microsoft/typescript-go/internal/json"
)

// Meta model version 3.17.0

// Structures

type ImplementationParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`
}

func (s *ImplementationParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Position           Position               `json:"position"`
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents a location inside a resource, such as a line
// inside a text file.
type Location struct {
	Uri DocumentUri `json:"uri"`

	Range Range `json:"range"`
}

func (s *Location) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri   requiredProp `json:"uri"`
		Range requiredProp `json:"range"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri   DocumentUri `json:"uri"`
		Range Range       `json:"range"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type ImplementationRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *ImplementationRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		Id               *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type TypeDefinitionParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`
}

func (s *TypeDefinitionParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Position           Position               `json:"position"`
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type TypeDefinitionRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *TypeDefinitionRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		Id               *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A workspace folder inside a client.
type WorkspaceFolder struct {
	// The associated URI for this workspace folder.
	Uri URI `json:"uri"`

	// The name of the workspace folder. Used to refer to this
	// workspace folder in the user interface.
	Name string `json:"name"`
}

func (s *WorkspaceFolder) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri  requiredProp `json:"uri"`
		Name requiredProp `json:"name"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.Name {
		return fmt.Errorf("required key 'name' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri  URI    `json:"uri"`
		Name string `json:"name"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters of a `workspace/didChangeWorkspaceFolders` notification.
type DidChangeWorkspaceFoldersParams struct {
	// The actual workspace folder change event.
	Event *WorkspaceFoldersChangeEvent `json:"event"`
}

func (s *DidChangeWorkspaceFoldersParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Event requiredProp `json:"event"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Event {
		return fmt.Errorf("required key 'event' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Event *WorkspaceFoldersChangeEvent `json:"event"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters of a configuration request.
type ConfigurationParams struct {
	Items []*ConfigurationItem `json:"items"`
}

func (s *ConfigurationParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Items requiredProp `json:"items"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Items {
		return fmt.Errorf("required key 'items' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Items []*ConfigurationItem `json:"items"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters for a DocumentColorRequest.
type DocumentColorParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (s *DocumentColorParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents a color range from a document.
type ColorInformation struct {
	// The range in the document where this color appears.
	Range Range `json:"range"`

	// The actual color value for this color range.
	Color Color `json:"color"`
}

func (s *ColorInformation) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range requiredProp `json:"range"`
		Color requiredProp `json:"color"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.Color {
		return fmt.Errorf("required key 'color' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range Range `json:"range"`
		Color Color `json:"color"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type DocumentColorRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *DocumentColorRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		Id               *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters for a ColorPresentationRequest.
type ColorPresentationParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The color to request presentations for.
	Color Color `json:"color"`

	// The range where the color would be inserted. Serves as a context.
	Range Range `json:"range"`
}

func (s *ColorPresentationParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Color        requiredProp `json:"color"`
		Range        requiredProp `json:"range"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Color {
		return fmt.Errorf("required key 'color' is missing")
	}
	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Color              Color                  `json:"color"`
		Range              Range                  `json:"range"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type ColorPresentation struct {
	// The label of this color presentation. It will be shown on the color
	// picker header. By default this is also the text that is inserted when selecting
	// this color presentation.
	Label string `json:"label"`

	// An edit which is applied to a document when selecting
	// this presentation for the color.  When `falsy` the label
	// is used.
	TextEdit *TextEdit `json:"textEdit,omitzero"`

	// An optional array of additional edits that are applied when
	// selecting this color presentation. Edits must not overlap with the main edit nor with themselves.
	AdditionalTextEdits *[]*TextEdit `json:"additionalTextEdits,omitzero"`
}

func (s *ColorPresentation) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Label requiredProp `json:"label"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Label {
		return fmt.Errorf("required key 'label' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Label               string       `json:"label"`
		TextEdit            *TextEdit    `json:"textEdit,omitzero"`
		AdditionalTextEdits *[]*TextEdit `json:"additionalTextEdits,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type WorkDoneProgressOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// General text document registration options.
type TextDocumentRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
}

func (s *TextDocumentRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters for a FoldingRangeRequest.
type FoldingRangeParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (s *FoldingRangeParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents a folding range. To be valid, start and end line must be bigger than zero and smaller
// than the number of lines in the document. Clients are free to ignore invalid ranges.
type FoldingRange struct {
	// The zero-based start line of the range to fold. The folded area starts after the line's last character.
	// To be valid, the end must be zero or larger and smaller than the number of lines in the document.
	StartLine uint32 `json:"startLine"`

	// The zero-based character offset from where the folded range starts. If not defined, defaults to the length of the start line.
	StartCharacter *uint32 `json:"startCharacter,omitzero"`

	// The zero-based end line of the range to fold. The folded area ends with the line's last character.
	// To be valid, the end must be zero or larger and smaller than the number of lines in the document.
	EndLine uint32 `json:"endLine"`

	// The zero-based character offset before the folded range ends. If not defined, defaults to the length of the end line.
	EndCharacter *uint32 `json:"endCharacter,omitzero"`

	// Describes the kind of the folding range such as 'comment' or 'region'. The kind
	// is used to categorize folding ranges and used by commands like 'Fold all comments'.
	// See FoldingRangeKind for an enumeration of standardized kinds.
	Kind *FoldingRangeKind `json:"kind,omitzero"`

	// The text that the client should show when the specified range is
	// collapsed. If not defined or not supported by the client, a default
	// will be chosen by the client.
	//
	// Since: 3.17.0
	CollapsedText *string `json:"collapsedText,omitzero"`
}

func (s *FoldingRange) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		StartLine requiredProp `json:"startLine"`
		EndLine   requiredProp `json:"endLine"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.StartLine {
		return fmt.Errorf("required key 'startLine' is missing")
	}
	if !keys.EndLine {
		return fmt.Errorf("required key 'endLine' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		StartLine      uint32            `json:"startLine"`
		StartCharacter *uint32           `json:"startCharacter,omitzero"`
		EndLine        uint32            `json:"endLine"`
		EndCharacter   *uint32           `json:"endCharacter,omitzero"`
		Kind           *FoldingRangeKind `json:"kind,omitzero"`
		CollapsedText  *string           `json:"collapsedText,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type FoldingRangeRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *FoldingRangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		Id               *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type DeclarationParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`
}

func (s *DeclarationParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Position           Position               `json:"position"`
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type DeclarationRegistrationOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *DeclarationRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		Id               *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A parameter literal used in selection range requests.
type SelectionRangeParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The positions inside the text document.
	Positions []Position `json:"positions"`
}

func (s *SelectionRangeParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Positions    requiredProp `json:"positions"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Positions {
		return fmt.Errorf("required key 'positions' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Positions          []Position             `json:"positions"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A selection range represents a part of a selection hierarchy. A selection range
// may have a parent selection range that contains it.
type SelectionRange struct {
	// The range of this selection range.
	Range Range `json:"range"`

	// The parent selection range containing this range. Therefore `parent.range` must contain `this.range`.
	Parent *SelectionRange `json:"parent,omitzero"`
}

func (s *SelectionRange) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range requiredProp `json:"range"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range  Range           `json:"range"`
		Parent *SelectionRange `json:"parent,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type SelectionRangeRegistrationOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *SelectionRangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		Id               *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type WorkDoneProgressCreateParams struct {
	// The token to be used to report progress.
	Token IntegerOrString `json:"token"`
}

func (s *WorkDoneProgressCreateParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Token requiredProp `json:"token"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Token {
		return fmt.Errorf("required key 'token' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Token IntegerOrString `json:"token"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type WorkDoneProgressCancelParams struct {
	// The token to be used to report progress.
	Token IntegerOrString `json:"token"`
}

func (s *WorkDoneProgressCancelParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Token requiredProp `json:"token"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Token {
		return fmt.Errorf("required key 'token' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Token IntegerOrString `json:"token"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameter of a `textDocument/prepareCallHierarchy` request.
//
// Since: 3.16.0
type CallHierarchyPrepareParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`
}

func (s *CallHierarchyPrepareParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument  TextDocumentIdentifier `json:"textDocument"`
		Position      Position               `json:"position"`
		WorkDoneToken *IntegerOrString       `json:"workDoneToken,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents programming constructs like functions or constructors in the context
// of call hierarchy.
//
// Since: 3.16.0
type CallHierarchyItem struct {
	// The name of this item.
	Name string `json:"name"`

	// The kind of this item.
	Kind SymbolKind `json:"kind"`

	// Tags for this item.
	Tags *[]SymbolTag `json:"tags,omitzero"`

	// More detail for this item, e.g. the signature of a function.
	Detail *string `json:"detail,omitzero"`

	// The resource identifier of this item.
	Uri DocumentUri `json:"uri"`

	// The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
	Range Range `json:"range"`

	// The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
	// Must be contained by the `range`.
	SelectionRange Range `json:"selectionRange"`

	// A data entry field that is preserved between a call hierarchy prepare and
	// incoming calls or outgoing calls requests.
	Data *any `json:"data,omitzero"`
}

func (s *CallHierarchyItem) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Name           requiredProp `json:"name"`
		Kind           requiredProp `json:"kind"`
		Uri            requiredProp `json:"uri"`
		Range          requiredProp `json:"range"`
		SelectionRange requiredProp `json:"selectionRange"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Name {
		return fmt.Errorf("required key 'name' is missing")
	}
	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.SelectionRange {
		return fmt.Errorf("required key 'selectionRange' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Name           string       `json:"name"`
		Kind           SymbolKind   `json:"kind"`
		Tags           *[]SymbolTag `json:"tags,omitzero"`
		Detail         *string      `json:"detail,omitzero"`
		Uri            DocumentUri  `json:"uri"`
		Range          Range        `json:"range"`
		SelectionRange Range        `json:"selectionRange"`
		Data           *any         `json:"data,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Call hierarchy options used during static or dynamic registration.
//
// Since: 3.16.0
type CallHierarchyRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *CallHierarchyRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		Id               *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameter of a `callHierarchy/incomingCalls` request.
//
// Since: 3.16.0
type CallHierarchyIncomingCallsParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	Item *CallHierarchyItem `json:"item"`
}

func (s *CallHierarchyIncomingCallsParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Item requiredProp `json:"item"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Item {
		return fmt.Errorf("required key 'item' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString   `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString   `json:"partialResultToken,omitzero"`
		Item               *CallHierarchyItem `json:"item"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents an incoming call, e.g. a caller of a method or constructor.
//
// Since: 3.16.0
type CallHierarchyIncomingCall struct {
	// The item that makes the call.
	From *CallHierarchyItem `json:"from"`

	// The ranges at which the calls appear. This is relative to the caller
	// denoted by `this.from`.
	FromRanges []Range `json:"fromRanges"`
}

func (s *CallHierarchyIncomingCall) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		From       requiredProp `json:"from"`
		FromRanges requiredProp `json:"fromRanges"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.From {
		return fmt.Errorf("required key 'from' is missing")
	}
	if !keys.FromRanges {
		return fmt.Errorf("required key 'fromRanges' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		From       *CallHierarchyItem `json:"from"`
		FromRanges []Range            `json:"fromRanges"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameter of a `callHierarchy/outgoingCalls` request.
//
// Since: 3.16.0
type CallHierarchyOutgoingCallsParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	Item *CallHierarchyItem `json:"item"`
}

func (s *CallHierarchyOutgoingCallsParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Item requiredProp `json:"item"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Item {
		return fmt.Errorf("required key 'item' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString   `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString   `json:"partialResultToken,omitzero"`
		Item               *CallHierarchyItem `json:"item"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.
//
// Since: 3.16.0
type CallHierarchyOutgoingCall struct {
	// The item that is called.
	To *CallHierarchyItem `json:"to"`

	// The range at which this item is called. This is the range relative to the caller, e.g the item
	// passed to `provideCallHierarchyOutgoingCalls`
	// and not `this.to`.
	FromRanges []Range `json:"fromRanges"`
}

func (s *CallHierarchyOutgoingCall) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		To         requiredProp `json:"to"`
		FromRanges requiredProp `json:"fromRanges"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.To {
		return fmt.Errorf("required key 'to' is missing")
	}
	if !keys.FromRanges {
		return fmt.Errorf("required key 'fromRanges' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		To         *CallHierarchyItem `json:"to"`
		FromRanges []Range            `json:"fromRanges"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.16.0
type SemanticTokensParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (s *SemanticTokensParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.16.0
type SemanticTokens struct {
	// An optional result id. If provided and clients support delta updating
	// the client will include the result id in the next semantic token request.
	// A server can then instead of computing all semantic tokens again simply
	// send a delta.
	ResultId *string `json:"resultId,omitzero"`

	// The actual tokens.
	Data []uint32 `json:"data"`
}

func (s *SemanticTokens) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Data requiredProp `json:"data"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Data {
		return fmt.Errorf("required key 'data' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		ResultId *string  `json:"resultId,omitzero"`
		Data     []uint32 `json:"data"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.16.0
type SemanticTokensPartialResult struct {
	Data []uint32 `json:"data"`
}

func (s *SemanticTokensPartialResult) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Data requiredProp `json:"data"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Data {
		return fmt.Errorf("required key 'data' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Data []uint32 `json:"data"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.16.0
type SemanticTokensRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The legend used by the server
	Legend *SemanticTokensLegend `json:"legend"`

	// Server supports providing semantic tokens for a specific range
	// of a document.
	Range *BooleanOrEmptyObject `json:"range,omitzero"`

	// Server supports providing semantic tokens for a full document.
	Full *BooleanOrSemanticTokensFullDelta `json:"full,omitzero"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *SemanticTokensRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
		Legend           requiredProp `json:"legend"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}
	if !keys.Legend {
		return fmt.Errorf("required key 'legend' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull            `json:"documentSelector"`
		WorkDoneProgress *bool                             `json:"workDoneProgress,omitzero"`
		Legend           *SemanticTokensLegend             `json:"legend"`
		Range            *BooleanOrEmptyObject             `json:"range,omitzero"`
		Full             *BooleanOrSemanticTokensFullDelta `json:"full,omitzero"`
		Id               *string                           `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.16.0
type SemanticTokensDeltaParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The result id of a previous response. The result Id can either point to a full response
	// or a delta response depending on what was received last.
	PreviousResultId string `json:"previousResultId"`
}

func (s *SemanticTokensDeltaParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument     requiredProp `json:"textDocument"`
		PreviousResultId requiredProp `json:"previousResultId"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.PreviousResultId {
		return fmt.Errorf("required key 'previousResultId' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		PreviousResultId   string                 `json:"previousResultId"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.16.0
type SemanticTokensDelta struct {
	ResultId *string `json:"resultId,omitzero"`

	// The semantic token edits to transform a previous result into a new result.
	Edits []*SemanticTokensEdit `json:"edits"`
}

func (s *SemanticTokensDelta) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Edits requiredProp `json:"edits"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Edits {
		return fmt.Errorf("required key 'edits' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		ResultId *string               `json:"resultId,omitzero"`
		Edits    []*SemanticTokensEdit `json:"edits"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.16.0
type SemanticTokensDeltaPartialResult struct {
	Edits []*SemanticTokensEdit `json:"edits"`
}

func (s *SemanticTokensDeltaPartialResult) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Edits requiredProp `json:"edits"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Edits {
		return fmt.Errorf("required key 'edits' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Edits []*SemanticTokensEdit `json:"edits"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.16.0
type SemanticTokensRangeParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The range the semantic tokens are requested for.
	Range Range `json:"range"`
}

func (s *SemanticTokensRangeParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Range        requiredProp `json:"range"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Range              Range                  `json:"range"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Params to show a resource in the UI.
//
// Since: 3.16.0
type ShowDocumentParams struct {
	// The uri to show.
	Uri URI `json:"uri"`

	// Indicates to show the resource in an external program.
	// To show, for example, `https://code.visualstudio.com/`
	// in the default WEB browser set `external` to `true`.
	External *bool `json:"external,omitzero"`

	// An optional property to indicate whether the editor
	// showing the document should take focus or not.
	// Clients might ignore this property if an external
	// program is started.
	TakeFocus *bool `json:"takeFocus,omitzero"`

	// An optional selection range if the document is a text
	// document. Clients might ignore the property if an
	// external program is started or the file is not a text
	// file.
	Selection *Range `json:"selection,omitzero"`
}

func (s *ShowDocumentParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri requiredProp `json:"uri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri       URI    `json:"uri"`
		External  *bool  `json:"external,omitzero"`
		TakeFocus *bool  `json:"takeFocus,omitzero"`
		Selection *Range `json:"selection,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The result of a showDocument request.
//
// Since: 3.16.0
type ShowDocumentResult struct {
	// A boolean indicating if the show was successful.
	Success bool `json:"success"`
}

func (s *ShowDocumentResult) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Success requiredProp `json:"success"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Success {
		return fmt.Errorf("required key 'success' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Success bool `json:"success"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type LinkedEditingRangeParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`
}

func (s *LinkedEditingRangeParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument  TextDocumentIdentifier `json:"textDocument"`
		Position      Position               `json:"position"`
		WorkDoneToken *IntegerOrString       `json:"workDoneToken,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The result of a linked editing range request.
//
// Since: 3.16.0
type LinkedEditingRanges struct {
	// A list of ranges that can be edited together. The ranges must have
	// identical length and contain identical text content. The ranges cannot overlap.
	Ranges []Range `json:"ranges"`

	// An optional word pattern (regular expression) that describes valid contents for
	// the given ranges. If no pattern is provided, the client configuration's word
	// pattern will be used.
	WordPattern *string `json:"wordPattern,omitzero"`
}

func (s *LinkedEditingRanges) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Ranges requiredProp `json:"ranges"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Ranges {
		return fmt.Errorf("required key 'ranges' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Ranges      []Range `json:"ranges"`
		WordPattern *string `json:"wordPattern,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type LinkedEditingRangeRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *LinkedEditingRangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		Id               *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters sent in notifications/requests for user-initiated creation of
// files.
//
// Since: 3.16.0
type CreateFilesParams struct {
	// An array of all files/folders created in this operation.
	Files []*FileCreate `json:"files"`
}

func (s *CreateFilesParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Files requiredProp `json:"files"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Files {
		return fmt.Errorf("required key 'files' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Files []*FileCreate `json:"files"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A workspace edit represents changes to many resources managed in the workspace. The edit
// should either provide `changes` or `documentChanges`. If documentChanges are present
// they are preferred over `changes` if the client can handle versioned document edits.
//
// Since version 3.13.0 a workspace edit can contain resource operations as well. If resource
// operations are present clients need to execute the operations in the order in which they
// are provided. So a workspace edit for example can consist of the following two changes:
// (1) a create file a.txt and (2) a text document edit which insert text into file a.txt.
//
// An invalid sequence (e.g. (1) delete file a.txt and (2) insert text into file a.txt) will
// cause failure of the operation. How the client recovers from the failure is described by
// the client capability: `workspace.workspaceEdit.failureHandling`
type WorkspaceEdit struct {
	// Holds changes to existing resources.
	Changes *map[DocumentUri][]*TextEdit `json:"changes,omitzero"`

	// Depending on the client capability `workspace.workspaceEdit.resourceOperations` document changes
	// are either an array of `TextDocumentEdit`s to express changes to n different text documents
	// where each text document edit addresses a specific version of a text document. Or it can contain
	// above `TextDocumentEdit`s mixed with create, rename and delete file / folder operations.
	//
	// Whether a client supports versioned document edits is expressed via
	// `workspace.workspaceEdit.documentChanges` client capability.
	//
	// If a client neither supports `documentChanges` nor `workspace.workspaceEdit.resourceOperations` then
	// only plain `TextEdit`s using the `changes` property are supported.
	DocumentChanges *[]TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile `json:"documentChanges,omitzero"`

	// A map of change annotations that can be referenced in `AnnotatedTextEdit`s or create, rename and
	// delete file / folder operations.
	//
	// Whether clients honor this property depends on the client capability `workspace.changeAnnotationSupport`.
	//
	// Since: 3.16.0
	ChangeAnnotations *map[string]*ChangeAnnotation `json:"changeAnnotations,omitzero"`
}

// The options to register for file operations.
//
// Since: 3.16.0
type FileOperationRegistrationOptions struct {
	// The actual filters.
	Filters []*FileOperationFilter `json:"filters"`
}

func (s *FileOperationRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Filters requiredProp `json:"filters"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Filters {
		return fmt.Errorf("required key 'filters' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Filters []*FileOperationFilter `json:"filters"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters sent in notifications/requests for user-initiated renames of
// files.
//
// Since: 3.16.0
type RenameFilesParams struct {
	// An array of all files/folders renamed in this operation. When a folder is renamed, only
	// the folder will be included, and not its children.
	Files []*FileRename `json:"files"`
}

func (s *RenameFilesParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Files requiredProp `json:"files"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Files {
		return fmt.Errorf("required key 'files' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Files []*FileRename `json:"files"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters sent in notifications/requests for user-initiated deletes of
// files.
//
// Since: 3.16.0
type DeleteFilesParams struct {
	// An array of all files/folders deleted in this operation.
	Files []*FileDelete `json:"files"`
}

func (s *DeleteFilesParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Files requiredProp `json:"files"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Files {
		return fmt.Errorf("required key 'files' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Files []*FileDelete `json:"files"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type MonikerParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`
}

func (s *MonikerParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Position           Position               `json:"position"`
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Moniker definition to match LSIF 0.5 moniker definition.
//
// Since: 3.16.0
type Moniker struct {
	// The scheme of the moniker. For example tsc or .Net
	Scheme string `json:"scheme"`

	// The identifier of the moniker. The value is opaque in LSIF however
	// schema owners are allowed to define the structure if they want.
	Identifier string `json:"identifier"`

	// The scope in which the moniker is unique
	Unique UniquenessLevel `json:"unique"`

	// The moniker kind if known.
	Kind *MonikerKind `json:"kind,omitzero"`
}

func (s *Moniker) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Scheme     requiredProp `json:"scheme"`
		Identifier requiredProp `json:"identifier"`
		Unique     requiredProp `json:"unique"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Scheme {
		return fmt.Errorf("required key 'scheme' is missing")
	}
	if !keys.Identifier {
		return fmt.Errorf("required key 'identifier' is missing")
	}
	if !keys.Unique {
		return fmt.Errorf("required key 'unique' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Scheme     string          `json:"scheme"`
		Identifier string          `json:"identifier"`
		Unique     UniquenessLevel `json:"unique"`
		Kind       *MonikerKind    `json:"kind,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type MonikerRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

func (s *MonikerRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameter of a `textDocument/prepareTypeHierarchy` request.
//
// Since: 3.17.0
type TypeHierarchyPrepareParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`
}

func (s *TypeHierarchyPrepareParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument  TextDocumentIdentifier `json:"textDocument"`
		Position      Position               `json:"position"`
		WorkDoneToken *IntegerOrString       `json:"workDoneToken,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.17.0
type TypeHierarchyItem struct {
	// The name of this item.
	Name string `json:"name"`

	// The kind of this item.
	Kind SymbolKind `json:"kind"`

	// Tags for this item.
	Tags *[]SymbolTag `json:"tags,omitzero"`

	// More detail for this item, e.g. the signature of a function.
	Detail *string `json:"detail,omitzero"`

	// The resource identifier of this item.
	Uri DocumentUri `json:"uri"`

	// The range enclosing this symbol not including leading/trailing whitespace
	// but everything else, e.g. comments and code.
	Range Range `json:"range"`

	// The range that should be selected and revealed when this symbol is being
	// picked, e.g. the name of a function. Must be contained by the
	// `range`.
	SelectionRange Range `json:"selectionRange"`

	// A data entry field that is preserved between a type hierarchy prepare and
	// supertypes or subtypes requests. It could also be used to identify the
	// type hierarchy in the server, helping improve the performance on
	// resolving supertypes and subtypes.
	Data *any `json:"data,omitzero"`
}

func (s *TypeHierarchyItem) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Name           requiredProp `json:"name"`
		Kind           requiredProp `json:"kind"`
		Uri            requiredProp `json:"uri"`
		Range          requiredProp `json:"range"`
		SelectionRange requiredProp `json:"selectionRange"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Name {
		return fmt.Errorf("required key 'name' is missing")
	}
	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.SelectionRange {
		return fmt.Errorf("required key 'selectionRange' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Name           string       `json:"name"`
		Kind           SymbolKind   `json:"kind"`
		Tags           *[]SymbolTag `json:"tags,omitzero"`
		Detail         *string      `json:"detail,omitzero"`
		Uri            DocumentUri  `json:"uri"`
		Range          Range        `json:"range"`
		SelectionRange Range        `json:"selectionRange"`
		Data           *any         `json:"data,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Type hierarchy options used during static or dynamic registration.
//
// Since: 3.17.0
type TypeHierarchyRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *TypeHierarchyRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		Id               *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameter of a `typeHierarchy/supertypes` request.
//
// Since: 3.17.0
type TypeHierarchySupertypesParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	Item *TypeHierarchyItem `json:"item"`
}

func (s *TypeHierarchySupertypesParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Item requiredProp `json:"item"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Item {
		return fmt.Errorf("required key 'item' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString   `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString   `json:"partialResultToken,omitzero"`
		Item               *TypeHierarchyItem `json:"item"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameter of a `typeHierarchy/subtypes` request.
//
// Since: 3.17.0
type TypeHierarchySubtypesParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	Item *TypeHierarchyItem `json:"item"`
}

func (s *TypeHierarchySubtypesParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Item requiredProp `json:"item"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Item {
		return fmt.Errorf("required key 'item' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString   `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString   `json:"partialResultToken,omitzero"`
		Item               *TypeHierarchyItem `json:"item"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A parameter literal used in inline value requests.
//
// Since: 3.17.0
type InlineValueParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The document range for which inline values should be computed.
	Range Range `json:"range"`

	// Additional information about the context in which inline values were
	// requested.
	Context *InlineValueContext `json:"context"`
}

func (s *InlineValueParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Range        requiredProp `json:"range"`
		Context      requiredProp `json:"context"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.Context {
		return fmt.Errorf("required key 'context' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken *IntegerOrString       `json:"workDoneToken,omitzero"`
		TextDocument  TextDocumentIdentifier `json:"textDocument"`
		Range         Range                  `json:"range"`
		Context       *InlineValueContext    `json:"context"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Inline value options used during static or dynamic registration.
//
// Since: 3.17.0
type InlineValueRegistrationOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *InlineValueRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		Id               *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A parameter literal used in inlay hint requests.
//
// Since: 3.17.0
type InlayHintParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The document range for which inlay hints should be computed.
	Range Range `json:"range"`
}

func (s *InlayHintParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Range        requiredProp `json:"range"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken *IntegerOrString       `json:"workDoneToken,omitzero"`
		TextDocument  TextDocumentIdentifier `json:"textDocument"`
		Range         Range                  `json:"range"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Inlay hint information.
//
// Since: 3.17.0
type InlayHint struct {
	// The position of this hint.
	//
	// If multiple hints have the same position, they will be shown in the order
	// they appear in the response.
	Position Position `json:"position"`

	// The label of this hint. A human readable string or an array of
	// InlayHintLabelPart label parts.
	//
	// *Note* that neither the string nor the label part can be empty.
	Label StringOrInlayHintLabelParts `json:"label"`

	// The kind of this hint. Can be omitted in which case the client
	// should fall back to a reasonable default.
	Kind *InlayHintKind `json:"kind,omitzero"`

	// Optional text edits that are performed when accepting this inlay hint.
	//
	// *Note* that edits are expected to change the document so that the inlay
	// hint (or its nearest variant) is now part of the document and the inlay
	// hint itself is now obsolete.
	TextEdits *[]*TextEdit `json:"textEdits,omitzero"`

	// The tooltip text when you hover over this item.
	Tooltip *StringOrMarkupContent `json:"tooltip,omitzero"`

	// Render padding before the hint.
	//
	// Note: Padding should use the editor's background color, not the
	// background color of the hint itself. That means padding can be used
	// to visually align/separate an inlay hint.
	PaddingLeft *bool `json:"paddingLeft,omitzero"`

	// Render padding after the hint.
	//
	// Note: Padding should use the editor's background color, not the
	// background color of the hint itself. That means padding can be used
	// to visually align/separate an inlay hint.
	PaddingRight *bool `json:"paddingRight,omitzero"`

	// A data entry field that is preserved on an inlay hint between
	// a `textDocument/inlayHint` and a `inlayHint/resolve` request.
	Data *any `json:"data,omitzero"`
}

func (s *InlayHint) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Position requiredProp `json:"position"`
		Label    requiredProp `json:"label"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}
	if !keys.Label {
		return fmt.Errorf("required key 'label' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Position     Position                    `json:"position"`
		Label        StringOrInlayHintLabelParts `json:"label"`
		Kind         *InlayHintKind              `json:"kind,omitzero"`
		TextEdits    *[]*TextEdit                `json:"textEdits,omitzero"`
		Tooltip      *StringOrMarkupContent      `json:"tooltip,omitzero"`
		PaddingLeft  *bool                       `json:"paddingLeft,omitzero"`
		PaddingRight *bool                       `json:"paddingRight,omitzero"`
		Data         *any                        `json:"data,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Inlay hint options used during static or dynamic registration.
//
// Since: 3.17.0
type InlayHintRegistrationOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The server provides support to resolve additional
	// information for an inlay hint item.
	ResolveProvider *bool `json:"resolveProvider,omitzero"`

	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *InlayHintRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		ResolveProvider  *bool                  `json:"resolveProvider,omitzero"`
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		Id               *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters of the document diagnostic request.
//
// Since: 3.17.0
type DocumentDiagnosticParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The additional identifier provided during registration.
	Identifier *string `json:"identifier,omitzero"`

	// The result id of a previous response if provided.
	PreviousResultId *string `json:"previousResultId,omitzero"`
}

func (s *DocumentDiagnosticParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Identifier         *string                `json:"identifier,omitzero"`
		PreviousResultId   *string                `json:"previousResultId,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A partial result for a document diagnostic report.
//
// Since: 3.17.0
type DocumentDiagnosticReportPartialResult struct {
	RelatedDocuments map[DocumentUri]FullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport `json:"relatedDocuments"`
}

func (s *DocumentDiagnosticReportPartialResult) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		RelatedDocuments requiredProp `json:"relatedDocuments"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.RelatedDocuments {
		return fmt.Errorf("required key 'relatedDocuments' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		RelatedDocuments map[DocumentUri]FullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport `json:"relatedDocuments"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Cancellation data returned from a diagnostic request.
//
// Since: 3.17.0
type DiagnosticServerCancellationData struct {
	RetriggerRequest bool `json:"retriggerRequest"`
}

func (s *DiagnosticServerCancellationData) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		RetriggerRequest requiredProp `json:"retriggerRequest"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.RetriggerRequest {
		return fmt.Errorf("required key 'retriggerRequest' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		RetriggerRequest bool `json:"retriggerRequest"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Diagnostic registration options.
//
// Since: 3.17.0
type DiagnosticRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// An optional identifier under which the diagnostics are
	// managed by the client.
	Identifier *string `json:"identifier,omitzero"`

	// Whether the language has inter file dependencies meaning that
	// editing code in one file can result in a different diagnostic
	// set in another file. Inter file dependencies are common for
	// most programming languages and typically uncommon for linters.
	InterFileDependencies bool `json:"interFileDependencies"`

	// The server provides support for workspace diagnostics as well.
	WorkspaceDiagnostics bool `json:"workspaceDiagnostics"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *DiagnosticRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector      requiredProp `json:"documentSelector"`
		InterFileDependencies requiredProp `json:"interFileDependencies"`
		WorkspaceDiagnostics  requiredProp `json:"workspaceDiagnostics"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}
	if !keys.InterFileDependencies {
		return fmt.Errorf("required key 'interFileDependencies' is missing")
	}
	if !keys.WorkspaceDiagnostics {
		return fmt.Errorf("required key 'workspaceDiagnostics' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector      DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress      *bool                  `json:"workDoneProgress,omitzero"`
		Identifier            *string                `json:"identifier,omitzero"`
		InterFileDependencies bool                   `json:"interFileDependencies"`
		WorkspaceDiagnostics  bool                   `json:"workspaceDiagnostics"`
		Id                    *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters of the workspace diagnostic request.
//
// Since: 3.17.0
type WorkspaceDiagnosticParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The additional identifier provided during registration.
	Identifier *string `json:"identifier,omitzero"`

	// The currently known diagnostic reports with their
	// previous result ids.
	PreviousResultIds []PreviousResultId `json:"previousResultIds"`
}

func (s *WorkspaceDiagnosticParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		PreviousResultIds requiredProp `json:"previousResultIds"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.PreviousResultIds {
		return fmt.Errorf("required key 'previousResultIds' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString   `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString   `json:"partialResultToken,omitzero"`
		Identifier         *string            `json:"identifier,omitzero"`
		PreviousResultIds  []PreviousResultId `json:"previousResultIds"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A workspace diagnostic report.
//
// Since: 3.17.0
type WorkspaceDiagnosticReport struct {
	Items []WorkspaceFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport `json:"items"`
}

func (s *WorkspaceDiagnosticReport) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Items requiredProp `json:"items"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Items {
		return fmt.Errorf("required key 'items' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Items []WorkspaceFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport `json:"items"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A partial result for a workspace diagnostic report.
//
// Since: 3.17.0
type WorkspaceDiagnosticReportPartialResult struct {
	Items []WorkspaceFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport `json:"items"`
}

func (s *WorkspaceDiagnosticReportPartialResult) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Items requiredProp `json:"items"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Items {
		return fmt.Errorf("required key 'items' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Items []WorkspaceFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport `json:"items"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The params sent in an open notebook document notification.
//
// Since: 3.17.0
type DidOpenNotebookDocumentParams struct {
	// The notebook document that got opened.
	NotebookDocument *NotebookDocument `json:"notebookDocument"`

	// The text documents that represent the content
	// of a notebook cell.
	CellTextDocuments []*TextDocumentItem `json:"cellTextDocuments"`
}

func (s *DidOpenNotebookDocumentParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		NotebookDocument  requiredProp `json:"notebookDocument"`
		CellTextDocuments requiredProp `json:"cellTextDocuments"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.NotebookDocument {
		return fmt.Errorf("required key 'notebookDocument' is missing")
	}
	if !keys.CellTextDocuments {
		return fmt.Errorf("required key 'cellTextDocuments' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		NotebookDocument  *NotebookDocument   `json:"notebookDocument"`
		CellTextDocuments []*TextDocumentItem `json:"cellTextDocuments"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options specific to a notebook.
//
// Since: 3.17.0
type NotebookDocumentSyncRegistrationOptions struct {
	// The notebooks to be synced
	NotebookSelector []NotebookDocumentFilterWithNotebookOrCells `json:"notebookSelector"`

	// Whether save notification should be forwarded to
	// the server. Will only be honored if mode === `notebook`.
	Save *bool `json:"save,omitzero"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *NotebookDocumentSyncRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		NotebookSelector requiredProp `json:"notebookSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.NotebookSelector {
		return fmt.Errorf("required key 'notebookSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		NotebookSelector []NotebookDocumentFilterWithNotebookOrCells `json:"notebookSelector"`
		Save             *bool                                       `json:"save,omitzero"`
		Id               *string                                     `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The params sent in a change notebook document notification.
//
// Since: 3.17.0
type DidChangeNotebookDocumentParams struct {
	// The notebook document that did change. The version number points
	// to the version after all provided changes have been applied. If
	// only the text document content of a cell changes the notebook version
	// doesn't necessarily have to change.
	NotebookDocument VersionedNotebookDocumentIdentifier `json:"notebookDocument"`

	// The actual changes to the notebook document.
	//
	// The changes describe single state changes to the notebook document.
	// So if there are two changes c1 (at array index 0) and c2 (at array
	// index 1) for a notebook in state S then c1 moves the notebook from
	// S to S' and c2 from S' to S''. So c1 is computed on the state S and
	// c2 is computed on the state S'.
	//
	// To mirror the content of a notebook using change events use the following approach:
	// - start with the same initial content
	// - apply the 'notebookDocument/didChange' notifications in the order you receive them.
	// - apply the `NotebookChangeEvent`s in a single notification in the order
	//   you receive them.
	Change *NotebookDocumentChangeEvent `json:"change"`
}

func (s *DidChangeNotebookDocumentParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		NotebookDocument requiredProp `json:"notebookDocument"`
		Change           requiredProp `json:"change"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.NotebookDocument {
		return fmt.Errorf("required key 'notebookDocument' is missing")
	}
	if !keys.Change {
		return fmt.Errorf("required key 'change' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		NotebookDocument VersionedNotebookDocumentIdentifier `json:"notebookDocument"`
		Change           *NotebookDocumentChangeEvent        `json:"change"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The params sent in a save notebook document notification.
//
// Since: 3.17.0
type DidSaveNotebookDocumentParams struct {
	// The notebook document that got saved.
	NotebookDocument NotebookDocumentIdentifier `json:"notebookDocument"`
}

func (s *DidSaveNotebookDocumentParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		NotebookDocument requiredProp `json:"notebookDocument"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.NotebookDocument {
		return fmt.Errorf("required key 'notebookDocument' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		NotebookDocument NotebookDocumentIdentifier `json:"notebookDocument"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The params sent in a close notebook document notification.
//
// Since: 3.17.0
type DidCloseNotebookDocumentParams struct {
	// The notebook document that got closed.
	NotebookDocument NotebookDocumentIdentifier `json:"notebookDocument"`

	// The text documents that represent the content
	// of a notebook cell that got closed.
	CellTextDocuments []TextDocumentIdentifier `json:"cellTextDocuments"`
}

func (s *DidCloseNotebookDocumentParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		NotebookDocument  requiredProp `json:"notebookDocument"`
		CellTextDocuments requiredProp `json:"cellTextDocuments"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.NotebookDocument {
		return fmt.Errorf("required key 'notebookDocument' is missing")
	}
	if !keys.CellTextDocuments {
		return fmt.Errorf("required key 'cellTextDocuments' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		NotebookDocument  NotebookDocumentIdentifier `json:"notebookDocument"`
		CellTextDocuments []TextDocumentIdentifier   `json:"cellTextDocuments"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A parameter literal used in inline completion requests.
//
// Since: 3.18.0
//
// Proposed.
type InlineCompletionParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// Additional information about the context in which inline completions were
	// requested.
	Context *InlineCompletionContext `json:"context"`
}

func (s *InlineCompletionParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
		Context      requiredProp `json:"context"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}
	if !keys.Context {
		return fmt.Errorf("required key 'context' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument  TextDocumentIdentifier   `json:"textDocument"`
		Position      Position                 `json:"position"`
		WorkDoneToken *IntegerOrString         `json:"workDoneToken,omitzero"`
		Context       *InlineCompletionContext `json:"context"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents a collection of items to be presented in the editor.
//
// Since: 3.18.0
//
// Proposed.
type InlineCompletionList struct {
	// The inline completion items
	Items []*InlineCompletionItem `json:"items"`
}

func (s *InlineCompletionList) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Items requiredProp `json:"items"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Items {
		return fmt.Errorf("required key 'items' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Items []*InlineCompletionItem `json:"items"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// An inline completion item represents a text snippet that is proposed inline to complete text that is being typed.
//
// Since: 3.18.0
//
// Proposed.
type InlineCompletionItem struct {
	// The text to replace the range with. Must be set.
	InsertText StringOrStringValue `json:"insertText"`

	// A text that is used to decide if this inline completion should be shown. When `falsy` the InlineCompletionItem.insertText is used.
	FilterText *string `json:"filterText,omitzero"`

	// The range to replace. Must begin and end on the same line.
	Range *Range `json:"range,omitzero"`

	// An optional Command that is executed *after* inserting this completion.
	Command *Command `json:"command,omitzero"`
}

func (s *InlineCompletionItem) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		InsertText requiredProp `json:"insertText"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.InsertText {
		return fmt.Errorf("required key 'insertText' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		InsertText StringOrStringValue `json:"insertText"`
		FilterText *string             `json:"filterText,omitzero"`
		Range      *Range              `json:"range,omitzero"`
		Command    *Command            `json:"command,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Inline completion options used during static or dynamic registration.
//
// Since: 3.18.0
//
// Proposed.
type InlineCompletionRegistrationOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *InlineCompletionRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		Id               *string                `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters for the `workspace/textDocumentContent` request.
//
// Since: 3.18.0
//
// Proposed.
type TextDocumentContentParams struct {
	// The uri of the text document.
	Uri DocumentUri `json:"uri"`
}

func (s *TextDocumentContentParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri requiredProp `json:"uri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri DocumentUri `json:"uri"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Result of the `workspace/textDocumentContent` request.
//
// Since: 3.18.0
//
// Proposed.
type TextDocumentContentResult struct {
	// The text content of the text document. Please note, that the content of
	// any subsequent open notifications for the text document might differ
	// from the returned content due to whitespace and line ending
	// normalizations done on the client
	Text string `json:"text"`
}

func (s *TextDocumentContentResult) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Text requiredProp `json:"text"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Text {
		return fmt.Errorf("required key 'text' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Text string `json:"text"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Text document content provider registration options.
//
// Since: 3.18.0
//
// Proposed.
type TextDocumentContentRegistrationOptions struct {
	// The schemes for which the server provides content.
	Schemes []string `json:"schemes"`

	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

func (s *TextDocumentContentRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Schemes requiredProp `json:"schemes"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Schemes {
		return fmt.Errorf("required key 'schemes' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Schemes []string `json:"schemes"`
		Id      *string  `json:"id,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters for the `workspace/textDocumentContent/refresh` request.
//
// Since: 3.18.0
//
// Proposed.
type TextDocumentContentRefreshParams struct {
	// The uri of the text document to refresh.
	Uri DocumentUri `json:"uri"`
}

func (s *TextDocumentContentRefreshParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri requiredProp `json:"uri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri DocumentUri `json:"uri"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type RegistrationParams struct {
	Registrations []*Registration `json:"registrations"`
}

func (s *RegistrationParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Registrations requiredProp `json:"registrations"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Registrations {
		return fmt.Errorf("required key 'registrations' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Registrations []*Registration `json:"registrations"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type UnregistrationParams struct {
	Unregisterations []*Unregistration `json:"unregisterations"`
}

func (s *UnregistrationParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Unregisterations requiredProp `json:"unregisterations"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Unregisterations {
		return fmt.Errorf("required key 'unregisterations' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Unregisterations []*Unregistration `json:"unregisterations"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type InitializeParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// The process Id of the parent process that started
	// the server.
	//
	// Is `null` if the process has not been started by another process.
	// If the parent process is not alive then the server should exit.
	ProcessId IntegerOrNull `json:"processId"`

	// Information about the client
	//
	// Since: 3.15.0
	ClientInfo *ClientInfo `json:"clientInfo,omitzero"`

	// The locale the client is currently showing the user interface
	// in. This must not necessarily be the locale of the operating
	// system.
	//
	// Uses IETF language tags as the value's syntax
	// (See https://en.wikipedia.org/wiki/IETF_language_tag)
	//
	// Since: 3.16.0
	Locale *string `json:"locale,omitzero"`

	// The rootPath of the workspace. Is null
	// if no folder is open.
	//
	// Deprecated: in favour of rootUri.
	RootPath *StringOrNull `json:"rootPath,omitzero"`

	// The rootUri of the workspace. Is null if no
	// folder is open. If both `rootPath` and `rootUri` are set
	// `rootUri` wins.
	//
	// Deprecated: in favour of workspaceFolders.
	RootUri DocumentUriOrNull `json:"rootUri"`

	// The capabilities provided by the client (editor or tool)
	Capabilities *ClientCapabilities `json:"capabilities"`

	// User provided initialization options.
	InitializationOptions *any `json:"initializationOptions,omitzero"`

	// The initial trace setting. If omitted trace is disabled ('off').
	Trace *TraceValue `json:"trace,omitzero"`

	// The workspace folders configured in the client when the server starts.
	//
	// This property is only available if the client supports workspace folders.
	// It can be `null` if the client supports workspace folders but none are
	// configured.
	//
	// Since: 3.6.0
	WorkspaceFolders *WorkspaceFoldersOrNull `json:"workspaceFolders,omitzero"`
}

func (s *InitializeParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		ProcessId    requiredProp `json:"processId"`
		RootUri      requiredProp `json:"rootUri"`
		Capabilities requiredProp `json:"capabilities"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.ProcessId {
		return fmt.Errorf("required key 'processId' is missing")
	}
	if !keys.RootUri {
		return fmt.Errorf("required key 'rootUri' is missing")
	}
	if !keys.Capabilities {
		return fmt.Errorf("required key 'capabilities' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken         *IntegerOrString        `json:"workDoneToken,omitzero"`
		ProcessId             IntegerOrNull           `json:"processId"`
		ClientInfo            *ClientInfo             `json:"clientInfo,omitzero"`
		Locale                *string                 `json:"locale,omitzero"`
		RootPath              *StringOrNull           `json:"rootPath,omitzero"`
		RootUri               DocumentUriOrNull       `json:"rootUri"`
		Capabilities          *ClientCapabilities     `json:"capabilities"`
		InitializationOptions *any                    `json:"initializationOptions,omitzero"`
		Trace                 *TraceValue             `json:"trace,omitzero"`
		WorkspaceFolders      *WorkspaceFoldersOrNull `json:"workspaceFolders,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The result returned from an initialize request.
type InitializeResult struct {
	// The capabilities the language server provides.
	Capabilities *ServerCapabilities `json:"capabilities"`

	// Information about the server.
	//
	// Since: 3.15.0
	ServerInfo *ServerInfo `json:"serverInfo,omitzero"`
}

func (s *InitializeResult) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Capabilities requiredProp `json:"capabilities"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Capabilities {
		return fmt.Errorf("required key 'capabilities' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Capabilities *ServerCapabilities `json:"capabilities"`
		ServerInfo   *ServerInfo         `json:"serverInfo,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The data type of the ResponseError if the
// initialize request fails.
type InitializeError struct {
	// Indicates whether the client execute the following retry logic:
	// (1) show the message provided by the ResponseError to the user
	// (2) user selects retry or cancel
	// (3) if user selected retry the initialize method is sent again.
	Retry bool `json:"retry"`
}

func (s *InitializeError) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Retry requiredProp `json:"retry"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Retry {
		return fmt.Errorf("required key 'retry' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Retry bool `json:"retry"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type InitializedParams struct{}

// The parameters of a change configuration notification.
type DidChangeConfigurationParams struct {
	// The actual changed settings
	Settings any `json:"settings"`
}

func (s *DidChangeConfigurationParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Settings requiredProp `json:"settings"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Settings {
		return fmt.Errorf("required key 'settings' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Settings any `json:"settings"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type DidChangeConfigurationRegistrationOptions struct {
	Section *StringOrStrings `json:"section,omitzero"`
}

// The parameters of a notification message.
type ShowMessageParams struct {
	// The message type. See MessageType
	Type MessageType `json:"type"`

	// The actual message.
	Message string `json:"message"`
}

func (s *ShowMessageParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Type    requiredProp `json:"type"`
		Message requiredProp `json:"message"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Type {
		return fmt.Errorf("required key 'type' is missing")
	}
	if !keys.Message {
		return fmt.Errorf("required key 'message' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Type    MessageType `json:"type"`
		Message string      `json:"message"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type ShowMessageRequestParams struct {
	// The message type. See MessageType
	Type MessageType `json:"type"`

	// The actual message.
	Message string `json:"message"`

	// The message action items to present.
	Actions *[]*MessageActionItem `json:"actions,omitzero"`
}

func (s *ShowMessageRequestParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Type    requiredProp `json:"type"`
		Message requiredProp `json:"message"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Type {
		return fmt.Errorf("required key 'type' is missing")
	}
	if !keys.Message {
		return fmt.Errorf("required key 'message' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Type    MessageType           `json:"type"`
		Message string                `json:"message"`
		Actions *[]*MessageActionItem `json:"actions,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type MessageActionItem struct {
	// A short title like 'Retry', 'Open Log' etc.
	Title string `json:"title"`
}

func (s *MessageActionItem) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Title requiredProp `json:"title"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Title {
		return fmt.Errorf("required key 'title' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Title string `json:"title"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The log message parameters.
type LogMessageParams struct {
	// The message type. See MessageType
	Type MessageType `json:"type"`

	// The actual message.
	Message string `json:"message"`
}

func (s *LogMessageParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Type    requiredProp `json:"type"`
		Message requiredProp `json:"message"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Type {
		return fmt.Errorf("required key 'type' is missing")
	}
	if !keys.Message {
		return fmt.Errorf("required key 'message' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Type    MessageType `json:"type"`
		Message string      `json:"message"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters sent in an open text document notification
type DidOpenTextDocumentParams struct {
	// The document that was opened.
	TextDocument *TextDocumentItem `json:"textDocument"`
}

func (s *DidOpenTextDocumentParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument *TextDocumentItem `json:"textDocument"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The change text document notification's parameters.
type DidChangeTextDocumentParams struct {
	// The document that did change. The version number points
	// to the version after all provided content changes have
	// been applied.
	TextDocument VersionedTextDocumentIdentifier `json:"textDocument"`

	// The actual content changes. The content changes describe single state changes
	// to the document. So if there are two content changes c1 (at array index 0) and
	// c2 (at array index 1) for a document in state S then c1 moves the document from
	// S to S' and c2 from S' to S''. So c1 is computed on the state S and c2 is computed
	// on the state S'.
	//
	// To mirror the content of a document using change events use the following approach:
	// - start with the same initial content
	// - apply the 'textDocument/didChange' notifications in the order you receive them.
	// - apply the `TextDocumentContentChangeEvent`s in a single notification in the order
	//   you receive them.
	ContentChanges []TextDocumentContentChangePartialOrWholeDocument `json:"contentChanges"`
}

func (s *DidChangeTextDocumentParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument   requiredProp `json:"textDocument"`
		ContentChanges requiredProp `json:"contentChanges"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.ContentChanges {
		return fmt.Errorf("required key 'contentChanges' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument   VersionedTextDocumentIdentifier                   `json:"textDocument"`
		ContentChanges []TextDocumentContentChangePartialOrWholeDocument `json:"contentChanges"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Describe options to be used when registered for text document change events.
type TextDocumentChangeRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	// How documents are synced to the server.
	SyncKind TextDocumentSyncKind `json:"syncKind"`
}

func (s *TextDocumentChangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
		SyncKind         requiredProp `json:"syncKind"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}
	if !keys.SyncKind {
		return fmt.Errorf("required key 'syncKind' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		SyncKind         TextDocumentSyncKind   `json:"syncKind"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters sent in a close text document notification
type DidCloseTextDocumentParams struct {
	// The document that was closed.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (s *DidCloseTextDocumentParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument TextDocumentIdentifier `json:"textDocument"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters sent in a save text document notification
type DidSaveTextDocumentParams struct {
	// The document that was saved.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// Optional the content when saved. Depends on the includeText value
	// when the save notification was requested.
	Text *string `json:"text,omitzero"`
}

func (s *DidSaveTextDocumentParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument TextDocumentIdentifier `json:"textDocument"`
		Text         *string                `json:"text,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Save registration options.
type TextDocumentSaveRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	// The client is supposed to include the content on save.
	IncludeText *bool `json:"includeText,omitzero"`
}

func (s *TextDocumentSaveRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		IncludeText      *bool                  `json:"includeText,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters sent in a will save text document notification.
type WillSaveTextDocumentParams struct {
	// The document that will be saved.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The 'TextDocumentSaveReason'.
	Reason TextDocumentSaveReason `json:"reason"`
}

func (s *WillSaveTextDocumentParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Reason       requiredProp `json:"reason"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Reason {
		return fmt.Errorf("required key 'reason' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument TextDocumentIdentifier `json:"textDocument"`
		Reason       TextDocumentSaveReason `json:"reason"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A text edit applicable to a text document.
type TextEdit struct {
	// The range of the text document to be manipulated. To insert
	// text into a document create a range where start === end.
	Range Range `json:"range"`

	// The string to be inserted. For delete operations use an
	// empty string.
	NewText string `json:"newText"`
}

func (s *TextEdit) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range   requiredProp `json:"range"`
		NewText requiredProp `json:"newText"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.NewText {
		return fmt.Errorf("required key 'newText' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range   Range  `json:"range"`
		NewText string `json:"newText"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The watched files change notification's parameters.
type DidChangeWatchedFilesParams struct {
	// The actual file events.
	Changes []*FileEvent `json:"changes"`
}

func (s *DidChangeWatchedFilesParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Changes requiredProp `json:"changes"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Changes {
		return fmt.Errorf("required key 'changes' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Changes []*FileEvent `json:"changes"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Describe options to be used when registered for text document change events.
type DidChangeWatchedFilesRegistrationOptions struct {
	// The watchers to register.
	Watchers []*FileSystemWatcher `json:"watchers"`
}

func (s *DidChangeWatchedFilesRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Watchers requiredProp `json:"watchers"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Watchers {
		return fmt.Errorf("required key 'watchers' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Watchers []*FileSystemWatcher `json:"watchers"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The publish diagnostic notification's parameters.
type PublishDiagnosticsParams struct {
	// The URI for which diagnostic information is reported.
	Uri DocumentUri `json:"uri"`

	// Optional the version number of the document the diagnostics are published for.
	//
	// Since: 3.15.0
	Version *int32 `json:"version,omitzero"`

	// An array of diagnostic information items.
	Diagnostics []*Diagnostic `json:"diagnostics"`
}

func (s *PublishDiagnosticsParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri         requiredProp `json:"uri"`
		Diagnostics requiredProp `json:"diagnostics"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.Diagnostics {
		return fmt.Errorf("required key 'diagnostics' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri         DocumentUri   `json:"uri"`
		Version     *int32        `json:"version,omitzero"`
		Diagnostics []*Diagnostic `json:"diagnostics"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Completion parameters
type CompletionParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The completion context. This is only available it the client specifies
	// to send this using the client capability `textDocument.completion.contextSupport === true`
	Context *CompletionContext `json:"context,omitzero"`
}

func (s *CompletionParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Position           Position               `json:"position"`
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		Context            *CompletionContext     `json:"context,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A completion item represents a text snippet that is
// proposed to complete text that is being typed.
type CompletionItem struct {
	// The label of this completion item.
	//
	// The label property is also by default the text that
	// is inserted when selecting this completion.
	//
	// If label details are provided the label itself should
	// be an unqualified name of the completion item.
	Label string `json:"label"`

	// Additional details for the label
	//
	// Since: 3.17.0
	LabelDetails *CompletionItemLabelDetails `json:"labelDetails,omitzero"`

	// The kind of this completion item. Based of the kind
	// an icon is chosen by the editor.
	Kind *CompletionItemKind `json:"kind,omitzero"`

	// Tags for this completion item.
	//
	// Since: 3.15.0
	Tags *[]CompletionItemTag `json:"tags,omitzero"`

	// A human-readable string with additional information
	// about this item, like type or symbol information.
	Detail *string `json:"detail,omitzero"`

	// A human-readable string that represents a doc-comment.
	Documentation *StringOrMarkupContent `json:"documentation,omitzero"`

	// Indicates if this item is deprecated.
	//
	// Deprecated: Use `tags` instead.
	Deprecated *bool `json:"deprecated,omitzero"`

	// Select this item when showing.
	//
	// *Note* that only one completion item can be selected and that the
	// tool / client decides which item that is. The rule is that the *first*
	// item of those that match best is selected.
	Preselect *bool `json:"preselect,omitzero"`

	// A string that should be used when comparing this item
	// with other items. When `falsy` the label
	// is used.
	SortText *string `json:"sortText,omitzero"`

	// A string that should be used when filtering a set of
	// completion items. When `falsy` the label
	// is used.
	FilterText *string `json:"filterText,omitzero"`

	// A string that should be inserted into a document when selecting
	// this completion. When `falsy` the label
	// is used.
	//
	// The `insertText` is subject to interpretation by the client side.
	// Some tools might not take the string literally. For example
	// VS Code when code complete is requested in this example
	// `con<cursor position>` and a completion item with an `insertText` of
	// `console` is provided it will only insert `sole`. Therefore it is
	// recommended to use `textEdit` instead since it avoids additional client
	// side interpretation.
	InsertText *string `json:"insertText,omitzero"`

	// The format of the insert text. The format applies to both the
	// `insertText` property and the `newText` property of a provided
	// `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.
	//
	// Please note that the insertTextFormat doesn't apply to
	// `additionalTextEdits`.
	InsertTextFormat *InsertTextFormat `json:"insertTextFormat,omitzero"`

	// How whitespace and indentation is handled during completion
	// item insertion. If not provided the clients default value depends on
	// the `textDocument.completion.insertTextMode` client capability.
	//
	// Since: 3.16.0
	InsertTextMode *InsertTextMode `json:"insertTextMode,omitzero"`

	// An edit which is applied to a document when selecting
	// this completion. When an edit is provided the value of
	// insertText is ignored.
	//
	// Most editors support two different operations when accepting a completion
	// item. One is to insert a completion text and the other is to replace an
	// existing text with a completion text. Since this can usually not be
	// predetermined by a server it can report both ranges. Clients need to
	// signal support for `InsertReplaceEdits` via the
	// `textDocument.completion.insertReplaceSupport` client capability
	// property.
	//
	// *Note 1:* The text edit's range as well as both ranges from an insert
	// replace edit must be a [single line] and they must contain the position
	// at which completion has been requested.
	// *Note 2:* If an `InsertReplaceEdit` is returned the edit's insert range
	// must be a prefix of the edit's replace range, that means it must be
	// contained and starting at the same position.
	//
	// Since: 3.16.0 additional type `InsertReplaceEdit`
	TextEdit *TextEditOrInsertReplaceEdit `json:"textEdit,omitzero"`

	// The edit text used if the completion item is part of a CompletionList and
	// CompletionList defines an item default for the text edit range.
	//
	// Clients will only honor this property if they opt into completion list
	// item defaults using the capability `completionList.itemDefaults`.
	//
	// If not provided and a list's default range is provided the label
	// property is used as a text.
	//
	// Since: 3.17.0
	TextEditText *string `json:"textEditText,omitzero"`

	// An optional array of additional edits that are applied when
	// selecting this completion. Edits must not overlap (including the same insert position)
	// with the main edit nor with themselves.
	//
	// Additional text edits should be used to change text unrelated to the current cursor position
	// (for example adding an import statement at the top of the file if the completion item will
	// insert an unqualified type).
	AdditionalTextEdits *[]*TextEdit `json:"additionalTextEdits,omitzero"`

	// An optional set of characters that when pressed while this completion is active will accept it first and
	// then type that character. *Note* that all commit characters should have `length=1` and that superfluous
	// characters will be ignored.
	CommitCharacters *[]string `json:"commitCharacters,omitzero"`

	// An optional command that is executed *after* inserting this completion. *Note* that
	// additional modifications to the current document should be described with the
	// additionalTextEdits-property.
	Command *Command `json:"command,omitzero"`

	// A data entry field that is preserved on a completion item between a
	// CompletionRequest and a CompletionResolveRequest.
	Data *any `json:"data,omitzero"`
}

func (s *CompletionItem) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Label requiredProp `json:"label"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Label {
		return fmt.Errorf("required key 'label' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Label               string                       `json:"label"`
		LabelDetails        *CompletionItemLabelDetails  `json:"labelDetails,omitzero"`
		Kind                *CompletionItemKind          `json:"kind,omitzero"`
		Tags                *[]CompletionItemTag         `json:"tags,omitzero"`
		Detail              *string                      `json:"detail,omitzero"`
		Documentation       *StringOrMarkupContent       `json:"documentation,omitzero"`
		Deprecated          *bool                        `json:"deprecated,omitzero"`
		Preselect           *bool                        `json:"preselect,omitzero"`
		SortText            *string                      `json:"sortText,omitzero"`
		FilterText          *string                      `json:"filterText,omitzero"`
		InsertText          *string                      `json:"insertText,omitzero"`
		InsertTextFormat    *InsertTextFormat            `json:"insertTextFormat,omitzero"`
		InsertTextMode      *InsertTextMode              `json:"insertTextMode,omitzero"`
		TextEdit            *TextEditOrInsertReplaceEdit `json:"textEdit,omitzero"`
		TextEditText        *string                      `json:"textEditText,omitzero"`
		AdditionalTextEdits *[]*TextEdit                 `json:"additionalTextEdits,omitzero"`
		CommitCharacters    *[]string                    `json:"commitCharacters,omitzero"`
		Command             *Command                     `json:"command,omitzero"`
		Data                *any                         `json:"data,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents a collection of items to be presented
// in the editor.
type CompletionList struct {
	// This list it not complete. Further typing results in recomputing this list.
	//
	// Recomputed lists have all their items replaced (not appended) in the
	// incomplete completion sessions.
	IsIncomplete bool `json:"isIncomplete"`

	// In many cases the items of an actual completion result share the same
	// value for properties like `commitCharacters` or the range of a text
	// edit. A completion list can therefore define item defaults which will
	// be used if a completion item itself doesn't specify the value.
	//
	// If a completion list specifies a default value and a completion item
	// also specifies a corresponding value, the rules for combining these are
	// defined by `applyKinds` (if the client supports it), defaulting to
	// ApplyKind.Replace.
	//
	// Servers are only allowed to return default values if the client
	// signals support for this via the `completionList.itemDefaults`
	// capability.
	//
	// Since: 3.17.0
	ItemDefaults *CompletionItemDefaults `json:"itemDefaults,omitzero"`

	// Specifies how fields from a completion item should be combined with those
	// from `completionList.itemDefaults`.
	//
	// If unspecified, all fields will be treated as ApplyKind.Replace.
	//
	// If a field's value is ApplyKind.Replace, the value from a completion item
	// (if provided and not `null`) will always be used instead of the value
	// from `completionItem.itemDefaults`.
	//
	// If a field's value is ApplyKind.Merge, the values will be merged using
	// the rules defined against each field below.
	//
	// Servers are only allowed to return `applyKind` if the client
	// signals support for this via the `completionList.applyKindSupport`
	// capability.
	//
	// Since: 3.18.0
	ApplyKind *CompletionItemApplyKinds `json:"applyKind,omitzero"`

	// The completion items.
	Items []*CompletionItem `json:"items"`
}

func (s *CompletionList) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		IsIncomplete requiredProp `json:"isIncomplete"`
		Items        requiredProp `json:"items"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.IsIncomplete {
		return fmt.Errorf("required key 'isIncomplete' is missing")
	}
	if !keys.Items {
		return fmt.Errorf("required key 'items' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		IsIncomplete bool                      `json:"isIncomplete"`
		ItemDefaults *CompletionItemDefaults   `json:"itemDefaults,omitzero"`
		ApplyKind    *CompletionItemApplyKinds `json:"applyKind,omitzero"`
		Items        []*CompletionItem         `json:"items"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a CompletionRequest.
type CompletionRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// Most tools trigger completion request automatically without explicitly requesting
	// it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
	// starts to type an identifier. For example if the user types `c` in a JavaScript file
	// code complete will automatically pop up present `console` besides others as a
	// completion item. Characters that make up identifiers don't need to be listed here.
	//
	// If code complete should automatically be trigger on characters not being valid inside
	// an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
	TriggerCharacters *[]string `json:"triggerCharacters,omitzero"`

	// The list of all possible characters that commit a completion. This field can be used
	// if clients don't support individual commit characters per completion item. See
	// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
	//
	// If a server provides both `allCommitCharacters` and commit characters on an individual
	// completion item the ones on the completion item win.
	//
	// Since: 3.2.0
	AllCommitCharacters *[]string `json:"allCommitCharacters,omitzero"`

	// The server provides support to resolve additional
	// information for a completion item.
	ResolveProvider *bool `json:"resolveProvider,omitzero"`

	// The server supports the following `CompletionItem` specific
	// capabilities.
	//
	// Since: 3.17.0
	CompletionItem *ServerCompletionItemOptions `json:"completionItem,omitzero"`
}

func (s *CompletionRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector    DocumentSelectorOrNull       `json:"documentSelector"`
		WorkDoneProgress    *bool                        `json:"workDoneProgress,omitzero"`
		TriggerCharacters   *[]string                    `json:"triggerCharacters,omitzero"`
		AllCommitCharacters *[]string                    `json:"allCommitCharacters,omitzero"`
		ResolveProvider     *bool                        `json:"resolveProvider,omitzero"`
		CompletionItem      *ServerCompletionItemOptions `json:"completionItem,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters for a HoverRequest.
type HoverParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`
}

func (s *HoverParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument  TextDocumentIdentifier `json:"textDocument"`
		Position      Position               `json:"position"`
		WorkDoneToken *IntegerOrString       `json:"workDoneToken,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The result of a hover request.
type Hover struct {
	// The hover's content
	Contents MarkupContentOrStringOrMarkedStringWithLanguageOrMarkedStrings `json:"contents"`

	// An optional range inside the text document that is used to
	// visualize the hover, e.g. by changing the background color.
	Range *Range `json:"range,omitzero"`
}

func (s *Hover) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Contents requiredProp `json:"contents"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Contents {
		return fmt.Errorf("required key 'contents' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Contents MarkupContentOrStringOrMarkedStringWithLanguageOrMarkedStrings `json:"contents"`
		Range    *Range                                                         `json:"range,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a HoverRequest.
type HoverRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

func (s *HoverRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters for a SignatureHelpRequest.
type SignatureHelpParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// The signature help context. This is only available if the client specifies
	// to send this using the client capability `textDocument.signatureHelp.contextSupport === true`
	//
	// Since: 3.15.0
	Context *SignatureHelpContext `json:"context,omitzero"`
}

func (s *SignatureHelpParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument  TextDocumentIdentifier `json:"textDocument"`
		Position      Position               `json:"position"`
		WorkDoneToken *IntegerOrString       `json:"workDoneToken,omitzero"`
		Context       *SignatureHelpContext  `json:"context,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Signature help represents the signature of something
// callable. There can be multiple signature but only one
// active and only one active parameter.
type SignatureHelp struct {
	// One or more signatures.
	Signatures []*SignatureInformation `json:"signatures"`

	// The active signature. If omitted or the value lies outside the
	// range of `signatures` the value defaults to zero or is ignored if
	// the `SignatureHelp` has no signatures.
	//
	// Whenever possible implementors should make an active decision about
	// the active signature and shouldn't rely on a default value.
	//
	// In future version of the protocol this property might become
	// mandatory to better express this.
	ActiveSignature *uint32 `json:"activeSignature,omitzero"`

	// The active parameter of the active signature.
	//
	// If `null`, no parameter of the signature is active (for example a named
	// argument that does not match any declared parameters). This is only valid
	// if the client specifies the client capability
	// `textDocument.signatureHelp.noActiveParameterSupport === true`
	//
	// If omitted or the value lies outside the range of
	// `signatures[activeSignature].parameters` defaults to 0 if the active
	// signature has parameters.
	//
	// If the active signature has no parameters it is ignored.
	//
	// In future version of the protocol this property might become
	// mandatory (but still nullable) to better express the active parameter if
	// the active signature does have any.
	ActiveParameter *UintegerOrNull `json:"activeParameter,omitzero"`
}

func (s *SignatureHelp) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Signatures requiredProp `json:"signatures"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Signatures {
		return fmt.Errorf("required key 'signatures' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Signatures      []*SignatureInformation `json:"signatures"`
		ActiveSignature *uint32                 `json:"activeSignature,omitzero"`
		ActiveParameter *UintegerOrNull         `json:"activeParameter,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a SignatureHelpRequest.
type SignatureHelpRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// List of characters that trigger signature help automatically.
	TriggerCharacters *[]string `json:"triggerCharacters,omitzero"`

	// List of characters that re-trigger signature help.
	//
	// These trigger characters are only active when signature help is already showing. All trigger characters
	// are also counted as re-trigger characters.
	//
	// Since: 3.15.0
	RetriggerCharacters *[]string `json:"retriggerCharacters,omitzero"`
}

func (s *SignatureHelpRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector    DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress    *bool                  `json:"workDoneProgress,omitzero"`
		TriggerCharacters   *[]string              `json:"triggerCharacters,omitzero"`
		RetriggerCharacters *[]string              `json:"retriggerCharacters,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters for a DefinitionRequest.
type DefinitionParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`
}

func (s *DefinitionParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Position           Position               `json:"position"`
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a DefinitionRequest.
type DefinitionRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

func (s *DefinitionRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters for a ReferencesRequest.
type ReferenceParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	Context *ReferenceContext `json:"context"`
}

func (s *ReferenceParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
		Context      requiredProp `json:"context"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}
	if !keys.Context {
		return fmt.Errorf("required key 'context' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Position           Position               `json:"position"`
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		Context            *ReferenceContext      `json:"context"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a ReferencesRequest.
type ReferenceRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

func (s *ReferenceRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters for a DocumentHighlightRequest.
type DocumentHighlightParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`
}

func (s *DocumentHighlightParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Position           Position               `json:"position"`
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A document highlight is a range inside a text document which deserves
// special attention. Usually a document highlight is visualized by changing
// the background color of its range.
type DocumentHighlight struct {
	// The range this highlight applies to.
	Range Range `json:"range"`

	// The highlight kind, default is text.
	Kind *DocumentHighlightKind `json:"kind,omitzero"`
}

func (s *DocumentHighlight) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range requiredProp `json:"range"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range Range                  `json:"range"`
		Kind  *DocumentHighlightKind `json:"kind,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a DocumentHighlightRequest.
type DocumentHighlightRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

func (s *DocumentHighlightRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Parameters for a DocumentSymbolRequest.
type DocumentSymbolParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (s *DocumentSymbolParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents information about programming constructs like variables, classes,
// interfaces etc.
type SymbolInformation struct {
	// The name of this symbol.
	Name string `json:"name"`

	// The kind of this symbol.
	Kind SymbolKind `json:"kind"`

	// Tags for this symbol.
	//
	// Since: 3.16.0
	Tags *[]SymbolTag `json:"tags,omitzero"`

	// The name of the symbol containing this symbol. This information is for
	// user interface purposes (e.g. to render a qualifier in the user interface
	// if necessary). It can't be used to re-infer a hierarchy for the document
	// symbols.
	ContainerName *string `json:"containerName,omitzero"`

	// Indicates if this symbol is deprecated.
	//
	// Deprecated: Use tags instead
	Deprecated *bool `json:"deprecated,omitzero"`

	// The location of this symbol. The location's range is used by a tool
	// to reveal the location in the editor. If the symbol is selected in the
	// tool the range's start information is used to position the cursor. So
	// the range usually spans more than the actual symbol's name and does
	// normally include things like visibility modifiers.
	//
	// The range doesn't have to denote a node range in the sense of an abstract
	// syntax tree. It can therefore not be used to re-construct a hierarchy of
	// the symbols.
	Location Location `json:"location"`
}

func (s *SymbolInformation) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Name     requiredProp `json:"name"`
		Kind     requiredProp `json:"kind"`
		Location requiredProp `json:"location"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Name {
		return fmt.Errorf("required key 'name' is missing")
	}
	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Location {
		return fmt.Errorf("required key 'location' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Name          string       `json:"name"`
		Kind          SymbolKind   `json:"kind"`
		Tags          *[]SymbolTag `json:"tags,omitzero"`
		ContainerName *string      `json:"containerName,omitzero"`
		Deprecated    *bool        `json:"deprecated,omitzero"`
		Location      Location     `json:"location"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents programming constructs like variables, classes, interfaces etc.
// that appear in a document. Document symbols can be hierarchical and they
// have two ranges: one that encloses its definition and one that points to
// its most interesting range, e.g. the range of an identifier.
type DocumentSymbol struct {
	// The name of this symbol. Will be displayed in the user interface and therefore must not be
	// an empty string or a string only consisting of white spaces.
	Name string `json:"name"`

	// More detail for this symbol, e.g the signature of a function.
	Detail *string `json:"detail,omitzero"`

	// The kind of this symbol.
	Kind SymbolKind `json:"kind"`

	// Tags for this document symbol.
	//
	// Since: 3.16.0
	Tags *[]SymbolTag `json:"tags,omitzero"`

	// Indicates if this symbol is deprecated.
	//
	// Deprecated: Use tags instead
	Deprecated *bool `json:"deprecated,omitzero"`

	// The range enclosing this symbol not including leading/trailing whitespace but everything else
	// like comments. This information is typically used to determine if the clients cursor is
	// inside the symbol to reveal in the symbol in the UI.
	Range Range `json:"range"`

	// The range that should be selected and revealed when this symbol is being picked, e.g the name of a function.
	// Must be contained by the `range`.
	SelectionRange Range `json:"selectionRange"`

	// Children of this symbol, e.g. properties of a class.
	Children *[]*DocumentSymbol `json:"children,omitzero"`
}

func (s *DocumentSymbol) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Name           requiredProp `json:"name"`
		Kind           requiredProp `json:"kind"`
		Range          requiredProp `json:"range"`
		SelectionRange requiredProp `json:"selectionRange"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Name {
		return fmt.Errorf("required key 'name' is missing")
	}
	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.SelectionRange {
		return fmt.Errorf("required key 'selectionRange' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Name           string             `json:"name"`
		Detail         *string            `json:"detail,omitzero"`
		Kind           SymbolKind         `json:"kind"`
		Tags           *[]SymbolTag       `json:"tags,omitzero"`
		Deprecated     *bool              `json:"deprecated,omitzero"`
		Range          Range              `json:"range"`
		SelectionRange Range              `json:"selectionRange"`
		Children       *[]*DocumentSymbol `json:"children,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a DocumentSymbolRequest.
type DocumentSymbolRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// A human-readable string that is shown when multiple outlines trees
	// are shown for the same document.
	//
	// Since: 3.16.0
	Label *string `json:"label,omitzero"`
}

func (s *DocumentSymbolRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		Label            *string                `json:"label,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters of a CodeActionRequest.
type CodeActionParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The document in which the command was invoked.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The range for which the command was invoked.
	Range Range `json:"range"`

	// Context carrying additional information.
	Context *CodeActionContext `json:"context"`
}

func (s *CodeActionParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Range        requiredProp `json:"range"`
		Context      requiredProp `json:"context"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.Context {
		return fmt.Errorf("required key 'context' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
		Range              Range                  `json:"range"`
		Context            *CodeActionContext     `json:"context"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents a reference to a command. Provides a title which
// will be used to represent a command in the UI and, optionally,
// an array of arguments which will be passed to the command handler
// function when invoked.
type Command struct {
	// Title of the command, like `save`.
	Title string `json:"title"`

	// An optional tooltip.
	//
	// Since: 3.18.0
	//
	// Proposed.
	Tooltip *string `json:"tooltip,omitzero"`

	// The identifier of the actual command handler.
	Command string `json:"command"`

	// Arguments that the command handler should be
	// invoked with.
	Arguments *[]any `json:"arguments,omitzero"`
}

func (s *Command) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Title   requiredProp `json:"title"`
		Command requiredProp `json:"command"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Title {
		return fmt.Errorf("required key 'title' is missing")
	}
	if !keys.Command {
		return fmt.Errorf("required key 'command' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Title     string  `json:"title"`
		Tooltip   *string `json:"tooltip,omitzero"`
		Command   string  `json:"command"`
		Arguments *[]any  `json:"arguments,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A code action represents a change that can be performed in code, e.g. to fix a problem or
// to refactor code.
//
// A CodeAction must set either `edit` and/or a `command`. If both are supplied, the `edit` is applied first, then the `command` is executed.
type CodeAction struct {
	// A short, human-readable, title for this code action.
	Title string `json:"title"`

	// The kind of the code action.
	//
	// Used to filter code actions.
	Kind *CodeActionKind `json:"kind,omitzero"`

	// The diagnostics that this code action resolves.
	Diagnostics *[]*Diagnostic `json:"diagnostics,omitzero"`

	// Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted
	// by keybindings.
	//
	// A quick fix should be marked preferred if it properly addresses the underlying error.
	// A refactoring should be marked preferred if it is the most reasonable choice of actions to take.
	//
	// Since: 3.15.0
	IsPreferred *bool `json:"isPreferred,omitzero"`

	// Marks that the code action cannot currently be applied.
	//
	// Clients should follow the following guidelines regarding disabled code actions:
	//
	//   - Disabled code actions are not shown in automatic [lightbulbs](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
	//     code action menus.
	//
	//   - Disabled actions are shown as faded out in the code action menu when the user requests a more specific type
	//     of code action, such as refactorings.
	//
	//   - If the user has a [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)
	//     that auto applies a code action and only disabled code actions are returned, the client should show the user an
	//     error message with `reason` in the editor.
	//
	// Since: 3.16.0
	Disabled *CodeActionDisabled `json:"disabled,omitzero"`

	// The workspace edit this code action performs.
	Edit *WorkspaceEdit `json:"edit,omitzero"`

	// A command this code action executes. If a code action
	// provides an edit and a command, first the edit is
	// executed and then the command.
	Command *Command `json:"command,omitzero"`

	// A data entry field that is preserved on a code action between
	// a `textDocument/codeAction` and a `codeAction/resolve` request.
	//
	// Since: 3.16.0
	Data *any `json:"data,omitzero"`

	// Tags for this code action.
	//
	// Since: 3.18.0 - proposed
	Tags *[]CodeActionTag `json:"tags,omitzero"`
}

func (s *CodeAction) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Title requiredProp `json:"title"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Title {
		return fmt.Errorf("required key 'title' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Title       string              `json:"title"`
		Kind        *CodeActionKind     `json:"kind,omitzero"`
		Diagnostics *[]*Diagnostic      `json:"diagnostics,omitzero"`
		IsPreferred *bool               `json:"isPreferred,omitzero"`
		Disabled    *CodeActionDisabled `json:"disabled,omitzero"`
		Edit        *WorkspaceEdit      `json:"edit,omitzero"`
		Command     *Command            `json:"command,omitzero"`
		Data        *any                `json:"data,omitzero"`
		Tags        *[]CodeActionTag    `json:"tags,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a CodeActionRequest.
type CodeActionRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// CodeActionKinds that this server may return.
	//
	// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
	// may list out every specific kind they provide.
	CodeActionKinds *[]CodeActionKind `json:"codeActionKinds,omitzero"`

	// Static documentation for a class of code actions.
	//
	// Documentation from the provider should be shown in the code actions menu if either:
	//
	// - Code actions of `kind` are requested by the editor. In this case, the editor will show the documentation that
	//   most closely matches the requested code action kind. For example, if a provider has documentation for
	//   both `Refactor` and `RefactorExtract`, when the user requests code actions for `RefactorExtract`,
	//   the editor will use the documentation for `RefactorExtract` instead of the documentation for `Refactor`.
	//
	// - Any code actions of `kind` are returned by the provider.
	//
	// At most one documentation entry should be shown per provider.
	//
	// Since: 3.18.0
	//
	// Proposed.
	Documentation *[]*CodeActionKindDocumentation `json:"documentation,omitzero"`

	// The server provides support to resolve additional
	// information for a code action.
	//
	// Since: 3.16.0
	ResolveProvider *bool `json:"resolveProvider,omitzero"`
}

func (s *CodeActionRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull          `json:"documentSelector"`
		WorkDoneProgress *bool                           `json:"workDoneProgress,omitzero"`
		CodeActionKinds  *[]CodeActionKind               `json:"codeActionKinds,omitzero"`
		Documentation    *[]*CodeActionKindDocumentation `json:"documentation,omitzero"`
		ResolveProvider  *bool                           `json:"resolveProvider,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters of a WorkspaceSymbolRequest.
type WorkspaceSymbolParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// A query string to filter symbols by. Clients may send an empty
	// string here to request all symbols.
	//
	// The `query`-parameter should be interpreted in a *relaxed way* as editors
	// will apply their own highlighting and scoring on the results. A good rule
	// of thumb is to match case-insensitive and to simply check that the
	// characters of *query* appear in their order in a candidate symbol.
	// Servers shouldn't use prefix, substring, or similar strict matching.
	Query string `json:"query"`
}

func (s *WorkspaceSymbolParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Query requiredProp `json:"query"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Query {
		return fmt.Errorf("required key 'query' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`
		Query              string           `json:"query"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A special workspace symbol that supports locations without a range.
//
// See also SymbolInformation.
//
// Since: 3.17.0
type WorkspaceSymbol struct {
	// The name of this symbol.
	Name string `json:"name"`

	// The kind of this symbol.
	Kind SymbolKind `json:"kind"`

	// Tags for this symbol.
	//
	// Since: 3.16.0
	Tags *[]SymbolTag `json:"tags,omitzero"`

	// The name of the symbol containing this symbol. This information is for
	// user interface purposes (e.g. to render a qualifier in the user interface
	// if necessary). It can't be used to re-infer a hierarchy for the document
	// symbols.
	ContainerName *string `json:"containerName,omitzero"`

	// The location of the symbol. Whether a server is allowed to
	// return a location without a range depends on the client
	// capability `workspace.symbol.resolveSupport`.
	//
	// See SymbolInformation#location for more details.
	Location LocationOrLocationUriOnly `json:"location"`

	// A data entry field that is preserved on a workspace symbol between a
	// workspace symbol request and a workspace symbol resolve request.
	Data *any `json:"data,omitzero"`
}

func (s *WorkspaceSymbol) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Name     requiredProp `json:"name"`
		Kind     requiredProp `json:"kind"`
		Location requiredProp `json:"location"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Name {
		return fmt.Errorf("required key 'name' is missing")
	}
	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Location {
		return fmt.Errorf("required key 'location' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Name          string                    `json:"name"`
		Kind          SymbolKind                `json:"kind"`
		Tags          *[]SymbolTag              `json:"tags,omitzero"`
		ContainerName *string                   `json:"containerName,omitzero"`
		Location      LocationOrLocationUriOnly `json:"location"`
		Data          *any                      `json:"data,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a WorkspaceSymbolRequest.
type WorkspaceSymbolRegistrationOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The server provides support to resolve additional
	// information for a workspace symbol.
	//
	// Since: 3.17.0
	ResolveProvider *bool `json:"resolveProvider,omitzero"`
}

// The parameters of a CodeLensRequest.
type CodeLensParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The document to request code lens for.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (s *CodeLensParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A code lens represents a command that should be shown along with
// source text, like the number of references, a way to run tests, etc.
//
// A code lens is _unresolved_ when no command is associated to it. For performance
// reasons the creation of a code lens and resolving should be done in two stages.
type CodeLens struct {
	// The range in which this code lens is valid. Should only span a single line.
	Range Range `json:"range"`

	// The command this code lens represents.
	Command *Command `json:"command,omitzero"`

	// A data entry field that is preserved on a code lens item between
	// a CodeLensRequest and a CodeLensResolveRequest
	Data *any `json:"data,omitzero"`
}

func (s *CodeLens) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range requiredProp `json:"range"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range   Range    `json:"range"`
		Command *Command `json:"command,omitzero"`
		Data    *any     `json:"data,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a CodeLensRequest.
type CodeLensRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// Code lens has a resolve provider as well.
	ResolveProvider *bool `json:"resolveProvider,omitzero"`
}

func (s *CodeLensRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		ResolveProvider  *bool                  `json:"resolveProvider,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters of a DocumentLinkRequest.
type DocumentLinkParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`

	// The document to provide document links for.
	TextDocument TextDocumentIdentifier `json:"textDocument"`
}

func (s *DocumentLinkParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken      *IntegerOrString       `json:"workDoneToken,omitzero"`
		PartialResultToken *IntegerOrString       `json:"partialResultToken,omitzero"`
		TextDocument       TextDocumentIdentifier `json:"textDocument"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A document link is a range in a text document that links to an internal or external resource, like another
// text document or a web site.
type DocumentLink struct {
	// The range this link applies to.
	Range Range `json:"range"`

	// The uri this link points to. If missing a resolve request is sent later.
	Target *URI `json:"target,omitzero"`

	// The tooltip text when you hover over this link.
	//
	// If a tooltip is provided, is will be displayed in a string that includes instructions on how to
	// trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS,
	// user settings, and localization.
	//
	// Since: 3.15.0
	Tooltip *string `json:"tooltip,omitzero"`

	// A data entry field that is preserved on a document link between a
	// DocumentLinkRequest and a DocumentLinkResolveRequest.
	Data *any `json:"data,omitzero"`
}

func (s *DocumentLink) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range requiredProp `json:"range"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range   Range   `json:"range"`
		Target  *URI    `json:"target,omitzero"`
		Tooltip *string `json:"tooltip,omitzero"`
		Data    *any    `json:"data,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a DocumentLinkRequest.
type DocumentLinkRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// Document links have a resolve provider as well.
	ResolveProvider *bool `json:"resolveProvider,omitzero"`
}

func (s *DocumentLinkRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		ResolveProvider  *bool                  `json:"resolveProvider,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters of a DocumentFormattingRequest.
type DocumentFormattingParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// The document to format.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The format options.
	Options *FormattingOptions `json:"options"`
}

func (s *DocumentFormattingParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Options      requiredProp `json:"options"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Options {
		return fmt.Errorf("required key 'options' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken *IntegerOrString       `json:"workDoneToken,omitzero"`
		TextDocument  TextDocumentIdentifier `json:"textDocument"`
		Options       *FormattingOptions     `json:"options"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a DocumentFormattingRequest.
type DocumentFormattingRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

func (s *DocumentFormattingRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters of a DocumentRangeFormattingRequest.
type DocumentRangeFormattingParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// The document to format.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The range to format
	Range Range `json:"range"`

	// The format options
	Options *FormattingOptions `json:"options"`
}

func (s *DocumentRangeFormattingParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Range        requiredProp `json:"range"`
		Options      requiredProp `json:"options"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.Options {
		return fmt.Errorf("required key 'options' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken *IntegerOrString       `json:"workDoneToken,omitzero"`
		TextDocument  TextDocumentIdentifier `json:"textDocument"`
		Range         Range                  `json:"range"`
		Options       *FormattingOptions     `json:"options"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a DocumentRangeFormattingRequest.
type DocumentRangeFormattingRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// Whether the server supports formatting multiple ranges at once.
	//
	// Since: 3.18.0
	//
	// Proposed.
	RangesSupport *bool `json:"rangesSupport,omitzero"`
}

func (s *DocumentRangeFormattingRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		RangesSupport    *bool                  `json:"rangesSupport,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters of a DocumentRangesFormattingRequest.
//
// Since: 3.18.0
//
// Proposed.
type DocumentRangesFormattingParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// The document to format.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The ranges to format
	Ranges []Range `json:"ranges"`

	// The format options
	Options *FormattingOptions `json:"options"`
}

func (s *DocumentRangesFormattingParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Ranges       requiredProp `json:"ranges"`
		Options      requiredProp `json:"options"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Ranges {
		return fmt.Errorf("required key 'ranges' is missing")
	}
	if !keys.Options {
		return fmt.Errorf("required key 'options' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken *IntegerOrString       `json:"workDoneToken,omitzero"`
		TextDocument  TextDocumentIdentifier `json:"textDocument"`
		Ranges        []Range                `json:"ranges"`
		Options       *FormattingOptions     `json:"options"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters of a DocumentOnTypeFormattingRequest.
type DocumentOnTypeFormattingParams struct {
	// The document to format.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position around which the on type formatting should happen.
	// This is not necessarily the exact position where the character denoted
	// by the property `ch` got typed.
	Position Position `json:"position"`

	// The character that has been typed that triggered the formatting
	// on type request. That is not necessarily the last character that
	// got inserted into the document since the client could auto insert
	// characters as well (e.g. like automatic brace completion).
	Ch string `json:"ch"`

	// The formatting options.
	Options *FormattingOptions `json:"options"`
}

func (s *DocumentOnTypeFormattingParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
		Ch           requiredProp `json:"ch"`
		Options      requiredProp `json:"options"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}
	if !keys.Ch {
		return fmt.Errorf("required key 'ch' is missing")
	}
	if !keys.Options {
		return fmt.Errorf("required key 'options' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument TextDocumentIdentifier `json:"textDocument"`
		Position     Position               `json:"position"`
		Ch           string                 `json:"ch"`
		Options      *FormattingOptions     `json:"options"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a DocumentOnTypeFormattingRequest.
type DocumentOnTypeFormattingRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	// A character on which formatting should be triggered, like `{`.
	FirstTriggerCharacter string `json:"firstTriggerCharacter"`

	// More trigger characters.
	MoreTriggerCharacter *[]string `json:"moreTriggerCharacter,omitzero"`
}

func (s *DocumentOnTypeFormattingRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector      requiredProp `json:"documentSelector"`
		FirstTriggerCharacter requiredProp `json:"firstTriggerCharacter"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}
	if !keys.FirstTriggerCharacter {
		return fmt.Errorf("required key 'firstTriggerCharacter' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector      DocumentSelectorOrNull `json:"documentSelector"`
		FirstTriggerCharacter string                 `json:"firstTriggerCharacter"`
		MoreTriggerCharacter  *[]string              `json:"moreTriggerCharacter,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters of a RenameRequest.
type RenameParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// The document to rename.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position at which this request was sent.
	Position Position `json:"position"`

	// The new name of the symbol. If the given name is not valid the
	// request must return a ResponseError with an
	// appropriate message set.
	NewName string `json:"newName"`
}

func (s *RenameParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
		NewName      requiredProp `json:"newName"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}
	if !keys.NewName {
		return fmt.Errorf("required key 'newName' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken *IntegerOrString       `json:"workDoneToken,omitzero"`
		TextDocument  TextDocumentIdentifier `json:"textDocument"`
		Position      Position               `json:"position"`
		NewName       string                 `json:"newName"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a RenameRequest.
type RenameRegistrationOptions struct {
	// A document selector to identify the scope of the registration. If set to null
	// the document selector provided on the client side will be used.
	DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`

	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// Renames should be checked and tested before being executed.
	//
	// Since: version 3.12.0
	PrepareProvider *bool `json:"prepareProvider,omitzero"`
}

func (s *RenameRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DocumentSelector requiredProp `json:"documentSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DocumentSelector {
		return fmt.Errorf("required key 'documentSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DocumentSelector DocumentSelectorOrNull `json:"documentSelector"`
		WorkDoneProgress *bool                  `json:"workDoneProgress,omitzero"`
		PrepareProvider  *bool                  `json:"prepareProvider,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type PrepareRenameParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`

	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`
}

func (s *PrepareRenameParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument  TextDocumentIdentifier `json:"textDocument"`
		Position      Position               `json:"position"`
		WorkDoneToken *IntegerOrString       `json:"workDoneToken,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters of a ExecuteCommandRequest.
type ExecuteCommandParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// The identifier of the actual command handler.
	Command string `json:"command"`

	// Arguments that the command should be invoked with.
	Arguments *[]any `json:"arguments,omitzero"`
}

func (s *ExecuteCommandParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Command requiredProp `json:"command"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Command {
		return fmt.Errorf("required key 'command' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`
		Command       string           `json:"command"`
		Arguments     *[]any           `json:"arguments,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Registration options for a ExecuteCommandRequest.
type ExecuteCommandRegistrationOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The commands to be executed on the server
	Commands []string `json:"commands"`
}

func (s *ExecuteCommandRegistrationOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Commands requiredProp `json:"commands"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Commands {
		return fmt.Errorf("required key 'commands' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneProgress *bool    `json:"workDoneProgress,omitzero"`
		Commands         []string `json:"commands"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The parameters passed via an apply workspace edit request.
type ApplyWorkspaceEditParams struct {
	// An optional label of the workspace edit. This label is
	// presented in the user interface for example on an undo
	// stack to undo the workspace edit.
	Label *string `json:"label,omitzero"`

	// The edits to apply.
	Edit *WorkspaceEdit `json:"edit"`

	// Additional data about the edit.
	//
	// Since: 3.18.0
	//
	// Proposed.
	Metadata *WorkspaceEditMetadata `json:"metadata,omitzero"`
}

func (s *ApplyWorkspaceEditParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Edit requiredProp `json:"edit"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Edit {
		return fmt.Errorf("required key 'edit' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Label    *string                `json:"label,omitzero"`
		Edit     *WorkspaceEdit         `json:"edit"`
		Metadata *WorkspaceEditMetadata `json:"metadata,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The result returned from the apply workspace edit request.
//
// Since: 3.17 renamed from ApplyWorkspaceEditResponse
type ApplyWorkspaceEditResult struct {
	// Indicates whether the edit was applied or not.
	Applied bool `json:"applied"`

	// An optional textual description for why the edit was not applied.
	// This may be used by the server for diagnostic logging or to provide
	// a suitable error for a request that triggered the edit.
	FailureReason *string `json:"failureReason,omitzero"`

	// Depending on the client's failure handling strategy `failedChange` might
	// contain the index of the change that failed. This property is only available
	// if the client signals a `failureHandlingStrategy` in its client capabilities.
	FailedChange *uint32 `json:"failedChange,omitzero"`
}

func (s *ApplyWorkspaceEditResult) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Applied requiredProp `json:"applied"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Applied {
		return fmt.Errorf("required key 'applied' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Applied       bool    `json:"applied"`
		FailureReason *string `json:"failureReason,omitzero"`
		FailedChange  *uint32 `json:"failedChange,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type WorkDoneProgressBegin struct {
	Kind StringLiteralBegin `json:"kind"`

	// Mandatory title of the progress operation. Used to briefly inform about
	// the kind of operation being performed.
	//
	// Examples: "Indexing" or "Linking dependencies".
	Title string `json:"title"`

	// Controls if a cancel button should show to allow the user to cancel the
	// long running operation. Clients that don't support cancellation are allowed
	// to ignore the setting.
	Cancellable *bool `json:"cancellable,omitzero"`

	// Optional, more detailed associated progress message. Contains
	// complementary information to the `title`.
	//
	// Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
	// If unset, the previous progress message (if any) is still valid.
	Message *string `json:"message,omitzero"`

	// Optional progress percentage to display (value 100 is considered 100%).
	// If not provided infinite progress is assumed and clients are allowed
	// to ignore the `percentage` value in subsequent in report notifications.
	//
	// The value should be steadily rising. Clients are free to ignore values
	// that are not following this rule. The value range is [0, 100].
	Percentage *uint32 `json:"percentage,omitzero"`
}

func (s *WorkDoneProgressBegin) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind  requiredProp `json:"kind"`
		Title requiredProp `json:"title"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Title {
		return fmt.Errorf("required key 'title' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind        StringLiteralBegin `json:"kind"`
		Title       string             `json:"title"`
		Cancellable *bool              `json:"cancellable,omitzero"`
		Message     *string            `json:"message,omitzero"`
		Percentage  *uint32            `json:"percentage,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type WorkDoneProgressReport struct {
	Kind StringLiteralReport `json:"kind"`

	// Controls enablement state of a cancel button.
	//
	// Clients that don't support cancellation or don't support controlling the button's
	// enablement state are allowed to ignore the property.
	Cancellable *bool `json:"cancellable,omitzero"`

	// Optional, more detailed associated progress message. Contains
	// complementary information to the `title`.
	//
	// Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
	// If unset, the previous progress message (if any) is still valid.
	Message *string `json:"message,omitzero"`

	// Optional progress percentage to display (value 100 is considered 100%).
	// If not provided infinite progress is assumed and clients are allowed
	// to ignore the `percentage` value in subsequent in report notifications.
	//
	// The value should be steadily rising. Clients are free to ignore values
	// that are not following this rule. The value range is [0, 100]
	Percentage *uint32 `json:"percentage,omitzero"`
}

func (s *WorkDoneProgressReport) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind requiredProp `json:"kind"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind        StringLiteralReport `json:"kind"`
		Cancellable *bool               `json:"cancellable,omitzero"`
		Message     *string             `json:"message,omitzero"`
		Percentage  *uint32             `json:"percentage,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type WorkDoneProgressEnd struct {
	Kind StringLiteralEnd `json:"kind"`

	// Optional, a final message indicating to for example indicate the outcome
	// of the operation.
	Message *string `json:"message,omitzero"`
}

func (s *WorkDoneProgressEnd) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind requiredProp `json:"kind"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind    StringLiteralEnd `json:"kind"`
		Message *string          `json:"message,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type SetTraceParams struct {
	Value TraceValue `json:"value"`
}

func (s *SetTraceParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Value requiredProp `json:"value"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Value {
		return fmt.Errorf("required key 'value' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Value TraceValue `json:"value"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type LogTraceParams struct {
	Message string `json:"message"`

	Verbose *string `json:"verbose,omitzero"`
}

func (s *LogTraceParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Message requiredProp `json:"message"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Message {
		return fmt.Errorf("required key 'message' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Message string  `json:"message"`
		Verbose *string `json:"verbose,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type CancelParams struct {
	// The request id to cancel.
	Id IntegerOrString `json:"id"`
}

func (s *CancelParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Id requiredProp `json:"id"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Id {
		return fmt.Errorf("required key 'id' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Id IntegerOrString `json:"id"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type ProgressParams struct {
	// The progress token provided by the client or server.
	Token IntegerOrString `json:"token"`

	// The progress data.
	Value any `json:"value"`
}

func (s *ProgressParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Token requiredProp `json:"token"`
		Value requiredProp `json:"value"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Token {
		return fmt.Errorf("required key 'token' is missing")
	}
	if !keys.Value {
		return fmt.Errorf("required key 'value' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Token IntegerOrString `json:"token"`
		Value any             `json:"value"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A parameter literal used in requests to pass a text document and a position inside that
// document.
type TextDocumentPositionParams struct {
	// The text document.
	TextDocument TextDocumentIdentifier `json:"textDocument"`

	// The position inside the text document.
	Position Position `json:"position"`
}

func (s *TextDocumentPositionParams) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Position     requiredProp `json:"position"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Position {
		return fmt.Errorf("required key 'position' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument TextDocumentIdentifier `json:"textDocument"`
		Position     Position               `json:"position"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type WorkDoneProgressParams struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`
}

type PartialResultParams struct {
	// An optional token that a server can use to report partial results (e.g. streaming) to
	// the client.
	PartialResultToken *IntegerOrString `json:"partialResultToken,omitzero"`
}

// Represents the connection of two locations. Provides additional metadata over normal locations,
// including an origin range.
type LocationLink struct {
	// Span of the origin of this link.
	//
	// Used as the underlined span for mouse interaction. Defaults to the word range at
	// the definition position.
	OriginSelectionRange *Range `json:"originSelectionRange,omitzero"`

	// The target resource identifier of this link.
	TargetUri DocumentUri `json:"targetUri"`

	// The full target range of this link. If the target for example is a symbol then target range is the
	// range enclosing this symbol not including leading/trailing whitespace but everything else
	// like comments. This information is typically used to highlight the range in the editor.
	TargetRange Range `json:"targetRange"`

	// The range that should be selected and revealed when this link is being followed, e.g the name of a function.
	// Must be contained by the `targetRange`. See also `DocumentSymbol#range`
	TargetSelectionRange Range `json:"targetSelectionRange"`
}

func (s *LocationLink) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TargetUri            requiredProp `json:"targetUri"`
		TargetRange          requiredProp `json:"targetRange"`
		TargetSelectionRange requiredProp `json:"targetSelectionRange"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TargetUri {
		return fmt.Errorf("required key 'targetUri' is missing")
	}
	if !keys.TargetRange {
		return fmt.Errorf("required key 'targetRange' is missing")
	}
	if !keys.TargetSelectionRange {
		return fmt.Errorf("required key 'targetSelectionRange' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		OriginSelectionRange *Range      `json:"originSelectionRange,omitzero"`
		TargetUri            DocumentUri `json:"targetUri"`
		TargetRange          Range       `json:"targetRange"`
		TargetSelectionRange Range       `json:"targetSelectionRange"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A range in a text document expressed as (zero-based) start and end positions.
//
// If you want to specify a range that contains a line including the line ending
// character(s) then use an end position denoting the start of the next line.
// For example:
// ```ts
//
//	{
//	    start: { line: 5, character: 23 }
//	    end : { line 6, character : 0 }
//	}
//
// ```
type Range struct {
	// The range's start position.
	Start Position `json:"start"`

	// The range's end position.
	End Position `json:"end"`
}

func (s *Range) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Start requiredProp `json:"start"`
		End   requiredProp `json:"end"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Start {
		return fmt.Errorf("required key 'start' is missing")
	}
	if !keys.End {
		return fmt.Errorf("required key 'end' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Start Position `json:"start"`
		End   Position `json:"end"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type ImplementationOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// Static registration options to be returned in the initialize
// request.
type StaticRegistrationOptions struct {
	// The id used to register the request. The id can be used to deregister
	// the request again. See also Registration#id.
	Id *string `json:"id,omitzero"`
}

type TypeDefinitionOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// The workspace folder change event.
type WorkspaceFoldersChangeEvent struct {
	// The array of added workspace folders
	Added []*WorkspaceFolder `json:"added"`

	// The array of the removed workspace folders
	Removed []*WorkspaceFolder `json:"removed"`
}

func (s *WorkspaceFoldersChangeEvent) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Added   requiredProp `json:"added"`
		Removed requiredProp `json:"removed"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Added {
		return fmt.Errorf("required key 'added' is missing")
	}
	if !keys.Removed {
		return fmt.Errorf("required key 'removed' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Added   []*WorkspaceFolder `json:"added"`
		Removed []*WorkspaceFolder `json:"removed"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type ConfigurationItem struct {
	// The scope to get the configuration section for.
	ScopeUri *URI `json:"scopeUri,omitzero"`

	// The configuration section asked for.
	Section *string `json:"section,omitzero"`
}

// A literal to identify a text document in the client.
type TextDocumentIdentifier struct {
	// The text document's uri.
	Uri DocumentUri `json:"uri"`
}

func (s *TextDocumentIdentifier) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri requiredProp `json:"uri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri DocumentUri `json:"uri"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents a color in RGBA space.
type Color struct {
	// The red component of this color in the range [0-1].
	Red float64 `json:"red"`

	// The green component of this color in the range [0-1].
	Green float64 `json:"green"`

	// The blue component of this color in the range [0-1].
	Blue float64 `json:"blue"`

	// The alpha component of this color in the range [0-1].
	Alpha float64 `json:"alpha"`
}

func (s *Color) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Red   requiredProp `json:"red"`
		Green requiredProp `json:"green"`
		Blue  requiredProp `json:"blue"`
		Alpha requiredProp `json:"alpha"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Red {
		return fmt.Errorf("required key 'red' is missing")
	}
	if !keys.Green {
		return fmt.Errorf("required key 'green' is missing")
	}
	if !keys.Blue {
		return fmt.Errorf("required key 'blue' is missing")
	}
	if !keys.Alpha {
		return fmt.Errorf("required key 'alpha' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Red   float64 `json:"red"`
		Green float64 `json:"green"`
		Blue  float64 `json:"blue"`
		Alpha float64 `json:"alpha"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type DocumentColorOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

type FoldingRangeOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

type DeclarationOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// Position in a text document expressed as zero-based line and character
// offset. Prior to 3.17 the offsets were always based on a UTF-16 string
// representation. So a string of the form `a𐐀b` the character offset of the
// character `a` is 0, the character offset of `𐐀` is 1 and the character
// offset of b is 3 since `𐐀` is represented using two code units in UTF-16.
// Since 3.17 clients and servers can agree on a different string encoding
// representation (e.g. UTF-8). The client announces it's supported encoding
// via the client capability [`general.positionEncodings`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#clientCapabilities).
// The value is an array of position encodings the client supports, with
// decreasing preference (e.g. the encoding at index `0` is the most preferred
// one). To stay backwards compatible the only mandatory encoding is UTF-16
// represented via the string `utf-16`. The server can pick one of the
// encodings offered by the client and signals that encoding back to the
// client via the initialize result's property
// [`capabilities.positionEncoding`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#serverCapabilities). If the string value
// `utf-16` is missing from the client's capability `general.positionEncodings`
// servers can safely assume that the client supports UTF-16. If the server
// omits the position encoding in its initialize result the encoding defaults
// to the string value `utf-16`. Implementation considerations: since the
// conversion from one encoding into another requires the content of the
// file / line the conversion is best done where the file is read which is
// usually on the server side.
//
// Positions are line end character agnostic. So you can not specify a position
// that denotes `\r|\n` or `\n|` where `|` represents the character offset.
//
// Since: 3.17.0 - support for negotiated position encoding.
type Position struct {
	// Line position in a document (zero-based).
	Line uint32 `json:"line"`

	// Character offset on a line in a document (zero-based).
	//
	// The meaning of this offset is determined by the negotiated
	// `PositionEncodingKind`.
	Character uint32 `json:"character"`
}

func (s *Position) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Line      requiredProp `json:"line"`
		Character requiredProp `json:"character"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Line {
		return fmt.Errorf("required key 'line' is missing")
	}
	if !keys.Character {
		return fmt.Errorf("required key 'character' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Line      uint32 `json:"line"`
		Character uint32 `json:"character"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type SelectionRangeOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// Call hierarchy options used during static registration.
//
// Since: 3.16.0
type CallHierarchyOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// Since: 3.16.0
type SemanticTokensOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The legend used by the server
	Legend *SemanticTokensLegend `json:"legend"`

	// Server supports providing semantic tokens for a specific range
	// of a document.
	Range *BooleanOrEmptyObject `json:"range,omitzero"`

	// Server supports providing semantic tokens for a full document.
	Full *BooleanOrSemanticTokensFullDelta `json:"full,omitzero"`
}

func (s *SemanticTokensOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Legend requiredProp `json:"legend"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Legend {
		return fmt.Errorf("required key 'legend' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneProgress *bool                             `json:"workDoneProgress,omitzero"`
		Legend           *SemanticTokensLegend             `json:"legend"`
		Range            *BooleanOrEmptyObject             `json:"range,omitzero"`
		Full             *BooleanOrSemanticTokensFullDelta `json:"full,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.16.0
type SemanticTokensEdit struct {
	// The start offset of the edit.
	Start uint32 `json:"start"`

	// The count of elements to remove.
	DeleteCount uint32 `json:"deleteCount"`

	// The elements to insert.
	Data *[]uint32 `json:"data,omitzero"`
}

func (s *SemanticTokensEdit) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Start       requiredProp `json:"start"`
		DeleteCount requiredProp `json:"deleteCount"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Start {
		return fmt.Errorf("required key 'start' is missing")
	}
	if !keys.DeleteCount {
		return fmt.Errorf("required key 'deleteCount' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Start       uint32    `json:"start"`
		DeleteCount uint32    `json:"deleteCount"`
		Data        *[]uint32 `json:"data,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type LinkedEditingRangeOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// Represents information on a file/folder create.
//
// Since: 3.16.0
type FileCreate struct {
	// A file:// URI for the location of the file/folder being created.
	Uri string `json:"uri"`
}

func (s *FileCreate) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri requiredProp `json:"uri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri string `json:"uri"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Describes textual changes on a text document. A TextDocumentEdit describes all changes
// on a document version Si and after they are applied move the document to version Si+1.
// So the creator of a TextDocumentEdit doesn't need to sort the array of edits or do any
// kind of ordering. However the edits must be non overlapping.
type TextDocumentEdit struct {
	// The text document to change.
	TextDocument OptionalVersionedTextDocumentIdentifier `json:"textDocument"`

	// The edits to be applied.
	//
	// Since: 3.16.0 - support for AnnotatedTextEdit. This is guarded using a
	// client capability.
	//
	// Since: 3.18.0 - support for SnippetTextEdit. This is guarded using a
	// client capability.
	Edits []TextEditOrAnnotatedTextEditOrSnippetTextEdit `json:"edits"`
}

func (s *TextDocumentEdit) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TextDocument requiredProp `json:"textDocument"`
		Edits        requiredProp `json:"edits"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TextDocument {
		return fmt.Errorf("required key 'textDocument' is missing")
	}
	if !keys.Edits {
		return fmt.Errorf("required key 'edits' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TextDocument OptionalVersionedTextDocumentIdentifier        `json:"textDocument"`
		Edits        []TextEditOrAnnotatedTextEditOrSnippetTextEdit `json:"edits"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Create file operation.
type CreateFile struct {
	// A create
	Kind StringLiteralCreate `json:"kind"`

	// An optional annotation identifier describing the operation.
	//
	// Since: 3.16.0
	AnnotationId *string `json:"annotationId,omitzero"`

	// The resource to create.
	Uri DocumentUri `json:"uri"`

	// Additional options
	Options *CreateFileOptions `json:"options,omitzero"`
}

func (s *CreateFile) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind requiredProp `json:"kind"`
		Uri  requiredProp `json:"uri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind         StringLiteralCreate `json:"kind"`
		AnnotationId *string             `json:"annotationId,omitzero"`
		Uri          DocumentUri         `json:"uri"`
		Options      *CreateFileOptions  `json:"options,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Rename file operation
type RenameFile struct {
	// A rename
	Kind StringLiteralRename `json:"kind"`

	// An optional annotation identifier describing the operation.
	//
	// Since: 3.16.0
	AnnotationId *string `json:"annotationId,omitzero"`

	// The old (existing) location.
	OldUri DocumentUri `json:"oldUri"`

	// The new location.
	NewUri DocumentUri `json:"newUri"`

	// Rename options.
	Options *RenameFileOptions `json:"options,omitzero"`
}

func (s *RenameFile) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind   requiredProp `json:"kind"`
		OldUri requiredProp `json:"oldUri"`
		NewUri requiredProp `json:"newUri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.OldUri {
		return fmt.Errorf("required key 'oldUri' is missing")
	}
	if !keys.NewUri {
		return fmt.Errorf("required key 'newUri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind         StringLiteralRename `json:"kind"`
		AnnotationId *string             `json:"annotationId,omitzero"`
		OldUri       DocumentUri         `json:"oldUri"`
		NewUri       DocumentUri         `json:"newUri"`
		Options      *RenameFileOptions  `json:"options,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Delete file operation
type DeleteFile struct {
	// A delete
	Kind StringLiteralDelete `json:"kind"`

	// An optional annotation identifier describing the operation.
	//
	// Since: 3.16.0
	AnnotationId *string `json:"annotationId,omitzero"`

	// The file to delete.
	Uri DocumentUri `json:"uri"`

	// Delete options.
	Options *DeleteFileOptions `json:"options,omitzero"`
}

func (s *DeleteFile) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind requiredProp `json:"kind"`
		Uri  requiredProp `json:"uri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind         StringLiteralDelete `json:"kind"`
		AnnotationId *string             `json:"annotationId,omitzero"`
		Uri          DocumentUri         `json:"uri"`
		Options      *DeleteFileOptions  `json:"options,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Additional information that describes document changes.
//
// Since: 3.16.0
type ChangeAnnotation struct {
	// A human-readable string describing the actual change. The string
	// is rendered prominent in the user interface.
	Label string `json:"label"`

	// A flag which indicates that user confirmation is needed
	// before applying the change.
	NeedsConfirmation *bool `json:"needsConfirmation,omitzero"`

	// A human-readable string which is rendered less prominent in
	// the user interface.
	Description *string `json:"description,omitzero"`
}

func (s *ChangeAnnotation) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Label requiredProp `json:"label"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Label {
		return fmt.Errorf("required key 'label' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Label             string  `json:"label"`
		NeedsConfirmation *bool   `json:"needsConfirmation,omitzero"`
		Description       *string `json:"description,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A filter to describe in which file operation requests or notifications
// the server is interested in receiving.
//
// Since: 3.16.0
type FileOperationFilter struct {
	// A Uri scheme like `file` or `untitled`.
	Scheme *string `json:"scheme,omitzero"`

	// The actual file operation pattern.
	Pattern *FileOperationPattern `json:"pattern"`
}

func (s *FileOperationFilter) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Pattern requiredProp `json:"pattern"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Pattern {
		return fmt.Errorf("required key 'pattern' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Scheme  *string               `json:"scheme,omitzero"`
		Pattern *FileOperationPattern `json:"pattern"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents information on a file/folder rename.
//
// Since: 3.16.0
type FileRename struct {
	// A file:// URI for the original location of the file/folder being renamed.
	OldUri string `json:"oldUri"`

	// A file:// URI for the new location of the file/folder being renamed.
	NewUri string `json:"newUri"`
}

func (s *FileRename) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		OldUri requiredProp `json:"oldUri"`
		NewUri requiredProp `json:"newUri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.OldUri {
		return fmt.Errorf("required key 'oldUri' is missing")
	}
	if !keys.NewUri {
		return fmt.Errorf("required key 'newUri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		OldUri string `json:"oldUri"`
		NewUri string `json:"newUri"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents information on a file/folder delete.
//
// Since: 3.16.0
type FileDelete struct {
	// A file:// URI for the location of the file/folder being deleted.
	Uri string `json:"uri"`
}

func (s *FileDelete) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri requiredProp `json:"uri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri string `json:"uri"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type MonikerOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// Type hierarchy options used during static registration.
//
// Since: 3.17.0
type TypeHierarchyOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// Since: 3.17.0
type InlineValueContext struct {
	// The stack frame (as a DAP Id) where the execution has stopped.
	FrameId int32 `json:"frameId"`

	// The document range where execution has stopped.
	// Typically the end position of the range denotes the line where the inline values are shown.
	StoppedLocation Range `json:"stoppedLocation"`
}

func (s *InlineValueContext) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		FrameId         requiredProp `json:"frameId"`
		StoppedLocation requiredProp `json:"stoppedLocation"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.FrameId {
		return fmt.Errorf("required key 'frameId' is missing")
	}
	if !keys.StoppedLocation {
		return fmt.Errorf("required key 'stoppedLocation' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		FrameId         int32 `json:"frameId"`
		StoppedLocation Range `json:"stoppedLocation"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Provide inline value as text.
//
// Since: 3.17.0
type InlineValueText struct {
	// The document range for which the inline value applies.
	Range Range `json:"range"`

	// The text of the inline value.
	Text string `json:"text"`
}

func (s *InlineValueText) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range requiredProp `json:"range"`
		Text  requiredProp `json:"text"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.Text {
		return fmt.Errorf("required key 'text' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range Range  `json:"range"`
		Text  string `json:"text"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Provide inline value through a variable lookup.
// If only a range is specified, the variable name will be extracted from the underlying document.
// An optional variable name can be used to override the extracted name.
//
// Since: 3.17.0
type InlineValueVariableLookup struct {
	// The document range for which the inline value applies.
	// The range is used to extract the variable name from the underlying document.
	Range Range `json:"range"`

	// If specified the name of the variable to look up.
	VariableName *string `json:"variableName,omitzero"`

	// How to perform the lookup.
	CaseSensitiveLookup bool `json:"caseSensitiveLookup"`
}

func (s *InlineValueVariableLookup) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range               requiredProp `json:"range"`
		CaseSensitiveLookup requiredProp `json:"caseSensitiveLookup"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.CaseSensitiveLookup {
		return fmt.Errorf("required key 'caseSensitiveLookup' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range               Range   `json:"range"`
		VariableName        *string `json:"variableName,omitzero"`
		CaseSensitiveLookup bool    `json:"caseSensitiveLookup"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Provide an inline value through an expression evaluation.
// If only a range is specified, the expression will be extracted from the underlying document.
// An optional expression can be used to override the extracted expression.
//
// Since: 3.17.0
type InlineValueEvaluatableExpression struct {
	// The document range for which the inline value applies.
	// The range is used to extract the evaluatable expression from the underlying document.
	Range Range `json:"range"`

	// If specified the expression overrides the extracted expression.
	Expression *string `json:"expression,omitzero"`
}

func (s *InlineValueEvaluatableExpression) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range requiredProp `json:"range"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range      Range   `json:"range"`
		Expression *string `json:"expression,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Inline value options used during static registration.
//
// Since: 3.17.0
type InlineValueOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// An inlay hint label part allows for interactive and composite labels
// of inlay hints.
//
// Since: 3.17.0
type InlayHintLabelPart struct {
	// The value of this label part.
	Value string `json:"value"`

	// The tooltip text when you hover over this label part. Depending on
	// the client capability `inlayHint.resolveSupport` clients might resolve
	// this property late using the resolve request.
	Tooltip *StringOrMarkupContent `json:"tooltip,omitzero"`

	// An optional source code location that represents this
	// label part.
	//
	// The editor will use this location for the hover and for code navigation
	// features: This part will become a clickable link that resolves to the
	// definition of the symbol at the given location (not necessarily the
	// location itself), it shows the hover that shows at the given location,
	// and it shows a context menu with further code navigation commands.
	//
	// Depending on the client capability `inlayHint.resolveSupport` clients
	// might resolve this property late using the resolve request.
	Location *Location `json:"location,omitzero"`

	// An optional command for this label part.
	//
	// Depending on the client capability `inlayHint.resolveSupport` clients
	// might resolve this property late using the resolve request.
	Command *Command `json:"command,omitzero"`
}

func (s *InlayHintLabelPart) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Value requiredProp `json:"value"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Value {
		return fmt.Errorf("required key 'value' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Value    string                 `json:"value"`
		Tooltip  *StringOrMarkupContent `json:"tooltip,omitzero"`
		Location *Location              `json:"location,omitzero"`
		Command  *Command               `json:"command,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A `MarkupContent` literal represents a string value which content is interpreted base on its
// kind flag. Currently the protocol supports `plaintext` and `markdown` as markup kinds.
//
// If the kind is `markdown` then the value can contain fenced code blocks like in GitHub issues.
// See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
//
// Here is an example how such a string can be constructed using JavaScript / TypeScript:
// ```ts
//
//	let markdown: MarkdownContent = {
//	 kind: MarkupKind.Markdown,
//	 value: [
//	   '# Header',
//	   'Some text',
//	   '```typescript',
//	   'someCode();',
//	   '```'
//	 ].join('\n')
//	};
//
// ```
//
// *Please Note* that clients might sanitize the return markdown. A client could decide to
// remove HTML from the markdown to avoid script execution.
type MarkupContent struct {
	// The type of the Markup
	Kind MarkupKind `json:"kind"`

	// The content itself
	Value string `json:"value"`
}

func (s *MarkupContent) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind  requiredProp `json:"kind"`
		Value requiredProp `json:"value"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Value {
		return fmt.Errorf("required key 'value' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind  MarkupKind `json:"kind"`
		Value string     `json:"value"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Inlay hint options used during static registration.
//
// Since: 3.17.0
type InlayHintOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The server provides support to resolve additional
	// information for an inlay hint item.
	ResolveProvider *bool `json:"resolveProvider,omitzero"`
}

// A full diagnostic report with a set of related documents.
//
// Since: 3.17.0
type RelatedFullDocumentDiagnosticReport struct {
	// A full document diagnostic report.
	Kind StringLiteralFull `json:"kind"`

	// An optional result id. If provided it will
	// be sent on the next diagnostic request for the
	// same document.
	ResultId *string `json:"resultId,omitzero"`

	// The actual items.
	Items []*Diagnostic `json:"items"`

	// Diagnostics of related documents. This information is useful
	// in programming languages where code in a file A can generate
	// diagnostics in a file B which A depends on. An example of
	// such a language is C/C++ where marco definitions in a file
	// a.cpp and result in errors in a header file b.hpp.
	//
	// Since: 3.17.0
	RelatedDocuments *map[DocumentUri]FullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport `json:"relatedDocuments,omitzero"`
}

func (s *RelatedFullDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind  requiredProp `json:"kind"`
		Items requiredProp `json:"items"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Items {
		return fmt.Errorf("required key 'items' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind             StringLiteralFull                                                                `json:"kind"`
		ResultId         *string                                                                          `json:"resultId,omitzero"`
		Items            []*Diagnostic                                                                    `json:"items"`
		RelatedDocuments *map[DocumentUri]FullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport `json:"relatedDocuments,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// An unchanged diagnostic report with a set of related documents.
//
// Since: 3.17.0
type RelatedUnchangedDocumentDiagnosticReport struct {
	// A document diagnostic report indicating
	// no changes to the last result. A server can
	// only return `unchanged` if result ids are
	// provided.
	Kind StringLiteralUnchanged `json:"kind"`

	// A result id which will be sent on the next
	// diagnostic request for the same document.
	ResultId string `json:"resultId"`

	// Diagnostics of related documents. This information is useful
	// in programming languages where code in a file A can generate
	// diagnostics in a file B which A depends on. An example of
	// such a language is C/C++ where marco definitions in a file
	// a.cpp and result in errors in a header file b.hpp.
	//
	// Since: 3.17.0
	RelatedDocuments *map[DocumentUri]FullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport `json:"relatedDocuments,omitzero"`
}

func (s *RelatedUnchangedDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind     requiredProp `json:"kind"`
		ResultId requiredProp `json:"resultId"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.ResultId {
		return fmt.Errorf("required key 'resultId' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind             StringLiteralUnchanged                                                           `json:"kind"`
		ResultId         string                                                                           `json:"resultId"`
		RelatedDocuments *map[DocumentUri]FullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport `json:"relatedDocuments,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A diagnostic report with a full set of problems.
//
// Since: 3.17.0
type FullDocumentDiagnosticReport struct {
	// A full document diagnostic report.
	Kind StringLiteralFull `json:"kind"`

	// An optional result id. If provided it will
	// be sent on the next diagnostic request for the
	// same document.
	ResultId *string `json:"resultId,omitzero"`

	// The actual items.
	Items []*Diagnostic `json:"items"`
}

func (s *FullDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind  requiredProp `json:"kind"`
		Items requiredProp `json:"items"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Items {
		return fmt.Errorf("required key 'items' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind     StringLiteralFull `json:"kind"`
		ResultId *string           `json:"resultId,omitzero"`
		Items    []*Diagnostic     `json:"items"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A diagnostic report indicating that the last returned
// report is still accurate.
//
// Since: 3.17.0
type UnchangedDocumentDiagnosticReport struct {
	// A document diagnostic report indicating
	// no changes to the last result. A server can
	// only return `unchanged` if result ids are
	// provided.
	Kind StringLiteralUnchanged `json:"kind"`

	// A result id which will be sent on the next
	// diagnostic request for the same document.
	ResultId string `json:"resultId"`
}

func (s *UnchangedDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind     requiredProp `json:"kind"`
		ResultId requiredProp `json:"resultId"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.ResultId {
		return fmt.Errorf("required key 'resultId' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind     StringLiteralUnchanged `json:"kind"`
		ResultId string                 `json:"resultId"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Diagnostic options.
//
// Since: 3.17.0
type DiagnosticOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// An optional identifier under which the diagnostics are
	// managed by the client.
	Identifier *string `json:"identifier,omitzero"`

	// Whether the language has inter file dependencies meaning that
	// editing code in one file can result in a different diagnostic
	// set in another file. Inter file dependencies are common for
	// most programming languages and typically uncommon for linters.
	InterFileDependencies bool `json:"interFileDependencies"`

	// The server provides support for workspace diagnostics as well.
	WorkspaceDiagnostics bool `json:"workspaceDiagnostics"`
}

func (s *DiagnosticOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		InterFileDependencies requiredProp `json:"interFileDependencies"`
		WorkspaceDiagnostics  requiredProp `json:"workspaceDiagnostics"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.InterFileDependencies {
		return fmt.Errorf("required key 'interFileDependencies' is missing")
	}
	if !keys.WorkspaceDiagnostics {
		return fmt.Errorf("required key 'workspaceDiagnostics' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneProgress      *bool   `json:"workDoneProgress,omitzero"`
		Identifier            *string `json:"identifier,omitzero"`
		InterFileDependencies bool    `json:"interFileDependencies"`
		WorkspaceDiagnostics  bool    `json:"workspaceDiagnostics"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A previous result id in a workspace pull request.
//
// Since: 3.17.0
type PreviousResultId struct {
	// The URI for which the client knowns a
	// result id.
	Uri DocumentUri `json:"uri"`

	// The value of the previous result id.
	Value string `json:"value"`
}

func (s *PreviousResultId) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri   requiredProp `json:"uri"`
		Value requiredProp `json:"value"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.Value {
		return fmt.Errorf("required key 'value' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri   DocumentUri `json:"uri"`
		Value string      `json:"value"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A notebook document.
//
// Since: 3.17.0
type NotebookDocument struct {
	// The notebook document's uri.
	Uri URI `json:"uri"`

	// The type of the notebook.
	NotebookType string `json:"notebookType"`

	// The version number of this document (it will increase after each
	// change, including undo/redo).
	Version int32 `json:"version"`

	// Additional metadata stored with the notebook
	// document.
	//
	// Note: should always be an object literal (e.g. LSPObject)
	Metadata *map[string]any `json:"metadata,omitzero"`

	// The cells of a notebook.
	Cells []*NotebookCell `json:"cells"`
}

func (s *NotebookDocument) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri          requiredProp `json:"uri"`
		NotebookType requiredProp `json:"notebookType"`
		Version      requiredProp `json:"version"`
		Cells        requiredProp `json:"cells"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.NotebookType {
		return fmt.Errorf("required key 'notebookType' is missing")
	}
	if !keys.Version {
		return fmt.Errorf("required key 'version' is missing")
	}
	if !keys.Cells {
		return fmt.Errorf("required key 'cells' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri          URI             `json:"uri"`
		NotebookType string          `json:"notebookType"`
		Version      int32           `json:"version"`
		Metadata     *map[string]any `json:"metadata,omitzero"`
		Cells        []*NotebookCell `json:"cells"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// An item to transfer a text document from the client to the
// server.
type TextDocumentItem struct {
	// The text document's uri.
	Uri DocumentUri `json:"uri"`

	// The text document's language identifier.
	LanguageId LanguageKind `json:"languageId"`

	// The version number of this document (it will increase after each
	// change, including undo/redo).
	Version int32 `json:"version"`

	// The content of the opened text document.
	Text string `json:"text"`
}

func (s *TextDocumentItem) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri        requiredProp `json:"uri"`
		LanguageId requiredProp `json:"languageId"`
		Version    requiredProp `json:"version"`
		Text       requiredProp `json:"text"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.LanguageId {
		return fmt.Errorf("required key 'languageId' is missing")
	}
	if !keys.Version {
		return fmt.Errorf("required key 'version' is missing")
	}
	if !keys.Text {
		return fmt.Errorf("required key 'text' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri        DocumentUri  `json:"uri"`
		LanguageId LanguageKind `json:"languageId"`
		Version    int32        `json:"version"`
		Text       string       `json:"text"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Options specific to a notebook plus its cells
// to be synced to the server.
//
// If a selector provides a notebook document
// filter but no cell selector all cells of a
// matching notebook document will be synced.
//
// If a selector provides no notebook document
// filter but only a cell selector all notebook
// document that contain at least one matching
// cell will be synced.
//
// Since: 3.17.0
type NotebookDocumentSyncOptions struct {
	// The notebooks to be synced
	NotebookSelector []NotebookDocumentFilterWithNotebookOrCells `json:"notebookSelector"`

	// Whether save notification should be forwarded to
	// the server. Will only be honored if mode === `notebook`.
	Save *bool `json:"save,omitzero"`
}

func (s *NotebookDocumentSyncOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		NotebookSelector requiredProp `json:"notebookSelector"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.NotebookSelector {
		return fmt.Errorf("required key 'notebookSelector' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		NotebookSelector []NotebookDocumentFilterWithNotebookOrCells `json:"notebookSelector"`
		Save             *bool                                       `json:"save,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A versioned notebook document identifier.
//
// Since: 3.17.0
type VersionedNotebookDocumentIdentifier struct {
	// The version number of this notebook document.
	Version int32 `json:"version"`

	// The notebook document's uri.
	Uri URI `json:"uri"`
}

func (s *VersionedNotebookDocumentIdentifier) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Version requiredProp `json:"version"`
		Uri     requiredProp `json:"uri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Version {
		return fmt.Errorf("required key 'version' is missing")
	}
	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Version int32 `json:"version"`
		Uri     URI   `json:"uri"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A change event for a notebook document.
//
// Since: 3.17.0
type NotebookDocumentChangeEvent struct {
	// The changed meta data if any.
	//
	// Note: should always be an object literal (e.g. LSPObject)
	Metadata *map[string]any `json:"metadata,omitzero"`

	// Changes to cells
	Cells *NotebookDocumentCellChanges `json:"cells,omitzero"`
}

// A literal to identify a notebook document in the client.
//
// Since: 3.17.0
type NotebookDocumentIdentifier struct {
	// The notebook document's uri.
	Uri URI `json:"uri"`
}

func (s *NotebookDocumentIdentifier) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri requiredProp `json:"uri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri URI `json:"uri"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Provides information about the context in which an inline completion was requested.
//
// Since: 3.18.0
//
// Proposed.
type InlineCompletionContext struct {
	// Describes how the inline completion was triggered.
	TriggerKind InlineCompletionTriggerKind `json:"triggerKind"`

	// Provides information about the currently selected item in the autocomplete widget if it is visible.
	SelectedCompletionInfo *SelectedCompletionInfo `json:"selectedCompletionInfo,omitzero"`
}

func (s *InlineCompletionContext) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TriggerKind requiredProp `json:"triggerKind"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TriggerKind {
		return fmt.Errorf("required key 'triggerKind' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TriggerKind            InlineCompletionTriggerKind `json:"triggerKind"`
		SelectedCompletionInfo *SelectedCompletionInfo     `json:"selectedCompletionInfo,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A string value used as a snippet is a template which allows to insert text
// and to control the editor cursor when insertion happens.
//
// A snippet can define tab stops and placeholders with `$1`, `$2`
// and `${3:foo}`. `$0` defines the final tab stop, it defaults to
// the end of the snippet. Variables are defined with `$name` and
// `${name:default value}`.
//
// Since: 3.18.0
//
// Proposed.
type StringValue struct {
	// The kind of string value.
	Kind StringLiteralSnippet `json:"kind"`

	// The snippet string.
	Value string `json:"value"`
}

func (s *StringValue) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind  requiredProp `json:"kind"`
		Value requiredProp `json:"value"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Value {
		return fmt.Errorf("required key 'value' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind  StringLiteralSnippet `json:"kind"`
		Value string               `json:"value"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Inline completion options used during static registration.
//
// Since: 3.18.0
//
// Proposed.
type InlineCompletionOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// Text document content provider options.
//
// Since: 3.18.0
//
// Proposed.
type TextDocumentContentOptions struct {
	// The schemes for which the server provides content.
	Schemes []string `json:"schemes"`
}

func (s *TextDocumentContentOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Schemes requiredProp `json:"schemes"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Schemes {
		return fmt.Errorf("required key 'schemes' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Schemes []string `json:"schemes"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// General parameters to register for a notification or to register a provider.
type Registration struct {
	// The id used to register the request. The id can be used to deregister
	// the request again.
	Id string `json:"id"`

	// The method / capability to register for.
	Method string `json:"method"`

	// Options necessary for the registration.
	RegisterOptions *any `json:"registerOptions,omitzero"`
}

func (s *Registration) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Id     requiredProp `json:"id"`
		Method requiredProp `json:"method"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Id {
		return fmt.Errorf("required key 'id' is missing")
	}
	if !keys.Method {
		return fmt.Errorf("required key 'method' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Id              string `json:"id"`
		Method          string `json:"method"`
		RegisterOptions *any   `json:"registerOptions,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// General parameters to unregister a request or notification.
type Unregistration struct {
	// The id used to unregister the request or notification. Usually an id
	// provided during the register request.
	Id string `json:"id"`

	// The method to unregister for.
	Method string `json:"method"`
}

func (s *Unregistration) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Id     requiredProp `json:"id"`
		Method requiredProp `json:"method"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Id {
		return fmt.Errorf("required key 'id' is missing")
	}
	if !keys.Method {
		return fmt.Errorf("required key 'method' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Id     string `json:"id"`
		Method string `json:"method"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The initialize parameters
type InitializeParamsBase struct {
	// An optional token that a server can use to report work done progress.
	WorkDoneToken *IntegerOrString `json:"workDoneToken,omitzero"`

	// The process Id of the parent process that started
	// the server.
	//
	// Is `null` if the process has not been started by another process.
	// If the parent process is not alive then the server should exit.
	ProcessId IntegerOrNull `json:"processId"`

	// Information about the client
	//
	// Since: 3.15.0
	ClientInfo *ClientInfo `json:"clientInfo,omitzero"`

	// The locale the client is currently showing the user interface
	// in. This must not necessarily be the locale of the operating
	// system.
	//
	// Uses IETF language tags as the value's syntax
	// (See https://en.wikipedia.org/wiki/IETF_language_tag)
	//
	// Since: 3.16.0
	Locale *string `json:"locale,omitzero"`

	// The rootPath of the workspace. Is null
	// if no folder is open.
	//
	// Deprecated: in favour of rootUri.
	RootPath *StringOrNull `json:"rootPath,omitzero"`

	// The rootUri of the workspace. Is null if no
	// folder is open. If both `rootPath` and `rootUri` are set
	// `rootUri` wins.
	//
	// Deprecated: in favour of workspaceFolders.
	RootUri DocumentUriOrNull `json:"rootUri"`

	// The capabilities provided by the client (editor or tool)
	Capabilities *ClientCapabilities `json:"capabilities"`

	// User provided initialization options.
	InitializationOptions *any `json:"initializationOptions,omitzero"`

	// The initial trace setting. If omitted trace is disabled ('off').
	Trace *TraceValue `json:"trace,omitzero"`
}

func (s *InitializeParamsBase) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		ProcessId    requiredProp `json:"processId"`
		RootUri      requiredProp `json:"rootUri"`
		Capabilities requiredProp `json:"capabilities"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.ProcessId {
		return fmt.Errorf("required key 'processId' is missing")
	}
	if !keys.RootUri {
		return fmt.Errorf("required key 'rootUri' is missing")
	}
	if !keys.Capabilities {
		return fmt.Errorf("required key 'capabilities' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneToken         *IntegerOrString    `json:"workDoneToken,omitzero"`
		ProcessId             IntegerOrNull       `json:"processId"`
		ClientInfo            *ClientInfo         `json:"clientInfo,omitzero"`
		Locale                *string             `json:"locale,omitzero"`
		RootPath              *StringOrNull       `json:"rootPath,omitzero"`
		RootUri               DocumentUriOrNull   `json:"rootUri"`
		Capabilities          *ClientCapabilities `json:"capabilities"`
		InitializationOptions *any                `json:"initializationOptions,omitzero"`
		Trace                 *TraceValue         `json:"trace,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type WorkspaceFoldersInitializeParams struct {
	// The workspace folders configured in the client when the server starts.
	//
	// This property is only available if the client supports workspace folders.
	// It can be `null` if the client supports workspace folders but none are
	// configured.
	//
	// Since: 3.6.0
	WorkspaceFolders *WorkspaceFoldersOrNull `json:"workspaceFolders,omitzero"`
}

// Defines the capabilities provided by a language
// server.
type ServerCapabilities struct {
	// The position encoding the server picked from the encodings offered
	// by the client via the client capability `general.positionEncodings`.
	//
	// If the client didn't provide any position encodings the only valid
	// value that a server can return is 'utf-16'.
	//
	// If omitted it defaults to 'utf-16'.
	//
	// Since: 3.17.0
	PositionEncoding *PositionEncodingKind `json:"positionEncoding,omitzero"`

	// Defines how text documents are synced. Is either a detailed structure
	// defining each notification or for backwards compatibility the
	// TextDocumentSyncKind number.
	TextDocumentSync *TextDocumentSyncOptionsOrKind `json:"textDocumentSync,omitzero"`

	// Defines how notebook documents are synced.
	//
	// Since: 3.17.0
	NotebookDocumentSync *NotebookDocumentSyncOptionsOrRegistrationOptions `json:"notebookDocumentSync,omitzero"`

	// The server provides completion support.
	CompletionProvider *CompletionOptions `json:"completionProvider,omitzero"`

	// The server provides hover support.
	HoverProvider *BooleanOrHoverOptions `json:"hoverProvider,omitzero"`

	// The server provides signature help support.
	SignatureHelpProvider *SignatureHelpOptions `json:"signatureHelpProvider,omitzero"`

	// The server provides Goto Declaration support.
	DeclarationProvider *BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions `json:"declarationProvider,omitzero"`

	// The server provides goto definition support.
	DefinitionProvider *BooleanOrDefinitionOptions `json:"definitionProvider,omitzero"`

	// The server provides Goto Type Definition support.
	TypeDefinitionProvider *BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions `json:"typeDefinitionProvider,omitzero"`

	// The server provides Goto Implementation support.
	ImplementationProvider *BooleanOrImplementationOptionsOrImplementationRegistrationOptions `json:"implementationProvider,omitzero"`

	// The server provides find references support.
	ReferencesProvider *BooleanOrReferenceOptions `json:"referencesProvider,omitzero"`

	// The server provides document highlight support.
	DocumentHighlightProvider *BooleanOrDocumentHighlightOptions `json:"documentHighlightProvider,omitzero"`

	// The server provides document symbol support.
	DocumentSymbolProvider *BooleanOrDocumentSymbolOptions `json:"documentSymbolProvider,omitzero"`

	// The server provides code actions. CodeActionOptions may only be
	// specified if the client states that it supports
	// `codeActionLiteralSupport` in its initial `initialize` request.
	CodeActionProvider *BooleanOrCodeActionOptions `json:"codeActionProvider,omitzero"`

	// The server provides code lens.
	CodeLensProvider *CodeLensOptions `json:"codeLensProvider,omitzero"`

	// The server provides document link support.
	DocumentLinkProvider *DocumentLinkOptions `json:"documentLinkProvider,omitzero"`

	// The server provides color provider support.
	ColorProvider *BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions `json:"colorProvider,omitzero"`

	// The server provides workspace symbol support.
	WorkspaceSymbolProvider *BooleanOrWorkspaceSymbolOptions `json:"workspaceSymbolProvider,omitzero"`

	// The server provides document formatting.
	DocumentFormattingProvider *BooleanOrDocumentFormattingOptions `json:"documentFormattingProvider,omitzero"`

	// The server provides document range formatting.
	DocumentRangeFormattingProvider *BooleanOrDocumentRangeFormattingOptions `json:"documentRangeFormattingProvider,omitzero"`

	// The server provides document formatting on typing.
	DocumentOnTypeFormattingProvider *DocumentOnTypeFormattingOptions `json:"documentOnTypeFormattingProvider,omitzero"`

	// The server provides rename support. RenameOptions may only be
	// specified if the client states that it supports
	// `prepareSupport` in its initial `initialize` request.
	RenameProvider *BooleanOrRenameOptions `json:"renameProvider,omitzero"`

	// The server provides folding provider support.
	FoldingRangeProvider *BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions `json:"foldingRangeProvider,omitzero"`

	// The server provides selection range support.
	SelectionRangeProvider *BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions `json:"selectionRangeProvider,omitzero"`

	// The server provides execute command support.
	ExecuteCommandProvider *ExecuteCommandOptions `json:"executeCommandProvider,omitzero"`

	// The server provides call hierarchy support.
	//
	// Since: 3.16.0
	CallHierarchyProvider *BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions `json:"callHierarchyProvider,omitzero"`

	// The server provides linked editing range support.
	//
	// Since: 3.16.0
	LinkedEditingRangeProvider *BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions `json:"linkedEditingRangeProvider,omitzero"`

	// The server provides semantic tokens support.
	//
	// Since: 3.16.0
	SemanticTokensProvider *SemanticTokensOptionsOrRegistrationOptions `json:"semanticTokensProvider,omitzero"`

	// The server provides moniker support.
	//
	// Since: 3.16.0
	MonikerProvider *BooleanOrMonikerOptionsOrMonikerRegistrationOptions `json:"monikerProvider,omitzero"`

	// The server provides type hierarchy support.
	//
	// Since: 3.17.0
	TypeHierarchyProvider *BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions `json:"typeHierarchyProvider,omitzero"`

	// The server provides inline values.
	//
	// Since: 3.17.0
	InlineValueProvider *BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions `json:"inlineValueProvider,omitzero"`

	// The server provides inlay hints.
	//
	// Since: 3.17.0
	InlayHintProvider *BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions `json:"inlayHintProvider,omitzero"`

	// The server has support for pull model diagnostics.
	//
	// Since: 3.17.0
	DiagnosticProvider *DiagnosticOptionsOrRegistrationOptions `json:"diagnosticProvider,omitzero"`

	// Inline completion options used during static registration.
	//
	// Since: 3.18.0
	//
	// Proposed.
	InlineCompletionProvider *BooleanOrInlineCompletionOptions `json:"inlineCompletionProvider,omitzero"`

	// Workspace specific server capabilities.
	Workspace *WorkspaceOptions `json:"workspace,omitzero"`

	// Experimental server capabilities.
	Experimental *any `json:"experimental,omitzero"`
}

// Information about the server
//
// Since: 3.15.0
//
// Since: 3.18.0 ServerInfo type name added.
type ServerInfo struct {
	// The name of the server as defined by the server.
	Name string `json:"name"`

	// The server's version as defined by the server.
	Version *string `json:"version,omitzero"`
}

func (s *ServerInfo) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Name requiredProp `json:"name"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Name {
		return fmt.Errorf("required key 'name' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Name    string  `json:"name"`
		Version *string `json:"version,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A text document identifier to denote a specific version of a text document.
type VersionedTextDocumentIdentifier struct {
	// The text document's uri.
	Uri DocumentUri `json:"uri"`

	// The version number of this document.
	Version int32 `json:"version"`
}

func (s *VersionedTextDocumentIdentifier) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri     requiredProp `json:"uri"`
		Version requiredProp `json:"version"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.Version {
		return fmt.Errorf("required key 'version' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri     DocumentUri `json:"uri"`
		Version int32       `json:"version"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Save options.
type SaveOptions struct {
	// The client is supposed to include the content on save.
	IncludeText *bool `json:"includeText,omitzero"`
}

// An event describing a file change.
type FileEvent struct {
	// The file's uri.
	Uri DocumentUri `json:"uri"`

	// The change type.
	Type FileChangeType `json:"type"`
}

func (s *FileEvent) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri  requiredProp `json:"uri"`
		Type requiredProp `json:"type"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.Type {
		return fmt.Errorf("required key 'type' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri  DocumentUri    `json:"uri"`
		Type FileChangeType `json:"type"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type FileSystemWatcher struct {
	// The glob pattern to watch. See pattern for more detail.
	//
	// Since: 3.17.0 support for relative patterns.
	GlobPattern PatternOrRelativePattern `json:"globPattern"`

	// The kind of events of interest. If omitted it defaults
	// to WatchKind.Create | WatchKind.Change | WatchKind.Delete
	// which is 7.
	Kind *WatchKind `json:"kind,omitzero"`
}

func (s *FileSystemWatcher) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		GlobPattern requiredProp `json:"globPattern"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.GlobPattern {
		return fmt.Errorf("required key 'globPattern' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		GlobPattern PatternOrRelativePattern `json:"globPattern"`
		Kind        *WatchKind               `json:"kind,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
// are only valid in the scope of a resource.
type Diagnostic struct {
	// The range at which the message applies
	Range Range `json:"range"`

	// The diagnostic's severity. To avoid interpretation mismatches when a
	// server is used with different clients it is highly recommended that servers
	// always provide a severity value.
	Severity *DiagnosticSeverity `json:"severity,omitzero"`

	// The diagnostic's code, which usually appear in the user interface.
	Code *IntegerOrString `json:"code,omitzero"`

	// An optional property to describe the error code.
	// Requires the code field (above) to be present/not null.
	//
	// Since: 3.16.0
	CodeDescription *CodeDescription `json:"codeDescription,omitzero"`

	// A human-readable string describing the source of this
	// diagnostic, e.g. 'typescript' or 'super lint'. It usually
	// appears in the user interface.
	Source *string `json:"source,omitzero"`

	// The diagnostic's message. It usually appears in the user interface
	Message string `json:"message"`

	// Additional metadata about the diagnostic.
	//
	// Since: 3.15.0
	Tags *[]DiagnosticTag `json:"tags,omitzero"`

	// An array of related diagnostic information, e.g. when symbol-names within
	// a scope collide all definitions can be marked via this property.
	RelatedInformation *[]*DiagnosticRelatedInformation `json:"relatedInformation,omitzero"`

	// A data entry field that is preserved between a `textDocument/publishDiagnostics`
	// notification and `textDocument/codeAction` request.
	//
	// Since: 3.16.0
	Data *any `json:"data,omitzero"`
}

func (s *Diagnostic) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range   requiredProp `json:"range"`
		Message requiredProp `json:"message"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.Message {
		return fmt.Errorf("required key 'message' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range              Range                            `json:"range"`
		Severity           *DiagnosticSeverity              `json:"severity,omitzero"`
		Code               *IntegerOrString                 `json:"code,omitzero"`
		CodeDescription    *CodeDescription                 `json:"codeDescription,omitzero"`
		Source             *string                          `json:"source,omitzero"`
		Message            string                           `json:"message"`
		Tags               *[]DiagnosticTag                 `json:"tags,omitzero"`
		RelatedInformation *[]*DiagnosticRelatedInformation `json:"relatedInformation,omitzero"`
		Data               *any                             `json:"data,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Contains additional information about the context in which a completion request is triggered.
type CompletionContext struct {
	// How the completion was triggered.
	TriggerKind CompletionTriggerKind `json:"triggerKind"`

	// The trigger character (a single character) that has trigger code complete.
	// Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`
	TriggerCharacter *string `json:"triggerCharacter,omitzero"`
}

func (s *CompletionContext) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TriggerKind requiredProp `json:"triggerKind"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TriggerKind {
		return fmt.Errorf("required key 'triggerKind' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TriggerKind      CompletionTriggerKind `json:"triggerKind"`
		TriggerCharacter *string               `json:"triggerCharacter,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Additional details for a completion item label.
//
// Since: 3.17.0
type CompletionItemLabelDetails struct {
	// An optional string which is rendered less prominently directly after label,
	// without any spacing. Should be used for function signatures and type annotations.
	Detail *string `json:"detail,omitzero"`

	// An optional string which is rendered less prominently after CompletionItem.detail. Should be used
	// for fully qualified names and file paths.
	Description *string `json:"description,omitzero"`
}

// A special text edit to provide an insert and a replace operation.
//
// Since: 3.16.0
type InsertReplaceEdit struct {
	// The string to be inserted.
	NewText string `json:"newText"`

	// The range if the insert is requested
	Insert Range `json:"insert"`

	// The range if the replace is requested.
	Replace Range `json:"replace"`
}

func (s *InsertReplaceEdit) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		NewText requiredProp `json:"newText"`
		Insert  requiredProp `json:"insert"`
		Replace requiredProp `json:"replace"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.NewText {
		return fmt.Errorf("required key 'newText' is missing")
	}
	if !keys.Insert {
		return fmt.Errorf("required key 'insert' is missing")
	}
	if !keys.Replace {
		return fmt.Errorf("required key 'replace' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		NewText string `json:"newText"`
		Insert  Range  `json:"insert"`
		Replace Range  `json:"replace"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// In many cases the items of an actual completion result share the same
// value for properties like `commitCharacters` or the range of a text
// edit. A completion list can therefore define item defaults which will
// be used if a completion item itself doesn't specify the value.
//
// If a completion list specifies a default value and a completion item
// also specifies a corresponding value, the rules for combining these are
// defined by `applyKinds` (if the client supports it), defaulting to
// ApplyKind.Replace.
//
// Servers are only allowed to return default values if the client
// signals support for this via the `completionList.itemDefaults`
// capability.
//
// Since: 3.17.0
type CompletionItemDefaults struct {
	// A default commit character set.
	//
	// Since: 3.17.0
	CommitCharacters *[]string `json:"commitCharacters,omitzero"`

	// A default edit range.
	//
	// Since: 3.17.0
	EditRange *RangeOrEditRangeWithInsertReplace `json:"editRange,omitzero"`

	// A default insert text format.
	//
	// Since: 3.17.0
	InsertTextFormat *InsertTextFormat `json:"insertTextFormat,omitzero"`

	// A default insert text mode.
	//
	// Since: 3.17.0
	InsertTextMode *InsertTextMode `json:"insertTextMode,omitzero"`

	// A default data value.
	//
	// Since: 3.17.0
	Data *any `json:"data,omitzero"`
}

// Specifies how fields from a completion item should be combined with those
// from `completionList.itemDefaults`.
//
// If unspecified, all fields will be treated as ApplyKind.Replace.
//
// If a field's value is ApplyKind.Replace, the value from a completion item (if
// provided and not `null`) will always be used instead of the value from
// `completionItem.itemDefaults`.
//
// If a field's value is ApplyKind.Merge, the values will be merged using the rules
// defined against each field below.
//
// Servers are only allowed to return `applyKind` if the client
// signals support for this via the `completionList.applyKindSupport`
// capability.
//
// Since: 3.18.0
type CompletionItemApplyKinds struct {
	// Specifies whether commitCharacters on a completion will replace or be
	// merged with those in `completionList.itemDefaults.commitCharacters`.
	//
	// If ApplyKind.Replace, the commit characters from the completion item will
	// always be used unless not provided, in which case those from
	// `completionList.itemDefaults.commitCharacters` will be used. An
	// empty list can be used if a completion item does not have any commit
	// characters and also should not use those from
	// `completionList.itemDefaults.commitCharacters`.
	//
	// If ApplyKind.Merge the commitCharacters for the completion will be the
	// union of all values in both `completionList.itemDefaults.commitCharacters`
	// and the completion's own `commitCharacters`.
	//
	// Since: 3.18.0
	CommitCharacters *ApplyKind `json:"commitCharacters,omitzero"`

	// Specifies whether the `data` field on a completion will replace or
	// be merged with data from `completionList.itemDefaults.data`.
	//
	// If ApplyKind.Replace, the data from the completion item will be used if
	// provided (and not `null`), otherwise
	// `completionList.itemDefaults.data` will be used. An empty object can
	// be used if a completion item does not have any data but also should
	// not use the value from `completionList.itemDefaults.data`.
	//
	// If ApplyKind.Merge, a shallow merge will be performed between
	// `completionList.itemDefaults.data` and the completion's own data
	// using the following rules:
	//
	// - If a completion's `data` field is not provided (or `null`), the
	//   entire `data` field from `completionList.itemDefaults.data` will be
	//   used as-is.
	// - If a completion's `data` field is provided, each field will
	//   overwrite the field of the same name in
	//   `completionList.itemDefaults.data` but no merging of nested fields
	//   within that value will occur.
	//
	// Since: 3.18.0
	Data *ApplyKind `json:"data,omitzero"`
}

// Completion options.
type CompletionOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// Most tools trigger completion request automatically without explicitly requesting
	// it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
	// starts to type an identifier. For example if the user types `c` in a JavaScript file
	// code complete will automatically pop up present `console` besides others as a
	// completion item. Characters that make up identifiers don't need to be listed here.
	//
	// If code complete should automatically be trigger on characters not being valid inside
	// an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
	TriggerCharacters *[]string `json:"triggerCharacters,omitzero"`

	// The list of all possible characters that commit a completion. This field can be used
	// if clients don't support individual commit characters per completion item. See
	// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
	//
	// If a server provides both `allCommitCharacters` and commit characters on an individual
	// completion item the ones on the completion item win.
	//
	// Since: 3.2.0
	AllCommitCharacters *[]string `json:"allCommitCharacters,omitzero"`

	// The server provides support to resolve additional
	// information for a completion item.
	ResolveProvider *bool `json:"resolveProvider,omitzero"`

	// The server supports the following `CompletionItem` specific
	// capabilities.
	//
	// Since: 3.17.0
	CompletionItem *ServerCompletionItemOptions `json:"completionItem,omitzero"`
}

// Hover options.
type HoverOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// Additional information about the context in which a signature help request was triggered.
//
// Since: 3.15.0
type SignatureHelpContext struct {
	// Action that caused signature help to be triggered.
	TriggerKind SignatureHelpTriggerKind `json:"triggerKind"`

	// Character that caused signature help to be triggered.
	//
	// This is undefined when `triggerKind !== SignatureHelpTriggerKind.TriggerCharacter`
	TriggerCharacter *string `json:"triggerCharacter,omitzero"`

	// `true` if signature help was already showing when it was triggered.
	//
	// Retriggers occurs when the signature help is already active and can be caused by actions such as
	// typing a trigger character, a cursor move, or document content changes.
	IsRetrigger bool `json:"isRetrigger"`

	// The currently active `SignatureHelp`.
	//
	// The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field updated based on
	// the user navigating through available signatures.
	ActiveSignatureHelp *SignatureHelp `json:"activeSignatureHelp,omitzero"`
}

func (s *SignatureHelpContext) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TriggerKind requiredProp `json:"triggerKind"`
		IsRetrigger requiredProp `json:"isRetrigger"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TriggerKind {
		return fmt.Errorf("required key 'triggerKind' is missing")
	}
	if !keys.IsRetrigger {
		return fmt.Errorf("required key 'isRetrigger' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TriggerKind         SignatureHelpTriggerKind `json:"triggerKind"`
		TriggerCharacter    *string                  `json:"triggerCharacter,omitzero"`
		IsRetrigger         bool                     `json:"isRetrigger"`
		ActiveSignatureHelp *SignatureHelp           `json:"activeSignatureHelp,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents the signature of something callable. A signature
// can have a label, like a function-name, a doc-comment, and
// a set of parameters.
type SignatureInformation struct {
	// The label of this signature. Will be shown in
	// the UI.
	Label string `json:"label"`

	// The human-readable doc-comment of this signature. Will be shown
	// in the UI but can be omitted.
	Documentation *StringOrMarkupContent `json:"documentation,omitzero"`

	// The parameters of this signature.
	Parameters *[]*ParameterInformation `json:"parameters,omitzero"`

	// The index of the active parameter.
	//
	// If `null`, no parameter of the signature is active (for example a named
	// argument that does not match any declared parameters). This is only valid
	// if the client specifies the client capability
	// `textDocument.signatureHelp.noActiveParameterSupport === true`
	//
	// If provided (or `null`), this is used in place of
	// `SignatureHelp.activeParameter`.
	//
	// Since: 3.16.0
	ActiveParameter *UintegerOrNull `json:"activeParameter,omitzero"`
}

func (s *SignatureInformation) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Label requiredProp `json:"label"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Label {
		return fmt.Errorf("required key 'label' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Label           string                   `json:"label"`
		Documentation   *StringOrMarkupContent   `json:"documentation,omitzero"`
		Parameters      *[]*ParameterInformation `json:"parameters,omitzero"`
		ActiveParameter *UintegerOrNull          `json:"activeParameter,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Server Capabilities for a SignatureHelpRequest.
type SignatureHelpOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// List of characters that trigger signature help automatically.
	TriggerCharacters *[]string `json:"triggerCharacters,omitzero"`

	// List of characters that re-trigger signature help.
	//
	// These trigger characters are only active when signature help is already showing. All trigger characters
	// are also counted as re-trigger characters.
	//
	// Since: 3.15.0
	RetriggerCharacters *[]string `json:"retriggerCharacters,omitzero"`
}

// Server Capabilities for a DefinitionRequest.
type DefinitionOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// Value-object that contains additional information when
// requesting references.
type ReferenceContext struct {
	// Include the declaration of the current symbol.
	IncludeDeclaration bool `json:"includeDeclaration"`
}

func (s *ReferenceContext) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		IncludeDeclaration requiredProp `json:"includeDeclaration"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.IncludeDeclaration {
		return fmt.Errorf("required key 'includeDeclaration' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		IncludeDeclaration bool `json:"includeDeclaration"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Reference options.
type ReferenceOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// Provider options for a DocumentHighlightRequest.
type DocumentHighlightOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// A base for all symbol information.
type BaseSymbolInformation struct {
	// The name of this symbol.
	Name string `json:"name"`

	// The kind of this symbol.
	Kind SymbolKind `json:"kind"`

	// Tags for this symbol.
	//
	// Since: 3.16.0
	Tags *[]SymbolTag `json:"tags,omitzero"`

	// The name of the symbol containing this symbol. This information is for
	// user interface purposes (e.g. to render a qualifier in the user interface
	// if necessary). It can't be used to re-infer a hierarchy for the document
	// symbols.
	ContainerName *string `json:"containerName,omitzero"`
}

func (s *BaseSymbolInformation) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Name requiredProp `json:"name"`
		Kind requiredProp `json:"kind"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Name {
		return fmt.Errorf("required key 'name' is missing")
	}
	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Name          string       `json:"name"`
		Kind          SymbolKind   `json:"kind"`
		Tags          *[]SymbolTag `json:"tags,omitzero"`
		ContainerName *string      `json:"containerName,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Provider options for a DocumentSymbolRequest.
type DocumentSymbolOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// A human-readable string that is shown when multiple outlines trees
	// are shown for the same document.
	//
	// Since: 3.16.0
	Label *string `json:"label,omitzero"`
}

// Contains additional diagnostic information about the context in which
// a action is run.
type CodeActionContext struct {
	// An array of diagnostics known on the client side overlapping the range provided to the
	// `textDocument/codeAction` request. They are provided so that the server knows which
	// errors are currently presented to the user for the given range. There is no guarantee
	// that these accurately reflect the error state of the resource. The primary parameter
	// to compute code actions is the provided range.
	Diagnostics []*Diagnostic `json:"diagnostics"`

	// Requested kind of actions to return.
	//
	// Actions not of this kind are filtered out by the client before being shown. So servers
	// can omit computing them.
	Only *[]CodeActionKind `json:"only,omitzero"`

	// The reason why code actions were requested.
	//
	// Since: 3.17.0
	TriggerKind *CodeActionTriggerKind `json:"triggerKind,omitzero"`
}

func (s *CodeActionContext) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Diagnostics requiredProp `json:"diagnostics"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Diagnostics {
		return fmt.Errorf("required key 'diagnostics' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Diagnostics []*Diagnostic          `json:"diagnostics"`
		Only        *[]CodeActionKind      `json:"only,omitzero"`
		TriggerKind *CodeActionTriggerKind `json:"triggerKind,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Captures why the code action is currently disabled.
//
// Since: 3.18.0
type CodeActionDisabled struct {
	// Human readable description of why the code action is currently disabled.
	//
	// This is displayed in the code actions UI.
	Reason string `json:"reason"`
}

func (s *CodeActionDisabled) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Reason requiredProp `json:"reason"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Reason {
		return fmt.Errorf("required key 'reason' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Reason string `json:"reason"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Provider options for a CodeActionRequest.
type CodeActionOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// CodeActionKinds that this server may return.
	//
	// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
	// may list out every specific kind they provide.
	CodeActionKinds *[]CodeActionKind `json:"codeActionKinds,omitzero"`

	// Static documentation for a class of code actions.
	//
	// Documentation from the provider should be shown in the code actions menu if either:
	//
	// - Code actions of `kind` are requested by the editor. In this case, the editor will show the documentation that
	//   most closely matches the requested code action kind. For example, if a provider has documentation for
	//   both `Refactor` and `RefactorExtract`, when the user requests code actions for `RefactorExtract`,
	//   the editor will use the documentation for `RefactorExtract` instead of the documentation for `Refactor`.
	//
	// - Any code actions of `kind` are returned by the provider.
	//
	// At most one documentation entry should be shown per provider.
	//
	// Since: 3.18.0
	//
	// Proposed.
	Documentation *[]*CodeActionKindDocumentation `json:"documentation,omitzero"`

	// The server provides support to resolve additional
	// information for a code action.
	//
	// Since: 3.16.0
	ResolveProvider *bool `json:"resolveProvider,omitzero"`
}

// Location with only uri and does not include range.
//
// Since: 3.18.0
type LocationUriOnly struct {
	Uri DocumentUri `json:"uri"`
}

func (s *LocationUriOnly) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri requiredProp `json:"uri"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri DocumentUri `json:"uri"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Server capabilities for a WorkspaceSymbolRequest.
type WorkspaceSymbolOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The server provides support to resolve additional
	// information for a workspace symbol.
	//
	// Since: 3.17.0
	ResolveProvider *bool `json:"resolveProvider,omitzero"`
}

// Code Lens provider options of a CodeLensRequest.
type CodeLensOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// Code lens has a resolve provider as well.
	ResolveProvider *bool `json:"resolveProvider,omitzero"`
}

// Provider options for a DocumentLinkRequest.
type DocumentLinkOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// Document links have a resolve provider as well.
	ResolveProvider *bool `json:"resolveProvider,omitzero"`
}

// Value-object describing what options formatting should use.
type FormattingOptions struct {
	// Size of a tab in spaces.
	TabSize uint32 `json:"tabSize"`

	// Prefer spaces over tabs.
	InsertSpaces bool `json:"insertSpaces"`

	// Trim trailing whitespace on a line.
	//
	// Since: 3.15.0
	TrimTrailingWhitespace *bool `json:"trimTrailingWhitespace,omitzero"`

	// Insert a newline character at the end of the file if one does not exist.
	//
	// Since: 3.15.0
	InsertFinalNewline *bool `json:"insertFinalNewline,omitzero"`

	// Trim all newlines after the final newline at the end of the file.
	//
	// Since: 3.15.0
	TrimFinalNewlines *bool `json:"trimFinalNewlines,omitzero"`
}

func (s *FormattingOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TabSize      requiredProp `json:"tabSize"`
		InsertSpaces requiredProp `json:"insertSpaces"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TabSize {
		return fmt.Errorf("required key 'tabSize' is missing")
	}
	if !keys.InsertSpaces {
		return fmt.Errorf("required key 'insertSpaces' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TabSize                uint32 `json:"tabSize"`
		InsertSpaces           bool   `json:"insertSpaces"`
		TrimTrailingWhitespace *bool  `json:"trimTrailingWhitespace,omitzero"`
		InsertFinalNewline     *bool  `json:"insertFinalNewline,omitzero"`
		TrimFinalNewlines      *bool  `json:"trimFinalNewlines,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Provider options for a DocumentFormattingRequest.
type DocumentFormattingOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`
}

// Provider options for a DocumentRangeFormattingRequest.
type DocumentRangeFormattingOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// Whether the server supports formatting multiple ranges at once.
	//
	// Since: 3.18.0
	//
	// Proposed.
	RangesSupport *bool `json:"rangesSupport,omitzero"`
}

// Provider options for a DocumentOnTypeFormattingRequest.
type DocumentOnTypeFormattingOptions struct {
	// A character on which formatting should be triggered, like `{`.
	FirstTriggerCharacter string `json:"firstTriggerCharacter"`

	// More trigger characters.
	MoreTriggerCharacter *[]string `json:"moreTriggerCharacter,omitzero"`
}

func (s *DocumentOnTypeFormattingOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		FirstTriggerCharacter requiredProp `json:"firstTriggerCharacter"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.FirstTriggerCharacter {
		return fmt.Errorf("required key 'firstTriggerCharacter' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		FirstTriggerCharacter string    `json:"firstTriggerCharacter"`
		MoreTriggerCharacter  *[]string `json:"moreTriggerCharacter,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Provider options for a RenameRequest.
type RenameOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// Renames should be checked and tested before being executed.
	//
	// Since: version 3.12.0
	PrepareProvider *bool `json:"prepareProvider,omitzero"`
}

// Since: 3.18.0
type PrepareRenamePlaceholder struct {
	Range Range `json:"range"`

	Placeholder string `json:"placeholder"`
}

func (s *PrepareRenamePlaceholder) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range       requiredProp `json:"range"`
		Placeholder requiredProp `json:"placeholder"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.Placeholder {
		return fmt.Errorf("required key 'placeholder' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range       Range  `json:"range"`
		Placeholder string `json:"placeholder"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type PrepareRenameDefaultBehavior struct {
	DefaultBehavior bool `json:"defaultBehavior"`
}

func (s *PrepareRenameDefaultBehavior) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		DefaultBehavior requiredProp `json:"defaultBehavior"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.DefaultBehavior {
		return fmt.Errorf("required key 'defaultBehavior' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DefaultBehavior bool `json:"defaultBehavior"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// The server capabilities of a ExecuteCommandRequest.
type ExecuteCommandOptions struct {
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// The commands to be executed on the server
	Commands []string `json:"commands"`
}

func (s *ExecuteCommandOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Commands requiredProp `json:"commands"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Commands {
		return fmt.Errorf("required key 'commands' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		WorkDoneProgress *bool    `json:"workDoneProgress,omitzero"`
		Commands         []string `json:"commands"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Additional data about a workspace edit.
//
// Since: 3.18.0
//
// Proposed.
type WorkspaceEditMetadata struct {
	// Signal to the editor that this edit is a refactoring.
	IsRefactoring *bool `json:"isRefactoring,omitzero"`
}

// Since: 3.16.0
type SemanticTokensLegend struct {
	// The token types a server uses.
	TokenTypes []string `json:"tokenTypes"`

	// The token modifiers a server uses.
	TokenModifiers []string `json:"tokenModifiers"`
}

func (s *SemanticTokensLegend) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		TokenTypes     requiredProp `json:"tokenTypes"`
		TokenModifiers requiredProp `json:"tokenModifiers"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.TokenTypes {
		return fmt.Errorf("required key 'tokenTypes' is missing")
	}
	if !keys.TokenModifiers {
		return fmt.Errorf("required key 'tokenModifiers' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		TokenTypes     []string `json:"tokenTypes"`
		TokenModifiers []string `json:"tokenModifiers"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Semantic tokens options to support deltas for full documents
//
// Since: 3.18.0
type SemanticTokensFullDelta struct {
	// The server supports deltas for full documents.
	Delta *bool `json:"delta,omitzero"`
}

// A text document identifier to optionally denote a specific version of a text document.
type OptionalVersionedTextDocumentIdentifier struct {
	// The text document's uri.
	Uri DocumentUri `json:"uri"`

	// The version number of this document. If a versioned text document identifier
	// is sent from the server to the client and the file is not open in the editor
	// (the server has not received an open notification before) the server can send
	// `null` to indicate that the version is unknown and the content on disk is the
	// truth (as specified with document content ownership).
	Version IntegerOrNull `json:"version"`
}

func (s *OptionalVersionedTextDocumentIdentifier) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Uri     requiredProp `json:"uri"`
		Version requiredProp `json:"version"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.Version {
		return fmt.Errorf("required key 'version' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Uri     DocumentUri   `json:"uri"`
		Version IntegerOrNull `json:"version"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A special text edit with an additional change annotation.
//
// Since: 3.16.0.
type AnnotatedTextEdit struct {
	// The range of the text document to be manipulated. To insert
	// text into a document create a range where start === end.
	Range Range `json:"range"`

	// The string to be inserted. For delete operations use an
	// empty string.
	NewText string `json:"newText"`

	// The actual identifier of the change annotation
	AnnotationId string `json:"annotationId"`
}

func (s *AnnotatedTextEdit) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range        requiredProp `json:"range"`
		NewText      requiredProp `json:"newText"`
		AnnotationId requiredProp `json:"annotationId"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.NewText {
		return fmt.Errorf("required key 'newText' is missing")
	}
	if !keys.AnnotationId {
		return fmt.Errorf("required key 'annotationId' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range        Range  `json:"range"`
		NewText      string `json:"newText"`
		AnnotationId string `json:"annotationId"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// An interactive text edit.
//
// Since: 3.18.0
//
// Proposed.
type SnippetTextEdit struct {
	// The range of the text document to be manipulated.
	Range Range `json:"range"`

	// The snippet to be inserted.
	Snippet *StringValue `json:"snippet"`

	// The actual identifier of the snippet edit.
	AnnotationId *string `json:"annotationId,omitzero"`
}

func (s *SnippetTextEdit) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range   requiredProp `json:"range"`
		Snippet requiredProp `json:"snippet"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.Snippet {
		return fmt.Errorf("required key 'snippet' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range        Range        `json:"range"`
		Snippet      *StringValue `json:"snippet"`
		AnnotationId *string      `json:"annotationId,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A generic resource operation.
type ResourceOperation struct {
	// The resource operation kind.
	Kind string `json:"kind"`

	// An optional annotation identifier describing the operation.
	//
	// Since: 3.16.0
	AnnotationId *string `json:"annotationId,omitzero"`
}

func (s *ResourceOperation) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind requiredProp `json:"kind"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind         string  `json:"kind"`
		AnnotationId *string `json:"annotationId,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Options to create a file.
type CreateFileOptions struct {
	// Overwrite existing file. Overwrite wins over `ignoreIfExists`
	Overwrite *bool `json:"overwrite,omitzero"`

	// Ignore if exists.
	IgnoreIfExists *bool `json:"ignoreIfExists,omitzero"`
}

// Rename file options
type RenameFileOptions struct {
	// Overwrite target if existing. Overwrite wins over `ignoreIfExists`
	Overwrite *bool `json:"overwrite,omitzero"`

	// Ignores if target exists.
	IgnoreIfExists *bool `json:"ignoreIfExists,omitzero"`
}

// Delete file options
type DeleteFileOptions struct {
	// Delete the content recursively if a folder is denoted.
	Recursive *bool `json:"recursive,omitzero"`

	// Ignore the operation if the file doesn't exist.
	IgnoreIfNotExists *bool `json:"ignoreIfNotExists,omitzero"`
}

// A pattern to describe in which file operation requests or notifications
// the server is interested in receiving.
//
// Since: 3.16.0
type FileOperationPattern struct {
	// The glob pattern to match. Glob patterns can have the following syntax:
	// - `*` to match one or more characters in a path segment
	// - `?` to match on one character in a path segment
	// - `**` to match any number of path segments, including none
	// - `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
	// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
	// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
	Glob string `json:"glob"`

	// Whether to match files or folders with this pattern.
	//
	// Matches both if undefined.
	Matches *FileOperationPatternKind `json:"matches,omitzero"`

	// Additional options used during matching.
	Options *FileOperationPatternOptions `json:"options,omitzero"`
}

func (s *FileOperationPattern) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Glob requiredProp `json:"glob"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Glob {
		return fmt.Errorf("required key 'glob' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Glob    string                       `json:"glob"`
		Matches *FileOperationPatternKind    `json:"matches,omitzero"`
		Options *FileOperationPatternOptions `json:"options,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A full document diagnostic report for a workspace diagnostic result.
//
// Since: 3.17.0
type WorkspaceFullDocumentDiagnosticReport struct {
	// A full document diagnostic report.
	Kind StringLiteralFull `json:"kind"`

	// An optional result id. If provided it will
	// be sent on the next diagnostic request for the
	// same document.
	ResultId *string `json:"resultId,omitzero"`

	// The actual items.
	Items []*Diagnostic `json:"items"`

	// The URI for which diagnostic information is reported.
	Uri DocumentUri `json:"uri"`

	// The version number for which the diagnostics are reported.
	// If the document is not marked as open `null` can be provided.
	Version IntegerOrNull `json:"version"`
}

func (s *WorkspaceFullDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind    requiredProp `json:"kind"`
		Items   requiredProp `json:"items"`
		Uri     requiredProp `json:"uri"`
		Version requiredProp `json:"version"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Items {
		return fmt.Errorf("required key 'items' is missing")
	}
	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.Version {
		return fmt.Errorf("required key 'version' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind     StringLiteralFull `json:"kind"`
		ResultId *string           `json:"resultId,omitzero"`
		Items    []*Diagnostic     `json:"items"`
		Uri      DocumentUri       `json:"uri"`
		Version  IntegerOrNull     `json:"version"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// An unchanged document diagnostic report for a workspace diagnostic result.
//
// Since: 3.17.0
type WorkspaceUnchangedDocumentDiagnosticReport struct {
	// A document diagnostic report indicating
	// no changes to the last result. A server can
	// only return `unchanged` if result ids are
	// provided.
	Kind StringLiteralUnchanged `json:"kind"`

	// A result id which will be sent on the next
	// diagnostic request for the same document.
	ResultId string `json:"resultId"`

	// The URI for which diagnostic information is reported.
	Uri DocumentUri `json:"uri"`

	// The version number for which the diagnostics are reported.
	// If the document is not marked as open `null` can be provided.
	Version IntegerOrNull `json:"version"`
}

func (s *WorkspaceUnchangedDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind     requiredProp `json:"kind"`
		ResultId requiredProp `json:"resultId"`
		Uri      requiredProp `json:"uri"`
		Version  requiredProp `json:"version"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.ResultId {
		return fmt.Errorf("required key 'resultId' is missing")
	}
	if !keys.Uri {
		return fmt.Errorf("required key 'uri' is missing")
	}
	if !keys.Version {
		return fmt.Errorf("required key 'version' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind     StringLiteralUnchanged `json:"kind"`
		ResultId string                 `json:"resultId"`
		Uri      DocumentUri            `json:"uri"`
		Version  IntegerOrNull          `json:"version"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A notebook cell.
//
// A cell's document URI must be unique across ALL notebook
// cells and can therefore be used to uniquely identify a
// notebook cell or the cell's text document.
//
// Since: 3.17.0
type NotebookCell struct {
	// The cell's kind
	Kind NotebookCellKind `json:"kind"`

	// The URI of the cell's text document
	// content.
	Document DocumentUri `json:"document"`

	// Additional metadata stored with the cell.
	//
	// Note: should always be an object literal (e.g. LSPObject)
	Metadata *map[string]any `json:"metadata,omitzero"`

	// Additional execution summary information
	// if supported by the client.
	ExecutionSummary *ExecutionSummary `json:"executionSummary,omitzero"`
}

func (s *NotebookCell) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind     requiredProp `json:"kind"`
		Document requiredProp `json:"document"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Document {
		return fmt.Errorf("required key 'document' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind             NotebookCellKind  `json:"kind"`
		Document         DocumentUri       `json:"document"`
		Metadata         *map[string]any   `json:"metadata,omitzero"`
		ExecutionSummary *ExecutionSummary `json:"executionSummary,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type NotebookDocumentFilterWithNotebook struct {
	// The notebook to be synced If a string
	// value is provided it matches against the
	// notebook type. '*' matches every notebook.
	Notebook StringOrNotebookDocumentFilterNotebookTypeOrNotebookDocumentFilterSchemeOrNotebookDocumentFilterPattern `json:"notebook"`

	// The cells of the matching notebook to be synced.
	Cells *[]*NotebookCellLanguage `json:"cells,omitzero"`
}

func (s *NotebookDocumentFilterWithNotebook) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Notebook requiredProp `json:"notebook"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Notebook {
		return fmt.Errorf("required key 'notebook' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Notebook StringOrNotebookDocumentFilterNotebookTypeOrNotebookDocumentFilterSchemeOrNotebookDocumentFilterPattern `json:"notebook"`
		Cells    *[]*NotebookCellLanguage                                                                                `json:"cells,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type NotebookDocumentFilterWithCells struct {
	// The notebook to be synced If a string
	// value is provided it matches against the
	// notebook type. '*' matches every notebook.
	Notebook *StringOrNotebookDocumentFilterNotebookTypeOrNotebookDocumentFilterSchemeOrNotebookDocumentFilterPattern `json:"notebook,omitzero"`

	// The cells of the matching notebook to be synced.
	Cells []*NotebookCellLanguage `json:"cells"`
}

func (s *NotebookDocumentFilterWithCells) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Cells requiredProp `json:"cells"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Cells {
		return fmt.Errorf("required key 'cells' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Notebook *StringOrNotebookDocumentFilterNotebookTypeOrNotebookDocumentFilterSchemeOrNotebookDocumentFilterPattern `json:"notebook,omitzero"`
		Cells    []*NotebookCellLanguage                                                                                  `json:"cells"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Cell changes to a notebook document.
//
// Since: 3.18.0
type NotebookDocumentCellChanges struct {
	// Changes to the cell structure to add or
	// remove cells.
	Structure *NotebookDocumentCellChangeStructure `json:"structure,omitzero"`

	// Changes to notebook cells properties like its
	// kind, execution summary or metadata.
	Data *[]*NotebookCell `json:"data,omitzero"`

	// Changes to the text content of notebook cells.
	TextContent *[]*NotebookDocumentCellContentChanges `json:"textContent,omitzero"`
}

// Describes the currently selected completion item.
//
// Since: 3.18.0
//
// Proposed.
type SelectedCompletionInfo struct {
	// The range that will be replaced if this completion item is accepted.
	Range Range `json:"range"`

	// The text the range will be replaced with if this completion is accepted.
	Text string `json:"text"`
}

func (s *SelectedCompletionInfo) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range requiredProp `json:"range"`
		Text  requiredProp `json:"text"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.Text {
		return fmt.Errorf("required key 'text' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range Range  `json:"range"`
		Text  string `json:"text"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Information about the client
//
// Since: 3.15.0
//
// Since: 3.18.0 ClientInfo type name added.
type ClientInfo struct {
	// The name of the client as defined by the client.
	Name string `json:"name"`

	// The client's version as defined by the client.
	Version *string `json:"version,omitzero"`
}

func (s *ClientInfo) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Name requiredProp `json:"name"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Name {
		return fmt.Errorf("required key 'name' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Name    string  `json:"name"`
		Version *string `json:"version,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Defines the capabilities provided by the client.
type ClientCapabilities struct {
	// Workspace specific client capabilities.
	Workspace *WorkspaceClientCapabilities `json:"workspace,omitzero"`

	// Text document specific client capabilities.
	TextDocument *TextDocumentClientCapabilities `json:"textDocument,omitzero"`

	// Capabilities specific to the notebook document support.
	//
	// Since: 3.17.0
	NotebookDocument *NotebookDocumentClientCapabilities `json:"notebookDocument,omitzero"`

	// Window specific client capabilities.
	Window *WindowClientCapabilities `json:"window,omitzero"`

	// General client capabilities.
	//
	// Since: 3.16.0
	General *GeneralClientCapabilities `json:"general,omitzero"`

	// Experimental client capabilities.
	Experimental *any `json:"experimental,omitzero"`
}

type TextDocumentSyncOptions struct {
	// Open and close notifications are sent to the server. If omitted open close notification should not
	// be sent.
	OpenClose *bool `json:"openClose,omitzero"`

	// Change notifications are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
	// and TextDocumentSyncKind.Incremental. If omitted it defaults to TextDocumentSyncKind.None.
	Change *TextDocumentSyncKind `json:"change,omitzero"`

	// If present will save notifications are sent to the server. If omitted the notification should not be
	// sent.
	WillSave *bool `json:"willSave,omitzero"`

	// If present will save wait until requests are sent to the server. If omitted the request should not be
	// sent.
	WillSaveWaitUntil *bool `json:"willSaveWaitUntil,omitzero"`

	// If present save notifications are sent to the server. If omitted the notification should not be
	// sent.
	Save *BooleanOrSaveOptions `json:"save,omitzero"`
}

// Defines workspace specific capabilities of the server.
//
// Since: 3.18.0
type WorkspaceOptions struct {
	// The server supports workspace folder.
	//
	// Since: 3.6.0
	WorkspaceFolders *WorkspaceFoldersServerCapabilities `json:"workspaceFolders,omitzero"`

	// The server is interested in notifications/requests for operations on files.
	//
	// Since: 3.16.0
	FileOperations *FileOperationOptions `json:"fileOperations,omitzero"`

	// The server supports the `workspace/textDocumentContent` request.
	//
	// Since: 3.18.0
	//
	// Proposed.
	TextDocumentContent *TextDocumentContentOptionsOrRegistrationOptions `json:"textDocumentContent,omitzero"`
}

// Since: 3.18.0
type TextDocumentContentChangePartial struct {
	// The range of the document that changed.
	Range Range `json:"range"`

	// The optional length of the range that got replaced.
	//
	// Deprecated: use range instead.
	RangeLength *uint32 `json:"rangeLength,omitzero"`

	// The new text for the provided range.
	Text string `json:"text"`
}

func (s *TextDocumentContentChangePartial) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Range requiredProp `json:"range"`
		Text  requiredProp `json:"text"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Range {
		return fmt.Errorf("required key 'range' is missing")
	}
	if !keys.Text {
		return fmt.Errorf("required key 'text' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Range       Range   `json:"range"`
		RangeLength *uint32 `json:"rangeLength,omitzero"`
		Text        string  `json:"text"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type TextDocumentContentChangeWholeDocument struct {
	// The new text of the whole document.
	Text string `json:"text"`
}

func (s *TextDocumentContentChangeWholeDocument) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Text requiredProp `json:"text"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Text {
		return fmt.Errorf("required key 'text' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Text string `json:"text"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Structure to capture a description for an error code.
//
// Since: 3.16.0
type CodeDescription struct {
	// An URI to open with more information about the diagnostic error.
	Href URI `json:"href"`
}

func (s *CodeDescription) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Href requiredProp `json:"href"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Href {
		return fmt.Errorf("required key 'href' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Href URI `json:"href"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents a related message and source code location for a diagnostic. This should be
// used to point to code locations that cause or related to a diagnostics, e.g when duplicating
// a symbol in a scope.
type DiagnosticRelatedInformation struct {
	// The location of this related diagnostic information.
	Location Location `json:"location"`

	// The message of this related diagnostic information.
	Message string `json:"message"`
}

func (s *DiagnosticRelatedInformation) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Location requiredProp `json:"location"`
		Message  requiredProp `json:"message"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Location {
		return fmt.Errorf("required key 'location' is missing")
	}
	if !keys.Message {
		return fmt.Errorf("required key 'message' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Location Location `json:"location"`
		Message  string   `json:"message"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Edit range variant that includes ranges for insert and replace operations.
//
// Since: 3.18.0
type EditRangeWithInsertReplace struct {
	Insert Range `json:"insert"`

	Replace Range `json:"replace"`
}

func (s *EditRangeWithInsertReplace) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Insert  requiredProp `json:"insert"`
		Replace requiredProp `json:"replace"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Insert {
		return fmt.Errorf("required key 'insert' is missing")
	}
	if !keys.Replace {
		return fmt.Errorf("required key 'replace' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Insert  Range `json:"insert"`
		Replace Range `json:"replace"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ServerCompletionItemOptions struct {
	// The server has support for completion item label
	// details (see also `CompletionItemLabelDetails`) when
	// receiving a completion item in a resolve call.
	//
	// Since: 3.17.0
	LabelDetailsSupport *bool `json:"labelDetailsSupport,omitzero"`
}

// Since: 3.18.0
//
// Deprecated: use MarkupContent instead.
type MarkedStringWithLanguage struct {
	Language string `json:"language"`

	Value string `json:"value"`
}

func (s *MarkedStringWithLanguage) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Language requiredProp `json:"language"`
		Value    requiredProp `json:"value"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Language {
		return fmt.Errorf("required key 'language' is missing")
	}
	if !keys.Value {
		return fmt.Errorf("required key 'value' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Language string `json:"language"`
		Value    string `json:"value"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Represents a parameter of a callable-signature. A parameter can
// have a label and a doc-comment.
type ParameterInformation struct {
	// The label of this parameter information.
	//
	// Either a string or an inclusive start and exclusive end offsets within its containing
	// signature label. (see SignatureInformation.label). The offsets are based on a UTF-16
	// string representation as `Position` and `Range` does.
	//
	// To avoid ambiguities a server should use the [start, end] offset value instead of using
	// a substring. Whether a client support this is controlled via `labelOffsetSupport` client
	// capability.
	//
	// *Note*: a label of type string should be a substring of its containing signature label.
	// Its intended use case is to highlight the parameter label part in the `SignatureInformation.label`.
	Label StringOrTuple `json:"label"`

	// The human-readable doc-comment of this parameter. Will be shown
	// in the UI but can be omitted.
	Documentation *StringOrMarkupContent `json:"documentation,omitzero"`
}

func (s *ParameterInformation) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Label requiredProp `json:"label"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Label {
		return fmt.Errorf("required key 'label' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Label         StringOrTuple          `json:"label"`
		Documentation *StringOrMarkupContent `json:"documentation,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Documentation for a class of code actions.
//
// Since: 3.18.0
//
// Proposed.
type CodeActionKindDocumentation struct {
	// The kind of the code action being documented.
	//
	// If the kind is generic, such as `CodeActionKind.Refactor`, the documentation will be shown whenever any
	// refactorings are returned. If the kind if more specific, such as `CodeActionKind.RefactorExtract`, the
	// documentation will only be shown when extract refactoring code actions are returned.
	Kind CodeActionKind `json:"kind"`

	// Command that is ued to display the documentation to the user.
	//
	// The title of this documentation code action is taken from Command.title
	Command *Command `json:"command"`
}

func (s *CodeActionKindDocumentation) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Kind    requiredProp `json:"kind"`
		Command requiredProp `json:"command"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Kind {
		return fmt.Errorf("required key 'kind' is missing")
	}
	if !keys.Command {
		return fmt.Errorf("required key 'command' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Kind    CodeActionKind `json:"kind"`
		Command *Command       `json:"command"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A notebook cell text document filter denotes a cell text
// document by different properties.
//
// Since: 3.17.0
type NotebookCellTextDocumentFilter struct {
	// A filter that matches against the notebook
	// containing the notebook cell. If a string
	// value is provided it matches against the
	// notebook type. '*' matches every notebook.
	Notebook StringOrNotebookDocumentFilterNotebookTypeOrNotebookDocumentFilterSchemeOrNotebookDocumentFilterPattern `json:"notebook"`

	// A language id like `python`.
	//
	// Will be matched against the language id of the
	// notebook cell document. '*' matches every language.
	Language *string `json:"language,omitzero"`
}

func (s *NotebookCellTextDocumentFilter) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Notebook requiredProp `json:"notebook"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Notebook {
		return fmt.Errorf("required key 'notebook' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Notebook StringOrNotebookDocumentFilterNotebookTypeOrNotebookDocumentFilterSchemeOrNotebookDocumentFilterPattern `json:"notebook"`
		Language *string                                                                                                 `json:"language,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Matching options for the file operation pattern.
//
// Since: 3.16.0
type FileOperationPatternOptions struct {
	// The pattern should be matched ignoring casing.
	IgnoreCase *bool `json:"ignoreCase,omitzero"`
}

type ExecutionSummary struct {
	// A strict monotonically increasing value
	// indicating the execution order of a cell
	// inside a notebook.
	ExecutionOrder uint32 `json:"executionOrder"`

	// Whether the execution was successful or
	// not if known by the client.
	Success *bool `json:"success,omitzero"`
}

func (s *ExecutionSummary) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		ExecutionOrder requiredProp `json:"executionOrder"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.ExecutionOrder {
		return fmt.Errorf("required key 'executionOrder' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		ExecutionOrder uint32 `json:"executionOrder"`
		Success        *bool  `json:"success,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type NotebookCellLanguage struct {
	Language string `json:"language"`
}

func (s *NotebookCellLanguage) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Language requiredProp `json:"language"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Language {
		return fmt.Errorf("required key 'language' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Language string `json:"language"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Structural changes to cells in a notebook document.
//
// Since: 3.18.0
type NotebookDocumentCellChangeStructure struct {
	// The change to the cell array.
	Array *NotebookCellArrayChange `json:"array"`

	// Additional opened cell text documents.
	DidOpen *[]*TextDocumentItem `json:"didOpen,omitzero"`

	// Additional closed cell text documents.
	DidClose *[]TextDocumentIdentifier `json:"didClose,omitzero"`
}

func (s *NotebookDocumentCellChangeStructure) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Array requiredProp `json:"array"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Array {
		return fmt.Errorf("required key 'array' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Array    *NotebookCellArrayChange  `json:"array"`
		DidOpen  *[]*TextDocumentItem      `json:"didOpen,omitzero"`
		DidClose *[]TextDocumentIdentifier `json:"didClose,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Content changes to a cell in a notebook document.
//
// Since: 3.18.0
type NotebookDocumentCellContentChanges struct {
	Document VersionedTextDocumentIdentifier `json:"document"`

	Changes []TextDocumentContentChangePartialOrWholeDocument `json:"changes"`
}

func (s *NotebookDocumentCellContentChanges) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Document requiredProp `json:"document"`
		Changes  requiredProp `json:"changes"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Document {
		return fmt.Errorf("required key 'document' is missing")
	}
	if !keys.Changes {
		return fmt.Errorf("required key 'changes' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Document VersionedTextDocumentIdentifier                   `json:"document"`
		Changes  []TextDocumentContentChangePartialOrWholeDocument `json:"changes"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Workspace specific client capabilities.
type WorkspaceClientCapabilities struct {
	// The client supports applying batch edits
	// to the workspace by supporting the request
	// 'workspace/applyEdit'
	ApplyEdit *bool `json:"applyEdit,omitzero"`

	// Capabilities specific to `WorkspaceEdit`s.
	WorkspaceEdit *WorkspaceEditClientCapabilities `json:"workspaceEdit,omitzero"`

	// Capabilities specific to the `workspace/didChangeConfiguration` notification.
	DidChangeConfiguration *DidChangeConfigurationClientCapabilities `json:"didChangeConfiguration,omitzero"`

	// Capabilities specific to the `workspace/didChangeWatchedFiles` notification.
	DidChangeWatchedFiles *DidChangeWatchedFilesClientCapabilities `json:"didChangeWatchedFiles,omitzero"`

	// Capabilities specific to the `workspace/symbol` request.
	Symbol *WorkspaceSymbolClientCapabilities `json:"symbol,omitzero"`

	// Capabilities specific to the `workspace/executeCommand` request.
	ExecuteCommand *ExecuteCommandClientCapabilities `json:"executeCommand,omitzero"`

	// The client has support for workspace folders.
	//
	// Since: 3.6.0
	WorkspaceFolders *bool `json:"workspaceFolders,omitzero"`

	// The client supports `workspace/configuration` requests.
	//
	// Since: 3.6.0
	Configuration *bool `json:"configuration,omitzero"`

	// Capabilities specific to the semantic token requests scoped to the
	// workspace.
	//
	// Since: 3.16.0.
	SemanticTokens *SemanticTokensWorkspaceClientCapabilities `json:"semanticTokens,omitzero"`

	// Capabilities specific to the code lens requests scoped to the
	// workspace.
	//
	// Since: 3.16.0.
	CodeLens *CodeLensWorkspaceClientCapabilities `json:"codeLens,omitzero"`

	// The client has support for file notifications/requests for user operations on files.
	//
	// Since 3.16.0
	FileOperations *FileOperationClientCapabilities `json:"fileOperations,omitzero"`

	// Capabilities specific to the inline values requests scoped to the
	// workspace.
	//
	// Since: 3.17.0.
	InlineValue *InlineValueWorkspaceClientCapabilities `json:"inlineValue,omitzero"`

	// Capabilities specific to the inlay hint requests scoped to the
	// workspace.
	//
	// Since: 3.17.0.
	InlayHint *InlayHintWorkspaceClientCapabilities `json:"inlayHint,omitzero"`

	// Capabilities specific to the diagnostic requests scoped to the
	// workspace.
	//
	// Since: 3.17.0.
	Diagnostics *DiagnosticWorkspaceClientCapabilities `json:"diagnostics,omitzero"`

	// Capabilities specific to the folding range requests scoped to the workspace.
	//
	// Since: 3.18.0
	//
	// Proposed.
	FoldingRange *FoldingRangeWorkspaceClientCapabilities `json:"foldingRange,omitzero"`

	// Capabilities specific to the `workspace/textDocumentContent` request.
	//
	// Since: 3.18.0
	//
	// Proposed.
	TextDocumentContent *TextDocumentContentClientCapabilities `json:"textDocumentContent,omitzero"`
}

// Text document specific client capabilities.
type TextDocumentClientCapabilities struct {
	// Defines which synchronization capabilities the client supports.
	Synchronization *TextDocumentSyncClientCapabilities `json:"synchronization,omitzero"`

	// Defines which filters the client supports.
	//
	// Since: 3.18.0
	Filters *TextDocumentFilterClientCapabilities `json:"filters,omitzero"`

	// Capabilities specific to the `textDocument/completion` request.
	Completion *CompletionClientCapabilities `json:"completion,omitzero"`

	// Capabilities specific to the `textDocument/hover` request.
	Hover *HoverClientCapabilities `json:"hover,omitzero"`

	// Capabilities specific to the `textDocument/signatureHelp` request.
	SignatureHelp *SignatureHelpClientCapabilities `json:"signatureHelp,omitzero"`

	// Capabilities specific to the `textDocument/declaration` request.
	//
	// Since: 3.14.0
	Declaration *DeclarationClientCapabilities `json:"declaration,omitzero"`

	// Capabilities specific to the `textDocument/definition` request.
	Definition *DefinitionClientCapabilities `json:"definition,omitzero"`

	// Capabilities specific to the `textDocument/typeDefinition` request.
	//
	// Since: 3.6.0
	TypeDefinition *TypeDefinitionClientCapabilities `json:"typeDefinition,omitzero"`

	// Capabilities specific to the `textDocument/implementation` request.
	//
	// Since: 3.6.0
	Implementation *ImplementationClientCapabilities `json:"implementation,omitzero"`

	// Capabilities specific to the `textDocument/references` request.
	References *ReferenceClientCapabilities `json:"references,omitzero"`

	// Capabilities specific to the `textDocument/documentHighlight` request.
	DocumentHighlight *DocumentHighlightClientCapabilities `json:"documentHighlight,omitzero"`

	// Capabilities specific to the `textDocument/documentSymbol` request.
	DocumentSymbol *DocumentSymbolClientCapabilities `json:"documentSymbol,omitzero"`

	// Capabilities specific to the `textDocument/codeAction` request.
	CodeAction *CodeActionClientCapabilities `json:"codeAction,omitzero"`

	// Capabilities specific to the `textDocument/codeLens` request.
	CodeLens *CodeLensClientCapabilities `json:"codeLens,omitzero"`

	// Capabilities specific to the `textDocument/documentLink` request.
	DocumentLink *DocumentLinkClientCapabilities `json:"documentLink,omitzero"`

	// Capabilities specific to the `textDocument/documentColor` and the
	// `textDocument/colorPresentation` request.
	//
	// Since: 3.6.0
	ColorProvider *DocumentColorClientCapabilities `json:"colorProvider,omitzero"`

	// Capabilities specific to the `textDocument/formatting` request.
	Formatting *DocumentFormattingClientCapabilities `json:"formatting,omitzero"`

	// Capabilities specific to the `textDocument/rangeFormatting` request.
	RangeFormatting *DocumentRangeFormattingClientCapabilities `json:"rangeFormatting,omitzero"`

	// Capabilities specific to the `textDocument/onTypeFormatting` request.
	OnTypeFormatting *DocumentOnTypeFormattingClientCapabilities `json:"onTypeFormatting,omitzero"`

	// Capabilities specific to the `textDocument/rename` request.
	Rename *RenameClientCapabilities `json:"rename,omitzero"`

	// Capabilities specific to the `textDocument/foldingRange` request.
	//
	// Since: 3.10.0
	FoldingRange *FoldingRangeClientCapabilities `json:"foldingRange,omitzero"`

	// Capabilities specific to the `textDocument/selectionRange` request.
	//
	// Since: 3.15.0
	SelectionRange *SelectionRangeClientCapabilities `json:"selectionRange,omitzero"`

	// Capabilities specific to the `textDocument/publishDiagnostics` notification.
	PublishDiagnostics *PublishDiagnosticsClientCapabilities `json:"publishDiagnostics,omitzero"`

	// Capabilities specific to the various call hierarchy requests.
	//
	// Since: 3.16.0
	CallHierarchy *CallHierarchyClientCapabilities `json:"callHierarchy,omitzero"`

	// Capabilities specific to the various semantic token request.
	//
	// Since: 3.16.0
	SemanticTokens *SemanticTokensClientCapabilities `json:"semanticTokens,omitzero"`

	// Capabilities specific to the `textDocument/linkedEditingRange` request.
	//
	// Since: 3.16.0
	LinkedEditingRange *LinkedEditingRangeClientCapabilities `json:"linkedEditingRange,omitzero"`

	// Client capabilities specific to the `textDocument/moniker` request.
	//
	// Since: 3.16.0
	Moniker *MonikerClientCapabilities `json:"moniker,omitzero"`

	// Capabilities specific to the various type hierarchy requests.
	//
	// Since: 3.17.0
	TypeHierarchy *TypeHierarchyClientCapabilities `json:"typeHierarchy,omitzero"`

	// Capabilities specific to the `textDocument/inlineValue` request.
	//
	// Since: 3.17.0
	InlineValue *InlineValueClientCapabilities `json:"inlineValue,omitzero"`

	// Capabilities specific to the `textDocument/inlayHint` request.
	//
	// Since: 3.17.0
	InlayHint *InlayHintClientCapabilities `json:"inlayHint,omitzero"`

	// Capabilities specific to the diagnostic pull model.
	//
	// Since: 3.17.0
	Diagnostic *DiagnosticClientCapabilities `json:"diagnostic,omitzero"`

	// Client capabilities specific to inline completions.
	//
	// Since: 3.18.0
	//
	// Proposed.
	InlineCompletion *InlineCompletionClientCapabilities `json:"inlineCompletion,omitzero"`
}

// Capabilities specific to the notebook document support.
//
// Since: 3.17.0
type NotebookDocumentClientCapabilities struct {
	// Capabilities specific to notebook document synchronization
	//
	// Since: 3.17.0
	Synchronization *NotebookDocumentSyncClientCapabilities `json:"synchronization"`
}

func (s *NotebookDocumentClientCapabilities) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Synchronization requiredProp `json:"synchronization"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Synchronization {
		return fmt.Errorf("required key 'synchronization' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Synchronization *NotebookDocumentSyncClientCapabilities `json:"synchronization"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type WindowClientCapabilities struct {
	// It indicates whether the client supports server initiated
	// progress using the `window/workDoneProgress/create` request.
	//
	// The capability also controls Whether client supports handling
	// of progress notifications. If set servers are allowed to report a
	// `workDoneProgress` property in the request specific server
	// capabilities.
	//
	// Since: 3.15.0
	WorkDoneProgress *bool `json:"workDoneProgress,omitzero"`

	// Capabilities specific to the showMessage request.
	//
	// Since: 3.16.0
	ShowMessage *ShowMessageRequestClientCapabilities `json:"showMessage,omitzero"`

	// Capabilities specific to the showDocument request.
	//
	// Since: 3.16.0
	ShowDocument *ShowDocumentClientCapabilities `json:"showDocument,omitzero"`
}

// General client capabilities.
//
// Since: 3.16.0
type GeneralClientCapabilities struct {
	// Client capability that signals how the client
	// handles stale requests (e.g. a request
	// for which the client will not process the response
	// anymore since the information is outdated).
	//
	// Since: 3.17.0
	StaleRequestSupport *StaleRequestSupportOptions `json:"staleRequestSupport,omitzero"`

	// Client capabilities specific to regular expressions.
	//
	// Since: 3.16.0
	RegularExpressions *RegularExpressionsClientCapabilities `json:"regularExpressions,omitzero"`

	// Client capabilities specific to the client's markdown parser.
	//
	// Since: 3.16.0
	Markdown *MarkdownClientCapabilities `json:"markdown,omitzero"`

	// The position encodings supported by the client. Client and server
	// have to agree on the same position encoding to ensure that offsets
	// (e.g. character position in a line) are interpreted the same on both
	// sides.
	//
	// To keep the protocol backwards compatible the following applies: if
	// the value 'utf-16' is missing from the array of position encodings
	// servers can assume that the client supports UTF-16. UTF-16 is
	// therefore a mandatory encoding.
	//
	// If omitted it defaults to ['utf-16'].
	//
	// Implementation considerations: since the conversion from one encoding
	// into another requires the content of the file / line the conversion
	// is best done where the file is read which is usually on the server
	// side.
	//
	// Since: 3.17.0
	PositionEncodings *[]PositionEncodingKind `json:"positionEncodings,omitzero"`
}

type WorkspaceFoldersServerCapabilities struct {
	// The server has support for workspace folders
	Supported *bool `json:"supported,omitzero"`

	// Whether the server wants to receive workspace folder
	// change notifications.
	//
	// If a string is provided the string is treated as an ID
	// under which the notification is registered on the client
	// side. The ID can be used to unregister for these events
	// using the `client/unregisterCapability` request.
	ChangeNotifications *StringOrBoolean `json:"changeNotifications,omitzero"`
}

// Options for notifications/requests for user operations on files.
//
// Since: 3.16.0
type FileOperationOptions struct {
	// The server is interested in receiving didCreateFiles notifications.
	DidCreate *FileOperationRegistrationOptions `json:"didCreate,omitzero"`

	// The server is interested in receiving willCreateFiles requests.
	WillCreate *FileOperationRegistrationOptions `json:"willCreate,omitzero"`

	// The server is interested in receiving didRenameFiles notifications.
	DidRename *FileOperationRegistrationOptions `json:"didRename,omitzero"`

	// The server is interested in receiving willRenameFiles requests.
	WillRename *FileOperationRegistrationOptions `json:"willRename,omitzero"`

	// The server is interested in receiving didDeleteFiles file notifications.
	DidDelete *FileOperationRegistrationOptions `json:"didDelete,omitzero"`

	// The server is interested in receiving willDeleteFiles file requests.
	WillDelete *FileOperationRegistrationOptions `json:"willDelete,omitzero"`
}

// A relative pattern is a helper to construct glob patterns that are matched
// relatively to a base URI. The common value for a `baseUri` is a workspace
// folder root, but it can be another absolute URI as well.
//
// Since: 3.17.0
type RelativePattern struct {
	// A workspace folder or a base URI to which this pattern will be matched
	// against relatively.
	BaseUri WorkspaceFolderOrURI `json:"baseUri"`

	// The actual glob pattern;
	Pattern string `json:"pattern"`
}

func (s *RelativePattern) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		BaseUri requiredProp `json:"baseUri"`
		Pattern requiredProp `json:"pattern"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.BaseUri {
		return fmt.Errorf("required key 'baseUri' is missing")
	}
	if !keys.Pattern {
		return fmt.Errorf("required key 'pattern' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		BaseUri WorkspaceFolderOrURI `json:"baseUri"`
		Pattern string               `json:"pattern"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A document filter where `language` is required field.
//
// Since: 3.18.0
type TextDocumentFilterLanguage struct {
	// A language id, like `typescript`.
	Language string `json:"language"`

	// A Uri scheme, like `file` or `untitled`.
	Scheme *string `json:"scheme,omitzero"`

	// A glob pattern, like **​/*.{ts,js}. See TextDocumentFilter for examples.
	//
	// Since: 3.18.0 - support for relative patterns. Whether clients support
	// relative patterns depends on the client capability
	// `textDocuments.filters.relativePatternSupport`.
	Pattern *PatternOrRelativePattern `json:"pattern,omitzero"`
}

func (s *TextDocumentFilterLanguage) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Language requiredProp `json:"language"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Language {
		return fmt.Errorf("required key 'language' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Language string                    `json:"language"`
		Scheme   *string                   `json:"scheme,omitzero"`
		Pattern  *PatternOrRelativePattern `json:"pattern,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A document filter where `scheme` is required field.
//
// Since: 3.18.0
type TextDocumentFilterScheme struct {
	// A language id, like `typescript`.
	Language *string `json:"language,omitzero"`

	// A Uri scheme, like `file` or `untitled`.
	Scheme string `json:"scheme"`

	// A glob pattern, like **​/*.{ts,js}. See TextDocumentFilter for examples.
	//
	// Since: 3.18.0 - support for relative patterns. Whether clients support
	// relative patterns depends on the client capability
	// `textDocuments.filters.relativePatternSupport`.
	Pattern *PatternOrRelativePattern `json:"pattern,omitzero"`
}

func (s *TextDocumentFilterScheme) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Scheme requiredProp `json:"scheme"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Scheme {
		return fmt.Errorf("required key 'scheme' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Language *string                   `json:"language,omitzero"`
		Scheme   string                    `json:"scheme"`
		Pattern  *PatternOrRelativePattern `json:"pattern,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A document filter where `pattern` is required field.
//
// Since: 3.18.0
type TextDocumentFilterPattern struct {
	// A language id, like `typescript`.
	Language *string `json:"language,omitzero"`

	// A Uri scheme, like `file` or `untitled`.
	Scheme *string `json:"scheme,omitzero"`

	// A glob pattern, like **​/*.{ts,js}. See TextDocumentFilter for examples.
	//
	// Since: 3.18.0 - support for relative patterns. Whether clients support
	// relative patterns depends on the client capability
	// `textDocuments.filters.relativePatternSupport`.
	Pattern PatternOrRelativePattern `json:"pattern"`
}

func (s *TextDocumentFilterPattern) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Pattern requiredProp `json:"pattern"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Pattern {
		return fmt.Errorf("required key 'pattern' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Language *string                  `json:"language,omitzero"`
		Scheme   *string                  `json:"scheme,omitzero"`
		Pattern  PatternOrRelativePattern `json:"pattern"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A notebook document filter where `notebookType` is required field.
//
// Since: 3.18.0
type NotebookDocumentFilterNotebookType struct {
	// The type of the enclosing notebook.
	NotebookType string `json:"notebookType"`

	// A Uri scheme, like `file` or `untitled`.
	Scheme *string `json:"scheme,omitzero"`

	// A glob pattern.
	Pattern *PatternOrRelativePattern `json:"pattern,omitzero"`
}

func (s *NotebookDocumentFilterNotebookType) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		NotebookType requiredProp `json:"notebookType"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.NotebookType {
		return fmt.Errorf("required key 'notebookType' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		NotebookType string                    `json:"notebookType"`
		Scheme       *string                   `json:"scheme,omitzero"`
		Pattern      *PatternOrRelativePattern `json:"pattern,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A notebook document filter where `scheme` is required field.
//
// Since: 3.18.0
type NotebookDocumentFilterScheme struct {
	// The type of the enclosing notebook.
	NotebookType *string `json:"notebookType,omitzero"`

	// A Uri scheme, like `file` or `untitled`.
	Scheme string `json:"scheme"`

	// A glob pattern.
	Pattern *PatternOrRelativePattern `json:"pattern,omitzero"`
}

func (s *NotebookDocumentFilterScheme) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Scheme requiredProp `json:"scheme"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Scheme {
		return fmt.Errorf("required key 'scheme' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		NotebookType *string                   `json:"notebookType,omitzero"`
		Scheme       string                    `json:"scheme"`
		Pattern      *PatternOrRelativePattern `json:"pattern,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A notebook document filter where `pattern` is required field.
//
// Since: 3.18.0
type NotebookDocumentFilterPattern struct {
	// The type of the enclosing notebook.
	NotebookType *string `json:"notebookType,omitzero"`

	// A Uri scheme, like `file` or `untitled`.
	Scheme *string `json:"scheme,omitzero"`

	// A glob pattern.
	Pattern PatternOrRelativePattern `json:"pattern"`
}

func (s *NotebookDocumentFilterPattern) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Pattern requiredProp `json:"pattern"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Pattern {
		return fmt.Errorf("required key 'pattern' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		NotebookType *string                  `json:"notebookType,omitzero"`
		Scheme       *string                  `json:"scheme,omitzero"`
		Pattern      PatternOrRelativePattern `json:"pattern"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// A change describing how to move a `NotebookCell`
// array from state S to S'.
//
// Since: 3.17.0
type NotebookCellArrayChange struct {
	// The start oftest of the cell that changed.
	Start uint32 `json:"start"`

	// The deleted cells
	DeleteCount uint32 `json:"deleteCount"`

	// The new cells, if any
	Cells *[]*NotebookCell `json:"cells,omitzero"`
}

func (s *NotebookCellArrayChange) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Start       requiredProp `json:"start"`
		DeleteCount requiredProp `json:"deleteCount"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Start {
		return fmt.Errorf("required key 'start' is missing")
	}
	if !keys.DeleteCount {
		return fmt.Errorf("required key 'deleteCount' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Start       uint32           `json:"start"`
		DeleteCount uint32           `json:"deleteCount"`
		Cells       *[]*NotebookCell `json:"cells,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

type WorkspaceEditClientCapabilities struct {
	// The client supports versioned document changes in `WorkspaceEdit`s
	DocumentChanges *bool `json:"documentChanges,omitzero"`

	// The resource operations the client supports. Clients should at least
	// support 'create', 'rename' and 'delete' files and folders.
	//
	// Since: 3.13.0
	ResourceOperations *[]ResourceOperationKind `json:"resourceOperations,omitzero"`

	// The failure handling strategy of a client if applying the workspace edit
	// fails.
	//
	// Since: 3.13.0
	FailureHandling *FailureHandlingKind `json:"failureHandling,omitzero"`

	// Whether the client normalizes line endings to the client specific
	// setting.
	// If set to `true` the client will normalize line ending characters
	// in a workspace edit to the client-specified new line
	// character.
	//
	// Since: 3.16.0
	NormalizesLineEndings *bool `json:"normalizesLineEndings,omitzero"`

	// Whether the client in general supports change annotations on text edits,
	// create file, rename file and delete file changes.
	//
	// Since: 3.16.0
	ChangeAnnotationSupport *ChangeAnnotationsSupportOptions `json:"changeAnnotationSupport,omitzero"`

	// Whether the client supports `WorkspaceEditMetadata` in `WorkspaceEdit`s.
	//
	// Since: 3.18.0
	//
	// Proposed.
	MetadataSupport *bool `json:"metadataSupport,omitzero"`

	// Whether the client supports snippets as text edits.
	//
	// Since: 3.18.0
	//
	// Proposed.
	SnippetEditSupport *bool `json:"snippetEditSupport,omitzero"`
}

type DidChangeConfigurationClientCapabilities struct {
	// Did change configuration notification supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

type DidChangeWatchedFilesClientCapabilities struct {
	// Did change watched files notification supports dynamic registration. Please note
	// that the current protocol doesn't support static configuration for file changes
	// from the server side.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// Whether the client has support for pattern
	// or not.
	//
	// Since: 3.17.0
	RelativePatternSupport *bool `json:"relativePatternSupport,omitzero"`
}

// Client capabilities for a WorkspaceSymbolRequest.
type WorkspaceSymbolClientCapabilities struct {
	// Symbol request supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// Specific capabilities for the `SymbolKind` in the `workspace/symbol` request.
	SymbolKind *ClientSymbolKindOptions `json:"symbolKind,omitzero"`

	// The client supports tags on `SymbolInformation`.
	// Clients supporting tags have to handle unknown tags gracefully.
	//
	// Since: 3.16.0
	TagSupport *ClientSymbolTagOptions `json:"tagSupport,omitzero"`

	// The client support partial workspace symbols. The client will send the
	// request `workspaceSymbol/resolve` to the server to resolve additional
	// properties.
	//
	// Since: 3.17.0
	ResolveSupport *ClientSymbolResolveOptions `json:"resolveSupport,omitzero"`
}

// The client capabilities of a ExecuteCommandRequest.
type ExecuteCommandClientCapabilities struct {
	// Execute command supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

// Since: 3.16.0
type SemanticTokensWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from
	// the server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// semantic tokens currently shown. It should be used with absolute care
	// and is useful for situation where a server for example detects a project
	// wide change that requires such a calculation.
	RefreshSupport *bool `json:"refreshSupport,omitzero"`
}

// Since: 3.16.0
type CodeLensWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from the
	// server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// code lenses currently shown. It should be used with absolute care and is
	// useful for situation where a server for example detect a project wide
	// change that requires such a calculation.
	RefreshSupport *bool `json:"refreshSupport,omitzero"`
}

// Capabilities relating to events from file operations by the user in the client.
//
// These events do not come from the file system, they come from user operations
// like renaming a file in the UI.
//
// Since: 3.16.0
type FileOperationClientCapabilities struct {
	// Whether the client supports dynamic registration for file requests/notifications.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// The client has support for sending didCreateFiles notifications.
	DidCreate *bool `json:"didCreate,omitzero"`

	// The client has support for sending willCreateFiles requests.
	WillCreate *bool `json:"willCreate,omitzero"`

	// The client has support for sending didRenameFiles notifications.
	DidRename *bool `json:"didRename,omitzero"`

	// The client has support for sending willRenameFiles requests.
	WillRename *bool `json:"willRename,omitzero"`

	// The client has support for sending didDeleteFiles notifications.
	DidDelete *bool `json:"didDelete,omitzero"`

	// The client has support for sending willDeleteFiles requests.
	WillDelete *bool `json:"willDelete,omitzero"`
}

// Client workspace capabilities specific to inline values.
//
// Since: 3.17.0
type InlineValueWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from the
	// server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// inline values currently shown. It should be used with absolute care and is
	// useful for situation where a server for example detects a project wide
	// change that requires such a calculation.
	RefreshSupport *bool `json:"refreshSupport,omitzero"`
}

// Client workspace capabilities specific to inlay hints.
//
// Since: 3.17.0
type InlayHintWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from
	// the server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// inlay hints currently shown. It should be used with absolute care and
	// is useful for situation where a server for example detects a project wide
	// change that requires such a calculation.
	RefreshSupport *bool `json:"refreshSupport,omitzero"`
}

// Workspace client capabilities specific to diagnostic pull requests.
//
// Since: 3.17.0
type DiagnosticWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from
	// the server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// pulled diagnostics currently shown. It should be used with absolute care and
	// is useful for situation where a server for example detects a project wide
	// change that requires such a calculation.
	RefreshSupport *bool `json:"refreshSupport,omitzero"`
}

// Client workspace capabilities specific to folding ranges
//
// Since: 3.18.0
//
// Proposed.
type FoldingRangeWorkspaceClientCapabilities struct {
	// Whether the client implementation supports a refresh request sent from the
	// server to the client.
	//
	// Note that this event is global and will force the client to refresh all
	// folding ranges currently shown. It should be used with absolute care and is
	// useful for situation where a server for example detects a project wide
	// change that requires such a calculation.
	//
	// Since: 3.18.0
	//
	// Proposed.
	RefreshSupport *bool `json:"refreshSupport,omitzero"`
}

// Client capabilities for a text document content provider.
//
// Since: 3.18.0
//
// Proposed.
type TextDocumentContentClientCapabilities struct {
	// Text document content provider supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

type TextDocumentSyncClientCapabilities struct {
	// Whether text document synchronization supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// The client supports sending will save notifications.
	WillSave *bool `json:"willSave,omitzero"`

	// The client supports sending a will save request and
	// waits for a response providing text edits which will
	// be applied to the document before it is saved.
	WillSaveWaitUntil *bool `json:"willSaveWaitUntil,omitzero"`

	// The client supports did save notifications.
	DidSave *bool `json:"didSave,omitzero"`
}

type TextDocumentFilterClientCapabilities struct {
	// The client supports Relative Patterns.
	//
	// Since: 3.18.0
	RelativePatternSupport *bool `json:"relativePatternSupport,omitzero"`
}

// Completion client capabilities
type CompletionClientCapabilities struct {
	// Whether completion supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// The client supports the following `CompletionItem` specific
	// capabilities.
	CompletionItem *ClientCompletionItemOptions `json:"completionItem,omitzero"`

	CompletionItemKind *ClientCompletionItemOptionsKind `json:"completionItemKind,omitzero"`

	// Defines how the client handles whitespace and indentation
	// when accepting a completion item that uses multi line
	// text in either `insertText` or `textEdit`.
	//
	// Since: 3.17.0
	InsertTextMode *InsertTextMode `json:"insertTextMode,omitzero"`

	// The client supports to send additional context information for a
	// `textDocument/completion` request.
	ContextSupport *bool `json:"contextSupport,omitzero"`

	// The client supports the following `CompletionList` specific
	// capabilities.
	//
	// Since: 3.17.0
	CompletionList *CompletionListCapabilities `json:"completionList,omitzero"`
}

type HoverClientCapabilities struct {
	// Whether hover supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// Client supports the following content formats for the content
	// property. The order describes the preferred format of the client.
	ContentFormat *[]MarkupKind `json:"contentFormat,omitzero"`
}

// Client Capabilities for a SignatureHelpRequest.
type SignatureHelpClientCapabilities struct {
	// Whether signature help supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// The client supports the following `SignatureInformation`
	// specific properties.
	SignatureInformation *ClientSignatureInformationOptions `json:"signatureInformation,omitzero"`

	// The client supports to send additional context information for a
	// `textDocument/signatureHelp` request. A client that opts into
	// contextSupport will also support the `retriggerCharacters` on
	// `SignatureHelpOptions`.
	//
	// Since: 3.15.0
	ContextSupport *bool `json:"contextSupport,omitzero"`
}

// Since: 3.14.0
type DeclarationClientCapabilities struct {
	// Whether declaration supports dynamic registration. If this is set to `true`
	// the client supports the new `DeclarationRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// The client supports additional metadata in the form of declaration links.
	LinkSupport *bool `json:"linkSupport,omitzero"`
}

// Client Capabilities for a DefinitionRequest.
type DefinitionClientCapabilities struct {
	// Whether definition supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// The client supports additional metadata in the form of definition links.
	//
	// Since: 3.14.0
	LinkSupport *bool `json:"linkSupport,omitzero"`
}

// Since 3.6.0
type TypeDefinitionClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `TypeDefinitionRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// The client supports additional metadata in the form of definition links.
	//
	// Since 3.14.0
	LinkSupport *bool `json:"linkSupport,omitzero"`
}

// Since: 3.6.0
type ImplementationClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `ImplementationRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// The client supports additional metadata in the form of definition links.
	//
	// Since: 3.14.0
	LinkSupport *bool `json:"linkSupport,omitzero"`
}

// Client Capabilities for a ReferencesRequest.
type ReferenceClientCapabilities struct {
	// Whether references supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

// Client Capabilities for a DocumentHighlightRequest.
type DocumentHighlightClientCapabilities struct {
	// Whether document highlight supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

// Client Capabilities for a DocumentSymbolRequest.
type DocumentSymbolClientCapabilities struct {
	// Whether document symbol supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// Specific capabilities for the `SymbolKind` in the
	// `textDocument/documentSymbol` request.
	SymbolKind *ClientSymbolKindOptions `json:"symbolKind,omitzero"`

	// The client supports hierarchical document symbols.
	HierarchicalDocumentSymbolSupport *bool `json:"hierarchicalDocumentSymbolSupport,omitzero"`

	// The client supports tags on `SymbolInformation`. Tags are supported on
	// `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
	// Clients supporting tags have to handle unknown tags gracefully.
	//
	// Since: 3.16.0
	TagSupport *ClientSymbolTagOptions `json:"tagSupport,omitzero"`

	// The client supports an additional label presented in the UI when
	// registering a document symbol provider.
	//
	// Since: 3.16.0
	LabelSupport *bool `json:"labelSupport,omitzero"`
}

// The Client Capabilities of a CodeActionRequest.
type CodeActionClientCapabilities struct {
	// Whether code action supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// The client support code action literals of type `CodeAction` as a valid
	// response of the `textDocument/codeAction` request. If the property is not
	// set the request can only return `Command` literals.
	//
	// Since: 3.8.0
	CodeActionLiteralSupport *ClientCodeActionLiteralOptions `json:"codeActionLiteralSupport,omitzero"`

	// Whether code action supports the `isPreferred` property.
	//
	// Since: 3.15.0
	IsPreferredSupport *bool `json:"isPreferredSupport,omitzero"`

	// Whether code action supports the `disabled` property.
	//
	// Since: 3.16.0
	DisabledSupport *bool `json:"disabledSupport,omitzero"`

	// Whether code action supports the `data` property which is
	// preserved between a `textDocument/codeAction` and a
	// `codeAction/resolve` request.
	//
	// Since: 3.16.0
	DataSupport *bool `json:"dataSupport,omitzero"`

	// Whether the client supports resolving additional code action
	// properties via a separate `codeAction/resolve` request.
	//
	// Since: 3.16.0
	ResolveSupport *ClientCodeActionResolveOptions `json:"resolveSupport,omitzero"`

	// Whether the client honors the change annotations in
	// text edits and resource operations returned via the
	// `CodeAction#edit` property by for example presenting
	// the workspace edit in the user interface and asking
	// for confirmation.
	//
	// Since: 3.16.0
	HonorsChangeAnnotations *bool `json:"honorsChangeAnnotations,omitzero"`

	// Whether the client supports documentation for a class of
	// code actions.
	//
	// Since: 3.18.0
	//
	// Proposed.
	DocumentationSupport *bool `json:"documentationSupport,omitzero"`

	// Client supports the tag property on a code action. Clients
	// supporting tags have to handle unknown tags gracefully.
	//
	// Since: 3.18.0 - proposed
	TagSupport *CodeActionTagOptions `json:"tagSupport,omitzero"`
}

// The client capabilities of a CodeLensRequest.
type CodeLensClientCapabilities struct {
	// Whether code lens supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// Whether the client supports resolving additional code lens
	// properties via a separate `codeLens/resolve` request.
	//
	// Since: 3.18.0
	ResolveSupport *ClientCodeLensResolveOptions `json:"resolveSupport,omitzero"`
}

// The client capabilities of a DocumentLinkRequest.
type DocumentLinkClientCapabilities struct {
	// Whether document link supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// Whether the client supports the `tooltip` property on `DocumentLink`.
	//
	// Since: 3.15.0
	TooltipSupport *bool `json:"tooltipSupport,omitzero"`
}

type DocumentColorClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `DocumentColorRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

// Client capabilities of a DocumentFormattingRequest.
type DocumentFormattingClientCapabilities struct {
	// Whether formatting supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

// Client capabilities of a DocumentRangeFormattingRequest.
type DocumentRangeFormattingClientCapabilities struct {
	// Whether range formatting supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// Whether the client supports formatting multiple ranges at once.
	//
	// Since: 3.18.0
	//
	// Proposed.
	RangesSupport *bool `json:"rangesSupport,omitzero"`
}

// Client capabilities of a DocumentOnTypeFormattingRequest.
type DocumentOnTypeFormattingClientCapabilities struct {
	// Whether on type formatting supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

type RenameClientCapabilities struct {
	// Whether rename supports dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// Client supports testing for validity of rename operations
	// before execution.
	//
	// Since: 3.12.0
	PrepareSupport *bool `json:"prepareSupport,omitzero"`

	// Client supports the default behavior result.
	//
	// The value indicates the default behavior used by the
	// client.
	//
	// Since: 3.16.0
	PrepareSupportDefaultBehavior *PrepareSupportDefaultBehavior `json:"prepareSupportDefaultBehavior,omitzero"`

	// Whether the client honors the change annotations in
	// text edits and resource operations returned via the
	// rename request's workspace edit by for example presenting
	// the workspace edit in the user interface and asking
	// for confirmation.
	//
	// Since: 3.16.0
	HonorsChangeAnnotations *bool `json:"honorsChangeAnnotations,omitzero"`
}

type FoldingRangeClientCapabilities struct {
	// Whether implementation supports dynamic registration for folding range
	// providers. If this is set to `true` the client supports the new
	// `FoldingRangeRegistrationOptions` return value for the corresponding
	// server capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// The maximum number of folding ranges that the client prefers to receive
	// per document. The value serves as a hint, servers are free to follow the
	// limit.
	RangeLimit *uint32 `json:"rangeLimit,omitzero"`

	// If set, the client signals that it only supports folding complete lines.
	// If set, client will ignore specified `startCharacter` and `endCharacter`
	// properties in a FoldingRange.
	LineFoldingOnly *bool `json:"lineFoldingOnly,omitzero"`

	// Specific options for the folding range kind.
	//
	// Since: 3.17.0
	FoldingRangeKind *ClientFoldingRangeKindOptions `json:"foldingRangeKind,omitzero"`

	// Specific options for the folding range.
	//
	// Since: 3.17.0
	FoldingRange *ClientFoldingRangeOptions `json:"foldingRange,omitzero"`
}

type SelectionRangeClientCapabilities struct {
	// Whether implementation supports dynamic registration for selection range providers. If this is set to `true`
	// the client supports the new `SelectionRangeRegistrationOptions` return value for the corresponding server
	// capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

// The publish diagnostic client capabilities.
type PublishDiagnosticsClientCapabilities struct {
	// Whether the clients accepts diagnostics with related information.
	RelatedInformation *bool `json:"relatedInformation,omitzero"`

	// Client supports the tag property to provide meta data about a diagnostic.
	// Clients supporting tags have to handle unknown tags gracefully.
	//
	// Since: 3.15.0
	TagSupport *ClientDiagnosticsTagOptions `json:"tagSupport,omitzero"`

	// Client supports a codeDescription property
	//
	// Since: 3.16.0
	CodeDescriptionSupport *bool `json:"codeDescriptionSupport,omitzero"`

	// Whether code action supports the `data` property which is
	// preserved between a `textDocument/publishDiagnostics` and
	// `textDocument/codeAction` request.
	//
	// Since: 3.16.0
	DataSupport *bool `json:"dataSupport,omitzero"`

	// Whether the client interprets the version property of the
	// `textDocument/publishDiagnostics` notification's parameter.
	//
	// Since: 3.15.0
	VersionSupport *bool `json:"versionSupport,omitzero"`
}

// Since: 3.16.0
type CallHierarchyClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

// Since: 3.16.0
type SemanticTokensClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// Which requests the client supports and might send to the server
	// depending on the server's capability. Please note that clients might not
	// show semantic tokens or degrade some of the user experience if a range
	// or full request is advertised by the client but not provided by the
	// server. If for example the client capability `requests.full` and
	// `request.range` are both set to true but the server only provides a
	// range provider the client might not render a minimap correctly or might
	// even decide to not show any semantic tokens at all.
	Requests *ClientSemanticTokensRequestOptions `json:"requests"`

	// The token types that the client supports.
	TokenTypes []string `json:"tokenTypes"`

	// The token modifiers that the client supports.
	TokenModifiers []string `json:"tokenModifiers"`

	// The token formats the clients supports.
	Formats []TokenFormat `json:"formats"`

	// Whether the client supports tokens that can overlap each other.
	OverlappingTokenSupport *bool `json:"overlappingTokenSupport,omitzero"`

	// Whether the client supports tokens that can span multiple lines.
	MultilineTokenSupport *bool `json:"multilineTokenSupport,omitzero"`

	// Whether the client allows the server to actively cancel a
	// semantic token request, e.g. supports returning
	// LSPErrorCodes.ServerCancelled. If a server does the client
	// needs to retrigger the request.
	//
	// Since: 3.17.0
	ServerCancelSupport *bool `json:"serverCancelSupport,omitzero"`

	// Whether the client uses semantic tokens to augment existing
	// syntax tokens. If set to `true` client side created syntax
	// tokens and semantic tokens are both used for colorization. If
	// set to `false` the client only uses the returned semantic tokens
	// for colorization.
	//
	// If the value is `undefined` then the client behavior is not
	// specified.
	//
	// Since: 3.17.0
	AugmentsSyntaxTokens *bool `json:"augmentsSyntaxTokens,omitzero"`
}

func (s *SemanticTokensClientCapabilities) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Requests       requiredProp `json:"requests"`
		TokenTypes     requiredProp `json:"tokenTypes"`
		TokenModifiers requiredProp `json:"tokenModifiers"`
		Formats        requiredProp `json:"formats"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Requests {
		return fmt.Errorf("required key 'requests' is missing")
	}
	if !keys.TokenTypes {
		return fmt.Errorf("required key 'tokenTypes' is missing")
	}
	if !keys.TokenModifiers {
		return fmt.Errorf("required key 'tokenModifiers' is missing")
	}
	if !keys.Formats {
		return fmt.Errorf("required key 'formats' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		DynamicRegistration     *bool                               `json:"dynamicRegistration,omitzero"`
		Requests                *ClientSemanticTokensRequestOptions `json:"requests"`
		TokenTypes              []string                            `json:"tokenTypes"`
		TokenModifiers          []string                            `json:"tokenModifiers"`
		Formats                 []TokenFormat                       `json:"formats"`
		OverlappingTokenSupport *bool                               `json:"overlappingTokenSupport,omitzero"`
		MultilineTokenSupport   *bool                               `json:"multilineTokenSupport,omitzero"`
		ServerCancelSupport     *bool                               `json:"serverCancelSupport,omitzero"`
		AugmentsSyntaxTokens    *bool                               `json:"augmentsSyntaxTokens,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Client capabilities for the linked editing range request.
//
// Since: 3.16.0
type LinkedEditingRangeClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

// Client capabilities specific to the moniker request.
//
// Since: 3.16.0
type MonikerClientCapabilities struct {
	// Whether moniker supports dynamic registration. If this is set to `true`
	// the client supports the new `MonikerRegistrationOptions` return value
	// for the corresponding server capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

// Since: 3.17.0
type TypeHierarchyClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

// Client capabilities specific to inline values.
//
// Since: 3.17.0
type InlineValueClientCapabilities struct {
	// Whether implementation supports dynamic registration for inline value providers.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

// Inlay hint client capabilities.
//
// Since: 3.17.0
type InlayHintClientCapabilities struct {
	// Whether inlay hints support dynamic registration.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// Indicates which properties a client can resolve lazily on an inlay
	// hint.
	ResolveSupport *ClientInlayHintResolveOptions `json:"resolveSupport,omitzero"`
}

// Client capabilities specific to diagnostic pull requests.
//
// Since: 3.17.0
type DiagnosticClientCapabilities struct {
	// Whether the clients accepts diagnostics with related information.
	RelatedInformation *bool `json:"relatedInformation,omitzero"`

	// Client supports the tag property to provide meta data about a diagnostic.
	// Clients supporting tags have to handle unknown tags gracefully.
	//
	// Since: 3.15.0
	TagSupport *ClientDiagnosticsTagOptions `json:"tagSupport,omitzero"`

	// Client supports a codeDescription property
	//
	// Since: 3.16.0
	CodeDescriptionSupport *bool `json:"codeDescriptionSupport,omitzero"`

	// Whether code action supports the `data` property which is
	// preserved between a `textDocument/publishDiagnostics` and
	// `textDocument/codeAction` request.
	//
	// Since: 3.16.0
	DataSupport *bool `json:"dataSupport,omitzero"`

	// Whether implementation supports dynamic registration. If this is set to `true`
	// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// Whether the clients supports related documents for document diagnostic pulls.
	RelatedDocumentSupport *bool `json:"relatedDocumentSupport,omitzero"`
}

// Client capabilities specific to inline completions.
//
// Since: 3.18.0
//
// Proposed.
type InlineCompletionClientCapabilities struct {
	// Whether implementation supports dynamic registration for inline completion providers.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`
}

// Notebook specific client capabilities.
//
// Since: 3.17.0
type NotebookDocumentSyncClientCapabilities struct {
	// Whether implementation supports dynamic registration. If this is
	// set to `true` the client supports the new
	// `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
	// return value for the corresponding server capability as well.
	DynamicRegistration *bool `json:"dynamicRegistration,omitzero"`

	// The client supports sending execution summary data per cell.
	ExecutionSummarySupport *bool `json:"executionSummarySupport,omitzero"`
}

// Show message request client capabilities
type ShowMessageRequestClientCapabilities struct {
	// Capabilities specific to the `MessageActionItem` type.
	MessageActionItem *ClientShowMessageActionItemOptions `json:"messageActionItem,omitzero"`
}

// Client capabilities for the showDocument request.
//
// Since: 3.16.0
type ShowDocumentClientCapabilities struct {
	// The client has support for the showDocument
	// request.
	Support bool `json:"support"`
}

func (s *ShowDocumentClientCapabilities) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Support requiredProp `json:"support"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Support {
		return fmt.Errorf("required key 'support' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Support bool `json:"support"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type StaleRequestSupportOptions struct {
	// The client will actively cancel the request.
	Cancel bool `json:"cancel"`

	// The list of requests for which the client
	// will retry the request if it receives a
	// response with error code `ContentModified`
	RetryOnContentModified []string `json:"retryOnContentModified"`
}

func (s *StaleRequestSupportOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Cancel                 requiredProp `json:"cancel"`
		RetryOnContentModified requiredProp `json:"retryOnContentModified"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Cancel {
		return fmt.Errorf("required key 'cancel' is missing")
	}
	if !keys.RetryOnContentModified {
		return fmt.Errorf("required key 'retryOnContentModified' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Cancel                 bool     `json:"cancel"`
		RetryOnContentModified []string `json:"retryOnContentModified"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Client capabilities specific to regular expressions.
//
// Since: 3.16.0
type RegularExpressionsClientCapabilities struct {
	// The engine's name.
	Engine string `json:"engine"`

	// The engine's version.
	Version *string `json:"version,omitzero"`
}

func (s *RegularExpressionsClientCapabilities) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Engine requiredProp `json:"engine"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Engine {
		return fmt.Errorf("required key 'engine' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Engine  string  `json:"engine"`
		Version *string `json:"version,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Client capabilities specific to the used markdown parser.
//
// Since: 3.16.0
type MarkdownClientCapabilities struct {
	// The name of the parser.
	Parser string `json:"parser"`

	// The version of the parser.
	Version *string `json:"version,omitzero"`

	// A list of HTML tags that the client allows / supports in
	// Markdown.
	//
	// Since: 3.17.0
	AllowedTags *[]string `json:"allowedTags,omitzero"`
}

func (s *MarkdownClientCapabilities) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Parser requiredProp `json:"parser"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Parser {
		return fmt.Errorf("required key 'parser' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Parser      string    `json:"parser"`
		Version     *string   `json:"version,omitzero"`
		AllowedTags *[]string `json:"allowedTags,omitzero"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ChangeAnnotationsSupportOptions struct {
	// Whether the client groups edits with equal labels into tree nodes,
	// for instance all edits labelled with "Changes in Strings" would
	// be a tree node.
	GroupsOnLabel *bool `json:"groupsOnLabel,omitzero"`
}

// Since: 3.18.0
type ClientSymbolKindOptions struct {
	// The symbol kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	//
	// If this property is not present the client only supports
	// the symbol kinds from `File` to `Array` as defined in
	// the initial version of the protocol.
	ValueSet *[]SymbolKind `json:"valueSet,omitzero"`
}

// Since: 3.18.0
type ClientSymbolTagOptions struct {
	// The tags supported by the client.
	ValueSet []SymbolTag `json:"valueSet"`
}

func (s *ClientSymbolTagOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		ValueSet requiredProp `json:"valueSet"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.ValueSet {
		return fmt.Errorf("required key 'valueSet' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		ValueSet []SymbolTag `json:"valueSet"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ClientSymbolResolveOptions struct {
	// The properties that a client can resolve lazily. Usually
	// `location.range`
	Properties []string `json:"properties"`
}

func (s *ClientSymbolResolveOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Properties requiredProp `json:"properties"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Properties {
		return fmt.Errorf("required key 'properties' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Properties []string `json:"properties"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ClientCompletionItemOptions struct {
	// Client supports snippets as insert text.
	//
	// A snippet can define tab stops and placeholders with `$1`, `$2`
	// and `${3:foo}`. `$0` defines the final tab stop, it defaults to
	// the end of the snippet. Placeholders with equal identifiers are linked,
	// that is typing in one will update others too.
	SnippetSupport *bool `json:"snippetSupport,omitzero"`

	// Client supports commit characters on a completion item.
	CommitCharactersSupport *bool `json:"commitCharactersSupport,omitzero"`

	// Client supports the following content formats for the documentation
	// property. The order describes the preferred format of the client.
	DocumentationFormat *[]MarkupKind `json:"documentationFormat,omitzero"`

	// Client supports the deprecated property on a completion item.
	DeprecatedSupport *bool `json:"deprecatedSupport,omitzero"`

	// Client supports the preselect property on a completion item.
	PreselectSupport *bool `json:"preselectSupport,omitzero"`

	// Client supports the tag property on a completion item. Clients supporting
	// tags have to handle unknown tags gracefully. Clients especially need to
	// preserve unknown tags when sending a completion item back to the server in
	// a resolve call.
	//
	// Since: 3.15.0
	TagSupport *CompletionItemTagOptions `json:"tagSupport,omitzero"`

	// Client support insert replace edit to control different behavior if a
	// completion item is inserted in the text or should replace text.
	//
	// Since: 3.16.0
	InsertReplaceSupport *bool `json:"insertReplaceSupport,omitzero"`

	// Indicates which properties a client can resolve lazily on a completion
	// item. Before version 3.16.0 only the predefined properties `documentation`
	// and `details` could be resolved lazily.
	//
	// Since: 3.16.0
	ResolveSupport *ClientCompletionItemResolveOptions `json:"resolveSupport,omitzero"`

	// The client supports the `insertTextMode` property on
	// a completion item to override the whitespace handling mode
	// as defined by the client (see `insertTextMode`).
	//
	// Since: 3.16.0
	InsertTextModeSupport *ClientCompletionItemInsertTextModeOptions `json:"insertTextModeSupport,omitzero"`

	// The client has support for completion item label
	// details (see also `CompletionItemLabelDetails`).
	//
	// Since: 3.17.0
	LabelDetailsSupport *bool `json:"labelDetailsSupport,omitzero"`
}

// Since: 3.18.0
type ClientCompletionItemOptionsKind struct {
	// The completion item kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	//
	// If this property is not present the client only supports
	// the completion items kinds from `Text` to `Reference` as defined in
	// the initial version of the protocol.
	ValueSet *[]CompletionItemKind `json:"valueSet,omitzero"`
}

// The client supports the following `CompletionList` specific
// capabilities.
//
// Since: 3.17.0
type CompletionListCapabilities struct {
	// The client supports the following itemDefaults on
	// a completion list.
	//
	// The value lists the supported property names of the
	// `CompletionList.itemDefaults` object. If omitted
	// no properties are supported.
	//
	// Since: 3.17.0
	ItemDefaults *[]string `json:"itemDefaults,omitzero"`

	// Specifies whether the client supports `CompletionList.applyKind` to
	// indicate how supported values from `completionList.itemDefaults`
	// and `completion` will be combined.
	//
	// If a client supports `applyKind` it must support it for all fields
	// that it supports that are listed in `CompletionList.applyKind`. This
	// means when clients add support for new/future fields in completion
	// items the MUST also support merge for them if those fields are
	// defined in `CompletionList.applyKind`.
	//
	// Since: 3.18.0
	ApplyKindSupport *bool `json:"applyKindSupport,omitzero"`
}

// Since: 3.18.0
type ClientSignatureInformationOptions struct {
	// Client supports the following content formats for the documentation
	// property. The order describes the preferred format of the client.
	DocumentationFormat *[]MarkupKind `json:"documentationFormat,omitzero"`

	// Client capabilities specific to parameter information.
	ParameterInformation *ClientSignatureParameterInformationOptions `json:"parameterInformation,omitzero"`

	// The client supports the `activeParameter` property on `SignatureInformation`
	// literal.
	//
	// Since: 3.16.0
	ActiveParameterSupport *bool `json:"activeParameterSupport,omitzero"`

	// The client supports the `activeParameter` property on
	// `SignatureHelp`/`SignatureInformation` being set to `null` to
	// indicate that no parameter should be active.
	//
	// Since: 3.18.0
	//
	// Proposed.
	NoActiveParameterSupport *bool `json:"noActiveParameterSupport,omitzero"`
}

// Since: 3.18.0
type ClientCodeActionLiteralOptions struct {
	// The code action kind is support with the following value
	// set.
	CodeActionKind *ClientCodeActionKindOptions `json:"codeActionKind"`
}

func (s *ClientCodeActionLiteralOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		CodeActionKind requiredProp `json:"codeActionKind"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.CodeActionKind {
		return fmt.Errorf("required key 'codeActionKind' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		CodeActionKind *ClientCodeActionKindOptions `json:"codeActionKind"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ClientCodeActionResolveOptions struct {
	// The properties that a client can resolve lazily.
	Properties []string `json:"properties"`
}

func (s *ClientCodeActionResolveOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Properties requiredProp `json:"properties"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Properties {
		return fmt.Errorf("required key 'properties' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Properties []string `json:"properties"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0 - proposed
type CodeActionTagOptions struct {
	// The tags supported by the client.
	ValueSet []CodeActionTag `json:"valueSet"`
}

func (s *CodeActionTagOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		ValueSet requiredProp `json:"valueSet"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.ValueSet {
		return fmt.Errorf("required key 'valueSet' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		ValueSet []CodeActionTag `json:"valueSet"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ClientCodeLensResolveOptions struct {
	// The properties that a client can resolve lazily.
	Properties []string `json:"properties"`
}

func (s *ClientCodeLensResolveOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Properties requiredProp `json:"properties"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Properties {
		return fmt.Errorf("required key 'properties' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Properties []string `json:"properties"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ClientFoldingRangeKindOptions struct {
	// The folding range kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	ValueSet *[]FoldingRangeKind `json:"valueSet,omitzero"`
}

// Since: 3.18.0
type ClientFoldingRangeOptions struct {
	// If set, the client signals that it supports setting collapsedText on
	// folding ranges to display custom labels instead of the default text.
	//
	// Since: 3.17.0
	CollapsedText *bool `json:"collapsedText,omitzero"`
}

// General diagnostics capabilities for pull and push model.
type DiagnosticsCapabilities struct {
	// Whether the clients accepts diagnostics with related information.
	RelatedInformation *bool `json:"relatedInformation,omitzero"`

	// Client supports the tag property to provide meta data about a diagnostic.
	// Clients supporting tags have to handle unknown tags gracefully.
	//
	// Since: 3.15.0
	TagSupport *ClientDiagnosticsTagOptions `json:"tagSupport,omitzero"`

	// Client supports a codeDescription property
	//
	// Since: 3.16.0
	CodeDescriptionSupport *bool `json:"codeDescriptionSupport,omitzero"`

	// Whether code action supports the `data` property which is
	// preserved between a `textDocument/publishDiagnostics` and
	// `textDocument/codeAction` request.
	//
	// Since: 3.16.0
	DataSupport *bool `json:"dataSupport,omitzero"`
}

// Since: 3.18.0
type ClientSemanticTokensRequestOptions struct {
	// The client will send the `textDocument/semanticTokens/range` request if
	// the server provides a corresponding handler.
	Range *BooleanOrEmptyObject `json:"range,omitzero"`

	// The client will send the `textDocument/semanticTokens/full` request if
	// the server provides a corresponding handler.
	Full *BooleanOrClientSemanticTokensRequestFullDelta `json:"full,omitzero"`
}

// Since: 3.18.0
type ClientInlayHintResolveOptions struct {
	// The properties that a client can resolve lazily.
	Properties []string `json:"properties"`
}

func (s *ClientInlayHintResolveOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Properties requiredProp `json:"properties"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Properties {
		return fmt.Errorf("required key 'properties' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Properties []string `json:"properties"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ClientShowMessageActionItemOptions struct {
	// Whether the client supports additional attributes which
	// are preserved and send back to the server in the
	// request's response.
	AdditionalPropertiesSupport *bool `json:"additionalPropertiesSupport,omitzero"`
}

// Since: 3.18.0
type CompletionItemTagOptions struct {
	// The tags supported by the client.
	ValueSet []CompletionItemTag `json:"valueSet"`
}

func (s *CompletionItemTagOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		ValueSet requiredProp `json:"valueSet"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.ValueSet {
		return fmt.Errorf("required key 'valueSet' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		ValueSet []CompletionItemTag `json:"valueSet"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ClientCompletionItemResolveOptions struct {
	// The properties that a client can resolve lazily.
	Properties []string `json:"properties"`
}

func (s *ClientCompletionItemResolveOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		Properties requiredProp `json:"properties"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.Properties {
		return fmt.Errorf("required key 'properties' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		Properties []string `json:"properties"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ClientCompletionItemInsertTextModeOptions struct {
	ValueSet []InsertTextMode `json:"valueSet"`
}

func (s *ClientCompletionItemInsertTextModeOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		ValueSet requiredProp `json:"valueSet"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.ValueSet {
		return fmt.Errorf("required key 'valueSet' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		ValueSet []InsertTextMode `json:"valueSet"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ClientSignatureParameterInformationOptions struct {
	// The client supports processing label offsets instead of a
	// simple label string.
	//
	// Since: 3.14.0
	LabelOffsetSupport *bool `json:"labelOffsetSupport,omitzero"`
}

// Since: 3.18.0
type ClientCodeActionKindOptions struct {
	// The code action kind values the client supports. When this
	// property exists the client also guarantees that it will
	// handle values outside its set gracefully and falls back
	// to a default value when unknown.
	ValueSet []CodeActionKind `json:"valueSet"`
}

func (s *ClientCodeActionKindOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		ValueSet requiredProp `json:"valueSet"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.ValueSet {
		return fmt.Errorf("required key 'valueSet' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		ValueSet []CodeActionKind `json:"valueSet"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ClientDiagnosticsTagOptions struct {
	// The tags supported by the client.
	ValueSet []DiagnosticTag `json:"valueSet"`
}

func (s *ClientDiagnosticsTagOptions) UnmarshalJSON(data []byte) error {
	// Check required props
	type requiredProps struct {
		ValueSet requiredProp `json:"valueSet"`
	}

	var keys requiredProps
	if err := json.Unmarshal(data, &keys); err != nil {
		return err
	}

	if !keys.ValueSet {
		return fmt.Errorf("required key 'valueSet' is missing")
	}

	// Redeclare the struct to prevent infinite recursion
	type temp struct {
		ValueSet []DiagnosticTag `json:"valueSet"`
	}

	return json.Unmarshal(data, (*temp)(s))
}

// Since: 3.18.0
type ClientSemanticTokensRequestFullDelta struct {
	// The client will send the `textDocument/semanticTokens/full/delta` request if
	// the server provides a corresponding handler.
	Delta *bool `json:"delta,omitzero"`
}

// Enumerations

// A set of predefined token types. This set is not fixed
// an clients can specify additional token types via the
// corresponding client capabilities.
//
// Since: 3.16.0
type SemanticTokenTypes string

const (
	SemanticTokenTypesnamespace SemanticTokenTypes = "namespace"
	// Represents a generic type. Acts as a fallback for types which can't be mapped to
	// a specific type like class or enum.
	SemanticTokenTypestype          SemanticTokenTypes = "type"
	SemanticTokenTypesclass         SemanticTokenTypes = "class"
	SemanticTokenTypesenum          SemanticTokenTypes = "enum"
	SemanticTokenTypesinterface     SemanticTokenTypes = "interface"
	SemanticTokenTypesstruct        SemanticTokenTypes = "struct"
	SemanticTokenTypestypeParameter SemanticTokenTypes = "typeParameter"
	SemanticTokenTypesparameter     SemanticTokenTypes = "parameter"
	SemanticTokenTypesvariable      SemanticTokenTypes = "variable"
	SemanticTokenTypesproperty      SemanticTokenTypes = "property"
	SemanticTokenTypesenumMember    SemanticTokenTypes = "enumMember"
	SemanticTokenTypesevent         SemanticTokenTypes = "event"
	SemanticTokenTypesfunction      SemanticTokenTypes = "function"
	SemanticTokenTypesmethod        SemanticTokenTypes = "method"
	SemanticTokenTypesmacro         SemanticTokenTypes = "macro"
	SemanticTokenTypeskeyword       SemanticTokenTypes = "keyword"
	SemanticTokenTypesmodifier      SemanticTokenTypes = "modifier"
	SemanticTokenTypescomment       SemanticTokenTypes = "comment"
	SemanticTokenTypesstring        SemanticTokenTypes = "string"
	SemanticTokenTypesnumber        SemanticTokenTypes = "number"
	SemanticTokenTypesregexp        SemanticTokenTypes = "regexp"
	SemanticTokenTypesoperator      SemanticTokenTypes = "operator"
	// Since: 3.17.0
	SemanticTokenTypesdecorator SemanticTokenTypes = "decorator"
	// Since: 3.18.0
	SemanticTokenTypeslabel SemanticTokenTypes = "label"
)

func (e *SemanticTokenTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = SemanticTokenTypes(v)
	return nil
}

// A set of predefined token modifiers. This set is not fixed
// an clients can specify additional token types via the
// corresponding client capabilities.
//
// Since: 3.16.0
type SemanticTokenModifiers string

const (
	SemanticTokenModifiersdeclaration    SemanticTokenModifiers = "declaration"
	SemanticTokenModifiersdefinition     SemanticTokenModifiers = "definition"
	SemanticTokenModifiersreadonly       SemanticTokenModifiers = "readonly"
	SemanticTokenModifiersstatic         SemanticTokenModifiers = "static"
	SemanticTokenModifiersdeprecated     SemanticTokenModifiers = "deprecated"
	SemanticTokenModifiersabstract       SemanticTokenModifiers = "abstract"
	SemanticTokenModifiersasync          SemanticTokenModifiers = "async"
	SemanticTokenModifiersmodification   SemanticTokenModifiers = "modification"
	SemanticTokenModifiersdocumentation  SemanticTokenModifiers = "documentation"
	SemanticTokenModifiersdefaultLibrary SemanticTokenModifiers = "defaultLibrary"
)

func (e *SemanticTokenModifiers) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = SemanticTokenModifiers(v)
	return nil
}

// The document diagnostic report kinds.
//
// Since: 3.17.0
type DocumentDiagnosticReportKind string

const (
	// A diagnostic report with a full
	// set of problems.
	DocumentDiagnosticReportKindFull DocumentDiagnosticReportKind = "full"
	// A report indicating that the last
	// returned report is still accurate.
	DocumentDiagnosticReportKindUnchanged DocumentDiagnosticReportKind = "unchanged"
)

func (e *DocumentDiagnosticReportKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = DocumentDiagnosticReportKind(v)
	return nil
}

// Predefined error codes.
type ErrorCodes int32

const (
	ErrorCodesParseError     ErrorCodes = -32700
	ErrorCodesInvalidRequest ErrorCodes = -32600
	ErrorCodesMethodNotFound ErrorCodes = -32601
	ErrorCodesInvalidParams  ErrorCodes = -32602
	ErrorCodesInternalError  ErrorCodes = -32603
	// Error code indicating that a server received a notification or
	// request before the server has received the `initialize` request.
	ErrorCodesServerNotInitialized ErrorCodes = -32002
	ErrorCodesUnknownErrorCode     ErrorCodes = -32001
)

func (e *ErrorCodes) UnmarshalJSON(data []byte) error {
	var v int32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = ErrorCodes(v)
	return nil
}

type LSPErrorCodes int32

const (
	// A request failed but it was syntactically correct, e.g the
	// method name was known and the parameters were valid. The error
	// message should contain human readable information about why
	// the request failed.
	//
	// Since: 3.17.0
	LSPErrorCodesRequestFailed LSPErrorCodes = -32803
	// The server cancelled the request. This error code should
	// only be used for requests that explicitly support being
	// server cancellable.
	//
	// Since: 3.17.0
	LSPErrorCodesServerCancelled LSPErrorCodes = -32802
	// The server detected that the content of a document got
	// modified outside normal conditions. A server should
	// NOT send this error code if it detects a content change
	// in it unprocessed messages. The result even computed
	// on an older state might still be useful for the client.
	//
	// If a client decides that a result is not of any use anymore
	// the client should cancel the request.
	LSPErrorCodesContentModified LSPErrorCodes = -32801
	// The client has canceled a request and a server has detected
	// the cancel.
	LSPErrorCodesRequestCancelled LSPErrorCodes = -32800
)

func (e *LSPErrorCodes) UnmarshalJSON(data []byte) error {
	var v int32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = LSPErrorCodes(v)
	return nil
}

// A set of predefined range kinds.
type FoldingRangeKind string

const (
	// Folding range for a comment
	FoldingRangeKindComment FoldingRangeKind = "comment"
	// Folding range for an import or include
	FoldingRangeKindImports FoldingRangeKind = "imports"
	// Folding range for a region (e.g. `#region`)
	FoldingRangeKindRegion FoldingRangeKind = "region"
)

func (e *FoldingRangeKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = FoldingRangeKind(v)
	return nil
}

// A symbol kind.
type SymbolKind uint32

const (
	SymbolKindFile          SymbolKind = 1
	SymbolKindModule        SymbolKind = 2
	SymbolKindNamespace     SymbolKind = 3
	SymbolKindPackage       SymbolKind = 4
	SymbolKindClass         SymbolKind = 5
	SymbolKindMethod        SymbolKind = 6
	SymbolKindProperty      SymbolKind = 7
	SymbolKindField         SymbolKind = 8
	SymbolKindConstructor   SymbolKind = 9
	SymbolKindEnum          SymbolKind = 10
	SymbolKindInterface     SymbolKind = 11
	SymbolKindFunction      SymbolKind = 12
	SymbolKindVariable      SymbolKind = 13
	SymbolKindConstant      SymbolKind = 14
	SymbolKindString        SymbolKind = 15
	SymbolKindNumber        SymbolKind = 16
	SymbolKindBoolean       SymbolKind = 17
	SymbolKindArray         SymbolKind = 18
	SymbolKindObject        SymbolKind = 19
	SymbolKindKey           SymbolKind = 20
	SymbolKindNull          SymbolKind = 21
	SymbolKindEnumMember    SymbolKind = 22
	SymbolKindStruct        SymbolKind = 23
	SymbolKindEvent         SymbolKind = 24
	SymbolKindOperator      SymbolKind = 25
	SymbolKindTypeParameter SymbolKind = 26
)

func (e *SymbolKind) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = SymbolKind(v)
	return nil
}

// Symbol tags are extra annotations that tweak the rendering of a symbol.
//
// Since: 3.16
type SymbolTag uint32

const (
	// Render a symbol as obsolete, usually using a strike-out.
	SymbolTagDeprecated SymbolTag = 1
)

func (e *SymbolTag) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = SymbolTag(v)
	return nil
}

// Moniker uniqueness level to define scope of the moniker.
//
// Since: 3.16.0
type UniquenessLevel string

const (
	// The moniker is only unique inside a document
	UniquenessLeveldocument UniquenessLevel = "document"
	// The moniker is unique inside a project for which a dump got created
	UniquenessLevelproject UniquenessLevel = "project"
	// The moniker is unique inside the group to which a project belongs
	UniquenessLevelgroup UniquenessLevel = "group"
	// The moniker is unique inside the moniker scheme.
	UniquenessLevelscheme UniquenessLevel = "scheme"
	// The moniker is globally unique
	UniquenessLevelglobal UniquenessLevel = "global"
)

func (e *UniquenessLevel) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = UniquenessLevel(v)
	return nil
}

// The moniker kind.
//
// Since: 3.16.0
type MonikerKind string

const (
	// The moniker represent a symbol that is imported into a project
	MonikerKindimport MonikerKind = "import"
	// The moniker represents a symbol that is exported from a project
	MonikerKindexport MonikerKind = "export"
	// The moniker represents a symbol that is local to a project (e.g. a local
	// variable of a function, a class not visible outside the project, ...)
	MonikerKindlocal MonikerKind = "local"
)

func (e *MonikerKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = MonikerKind(v)
	return nil
}

// Inlay hint kinds.
//
// Since: 3.17.0
type InlayHintKind uint32

const (
	// An inlay hint that for a type annotation.
	InlayHintKindType InlayHintKind = 1
	// An inlay hint that is for a parameter.
	InlayHintKindParameter InlayHintKind = 2
)

func (e *InlayHintKind) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = InlayHintKind(v)
	return nil
}

// The message type
type MessageType uint32

const (
	// An error message.
	MessageTypeError MessageType = 1
	// A warning message.
	MessageTypeWarning MessageType = 2
	// An information message.
	MessageTypeInfo MessageType = 3
	// A log message.
	MessageTypeLog MessageType = 4
	// A debug message.
	//
	// Since: 3.18.0
	//
	// Proposed.
	MessageTypeDebug MessageType = 5
)

func (e *MessageType) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = MessageType(v)
	return nil
}

// Defines how the host (editor) should sync
// document changes to the language server.
type TextDocumentSyncKind uint32

const (
	// Documents should not be synced at all.
	TextDocumentSyncKindNone TextDocumentSyncKind = 0
	// Documents are synced by always sending the full content
	// of the document.
	TextDocumentSyncKindFull TextDocumentSyncKind = 1
	// Documents are synced by sending the full content on open.
	// After that only incremental updates to the document are
	// send.
	TextDocumentSyncKindIncremental TextDocumentSyncKind = 2
)

func (e *TextDocumentSyncKind) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = TextDocumentSyncKind(v)
	return nil
}

// Represents reasons why a text document is saved.
type TextDocumentSaveReason uint32

const (
	// Manually triggered, e.g. by the user pressing save, by starting debugging,
	// or by an API call.
	TextDocumentSaveReasonManual TextDocumentSaveReason = 1
	// Automatic after a delay.
	TextDocumentSaveReasonAfterDelay TextDocumentSaveReason = 2
	// When the editor lost focus.
	TextDocumentSaveReasonFocusOut TextDocumentSaveReason = 3
)

func (e *TextDocumentSaveReason) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = TextDocumentSaveReason(v)
	return nil
}

// The kind of a completion entry.
type CompletionItemKind uint32

const (
	CompletionItemKindText          CompletionItemKind = 1
	CompletionItemKindMethod        CompletionItemKind = 2
	CompletionItemKindFunction      CompletionItemKind = 3
	CompletionItemKindConstructor   CompletionItemKind = 4
	CompletionItemKindField         CompletionItemKind = 5
	CompletionItemKindVariable      CompletionItemKind = 6
	CompletionItemKindClass         CompletionItemKind = 7
	CompletionItemKindInterface     CompletionItemKind = 8
	CompletionItemKindModule        CompletionItemKind = 9
	CompletionItemKindProperty      CompletionItemKind = 10
	CompletionItemKindUnit          CompletionItemKind = 11
	CompletionItemKindValue         CompletionItemKind = 12
	CompletionItemKindEnum          CompletionItemKind = 13
	CompletionItemKindKeyword       CompletionItemKind = 14
	CompletionItemKindSnippet       CompletionItemKind = 15
	CompletionItemKindColor         CompletionItemKind = 16
	CompletionItemKindFile          CompletionItemKind = 17
	CompletionItemKindReference     CompletionItemKind = 18
	CompletionItemKindFolder        CompletionItemKind = 19
	CompletionItemKindEnumMember    CompletionItemKind = 20
	CompletionItemKindConstant      CompletionItemKind = 21
	CompletionItemKindStruct        CompletionItemKind = 22
	CompletionItemKindEvent         CompletionItemKind = 23
	CompletionItemKindOperator      CompletionItemKind = 24
	CompletionItemKindTypeParameter CompletionItemKind = 25
)

func (e *CompletionItemKind) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = CompletionItemKind(v)
	return nil
}

// Completion item tags are extra annotations that tweak the rendering of a completion
// item.
//
// Since: 3.15.0
type CompletionItemTag uint32

const (
	// Render a completion as obsolete, usually using a strike-out.
	CompletionItemTagDeprecated CompletionItemTag = 1
)

func (e *CompletionItemTag) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = CompletionItemTag(v)
	return nil
}

// Defines whether the insert text in a completion item should be interpreted as
// plain text or a snippet.
type InsertTextFormat uint32

const (
	// The primary text to be inserted is treated as a plain string.
	InsertTextFormatPlainText InsertTextFormat = 1
	// The primary text to be inserted is treated as a snippet.
	//
	// A snippet can define tab stops and placeholders with `$1`, `$2`
	// and `${3:foo}`. `$0` defines the final tab stop, it defaults to
	// the end of the snippet. Placeholders with equal identifiers are linked,
	// that is typing in one will update others too.
	//
	// See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
	InsertTextFormatSnippet InsertTextFormat = 2
)

func (e *InsertTextFormat) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = InsertTextFormat(v)
	return nil
}

// How whitespace and indentation is handled during completion
// item insertion.
//
// Since: 3.16.0
type InsertTextMode uint32

const (
	// The insertion or replace strings is taken as it is. If the
	// value is multi line the lines below the cursor will be
	// inserted using the indentation defined in the string value.
	// The client will not apply any kind of adjustments to the
	// string.
	InsertTextModeasIs InsertTextMode = 1
	// The editor adjusts leading whitespace of new lines so that
	// they match the indentation up to the cursor of the line for
	// which the item is accepted.
	//
	// Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
	// multi line completion item is indented using 2 tabs and all
	// following lines inserted will be indented using 2 tabs as well.
	InsertTextModeadjustIndentation InsertTextMode = 2
)

func (e *InsertTextMode) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = InsertTextMode(v)
	return nil
}

// A document highlight kind.
type DocumentHighlightKind uint32

const (
	// A textual occurrence.
	DocumentHighlightKindText DocumentHighlightKind = 1
	// Read-access of a symbol, like reading a variable.
	DocumentHighlightKindRead DocumentHighlightKind = 2
	// Write-access of a symbol, like writing to a variable.
	DocumentHighlightKindWrite DocumentHighlightKind = 3
)

func (e *DocumentHighlightKind) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = DocumentHighlightKind(v)
	return nil
}

// A set of predefined code action kinds
type CodeActionKind string

const (
	// Empty kind.
	CodeActionKindEmpty CodeActionKind = ""
	// Base kind for quickfix actions: 'quickfix'
	CodeActionKindQuickFix CodeActionKind = "quickfix"
	// Base kind for refactoring actions: 'refactor'
	CodeActionKindRefactor CodeActionKind = "refactor"
	// Base kind for refactoring extraction actions: 'refactor.extract'
	//
	// Example extract actions:
	//
	// - Extract method
	// - Extract function
	// - Extract variable
	// - Extract interface from class
	// - ...
	CodeActionKindRefactorExtract CodeActionKind = "refactor.extract"
	// Base kind for refactoring inline actions: 'refactor.inline'
	//
	// Example inline actions:
	//
	// - Inline function
	// - Inline variable
	// - Inline constant
	// - ...
	CodeActionKindRefactorInline CodeActionKind = "refactor.inline"
	// Base kind for refactoring move actions: `refactor.move`
	//
	// Example move actions:
	//
	// - Move a function to a new file
	// - Move a property between classes
	// - Move method to base class
	// - ...
	//
	// Since: 3.18.0
	//
	// Proposed.
	CodeActionKindRefactorMove CodeActionKind = "refactor.move"
	// Base kind for refactoring rewrite actions: 'refactor.rewrite'
	//
	// Example rewrite actions:
	//
	// - Convert JavaScript function to class
	// - Add or remove parameter
	// - Encapsulate field
	// - Make method static
	// - Move method to base class
	// - ...
	CodeActionKindRefactorRewrite CodeActionKind = "refactor.rewrite"
	// Base kind for source actions: `source`
	//
	// Source code actions apply to the entire file.
	CodeActionKindSource CodeActionKind = "source"
	// Base kind for an organize imports source action: `source.organizeImports`
	CodeActionKindSourceOrganizeImports CodeActionKind = "source.organizeImports"
	// Base kind for auto-fix source actions: `source.fixAll`.
	//
	// Fix all actions automatically fix errors that have a clear fix that do not require user input.
	// They should not suppress errors or perform unsafe fixes such as generating new types or classes.
	//
	// Since: 3.15.0
	CodeActionKindSourceFixAll CodeActionKind = "source.fixAll"
	// Base kind for all code actions applying to the entire notebook's scope. CodeActionKinds using
	// this should always begin with `notebook.`
	//
	// Since: 3.18.0
	CodeActionKindNotebook CodeActionKind = "notebook"
)

func (e *CodeActionKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = CodeActionKind(v)
	return nil
}

// Code action tags are extra annotations that tweak the behavior of a code action.
//
// Since: 3.18.0 - proposed
type CodeActionTag uint32

const (
	// Marks the code action as LLM-generated.
	CodeActionTagLLMGenerated CodeActionTag = 1
)

func (e *CodeActionTag) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = CodeActionTag(v)
	return nil
}

type TraceValue string

const (
	// Turn tracing off.
	TraceValueOff TraceValue = "off"
	// Trace messages only.
	TraceValueMessages TraceValue = "messages"
	// Verbose message tracing.
	TraceValueVerbose TraceValue = "verbose"
)

func (e *TraceValue) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = TraceValue(v)
	return nil
}

// Describes the content type that a client supports in various
// result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
//
// Please note that `MarkupKinds` must not start with a `$`. This kinds
// are reserved for internal usage.
type MarkupKind string

const (
	// Plain text is supported as a content format
	MarkupKindPlainText MarkupKind = "plaintext"
	// Markdown is supported as a content format
	MarkupKindMarkdown MarkupKind = "markdown"
)

func (e *MarkupKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = MarkupKind(v)
	return nil
}

// Predefined Language kinds
//
// Since: 3.18.0
type LanguageKind string

const (
	LanguageKindABAP         LanguageKind = "abap"
	LanguageKindWindowsBat   LanguageKind = "bat"
	LanguageKindBibTeX       LanguageKind = "bibtex"
	LanguageKindClojure      LanguageKind = "clojure"
	LanguageKindCoffeescript LanguageKind = "coffeescript"
	LanguageKindC            LanguageKind = "c"
	LanguageKindCPP          LanguageKind = "cpp"
	LanguageKindCSharp       LanguageKind = "csharp"
	LanguageKindCSS          LanguageKind = "css"
	// Since: 3.18.0
	//
	// Proposed.
	LanguageKindD LanguageKind = "d"
	// Since: 3.18.0
	//
	// Proposed.
	LanguageKindDelphi          LanguageKind = "pascal"
	LanguageKindDiff            LanguageKind = "diff"
	LanguageKindDart            LanguageKind = "dart"
	LanguageKindDockerfile      LanguageKind = "dockerfile"
	LanguageKindElixir          LanguageKind = "elixir"
	LanguageKindErlang          LanguageKind = "erlang"
	LanguageKindFSharp          LanguageKind = "fsharp"
	LanguageKindGitCommit       LanguageKind = "git-commit"
	LanguageKindGitRebase       LanguageKind = "rebase"
	LanguageKindGo              LanguageKind = "go"
	LanguageKindGroovy          LanguageKind = "groovy"
	LanguageKindHandlebars      LanguageKind = "handlebars"
	LanguageKindHaskell         LanguageKind = "haskell"
	LanguageKindHTML            LanguageKind = "html"
	LanguageKindIni             LanguageKind = "ini"
	LanguageKindJava            LanguageKind = "java"
	LanguageKindJavaScript      LanguageKind = "javascript"
	LanguageKindJavaScriptReact LanguageKind = "javascriptreact"
	LanguageKindJSON            LanguageKind = "json"
	LanguageKindLaTeX           LanguageKind = "latex"
	LanguageKindLess            LanguageKind = "less"
	LanguageKindLua             LanguageKind = "lua"
	LanguageKindMakefile        LanguageKind = "makefile"
	LanguageKindMarkdown        LanguageKind = "markdown"
	LanguageKindObjectiveC      LanguageKind = "objective-c"
	LanguageKindObjectiveCPP    LanguageKind = "objective-cpp"
	// Since: 3.18.0
	//
	// Proposed.
	LanguageKindPascal          LanguageKind = "pascal"
	LanguageKindPerl            LanguageKind = "perl"
	LanguageKindPerl6           LanguageKind = "perl6"
	LanguageKindPHP             LanguageKind = "php"
	LanguageKindPowershell      LanguageKind = "powershell"
	LanguageKindPug             LanguageKind = "jade"
	LanguageKindPython          LanguageKind = "python"
	LanguageKindR               LanguageKind = "r"
	LanguageKindRazor           LanguageKind = "razor"
	LanguageKindRuby            LanguageKind = "ruby"
	LanguageKindRust            LanguageKind = "rust"
	LanguageKindSCSS            LanguageKind = "scss"
	LanguageKindSASS            LanguageKind = "sass"
	LanguageKindScala           LanguageKind = "scala"
	LanguageKindShaderLab       LanguageKind = "shaderlab"
	LanguageKindShellScript     LanguageKind = "shellscript"
	LanguageKindSQL             LanguageKind = "sql"
	LanguageKindSwift           LanguageKind = "swift"
	LanguageKindTypeScript      LanguageKind = "typescript"
	LanguageKindTypeScriptReact LanguageKind = "typescriptreact"
	LanguageKindTeX             LanguageKind = "tex"
	LanguageKindVisualBasic     LanguageKind = "vb"
	LanguageKindXML             LanguageKind = "xml"
	LanguageKindXSL             LanguageKind = "xsl"
	LanguageKindYAML            LanguageKind = "yaml"
)

func (e *LanguageKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = LanguageKind(v)
	return nil
}

// Describes how an provider was triggered.
//
// Since: 3.18.0
//
// Proposed.
type InlineCompletionTriggerKind uint32

const (
	// Completion was triggered explicitly by a user gesture.
	InlineCompletionTriggerKindInvoked InlineCompletionTriggerKind = 1
	// Completion was triggered automatically while editing.
	InlineCompletionTriggerKindAutomatic InlineCompletionTriggerKind = 2
)

func (e *InlineCompletionTriggerKind) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = InlineCompletionTriggerKind(v)
	return nil
}

// A set of predefined position encoding kinds.
//
// Since: 3.17.0
type PositionEncodingKind string

const (
	// Character offsets count UTF-8 code units (e.g. bytes).
	PositionEncodingKindUTF8 PositionEncodingKind = "utf-8"
	// Character offsets count UTF-16 code units.
	//
	// This is the default and must always be supported
	// by servers
	PositionEncodingKindUTF16 PositionEncodingKind = "utf-16"
	// Character offsets count UTF-32 code units.
	//
	// Implementation note: these are the same as Unicode codepoints,
	// so this `PositionEncodingKind` may also be used for an
	// encoding-agnostic representation of character offsets.
	PositionEncodingKindUTF32 PositionEncodingKind = "utf-32"
)

func (e *PositionEncodingKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = PositionEncodingKind(v)
	return nil
}

// The file event type
type FileChangeType uint32

const (
	// The file got created.
	FileChangeTypeCreated FileChangeType = 1
	// The file got changed.
	FileChangeTypeChanged FileChangeType = 2
	// The file got deleted.
	FileChangeTypeDeleted FileChangeType = 3
)

func (e *FileChangeType) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = FileChangeType(v)
	return nil
}

type WatchKind uint32

const (
	// Interested in create events.
	WatchKindCreate WatchKind = 1
	// Interested in change events
	WatchKindChange WatchKind = 2
	// Interested in delete events
	WatchKindDelete WatchKind = 4
)

func (e *WatchKind) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = WatchKind(v)
	return nil
}

// The diagnostic's severity.
type DiagnosticSeverity uint32

const (
	// Reports an error.
	DiagnosticSeverityError DiagnosticSeverity = 1
	// Reports a warning.
	DiagnosticSeverityWarning DiagnosticSeverity = 2
	// Reports an information.
	DiagnosticSeverityInformation DiagnosticSeverity = 3
	// Reports a hint.
	DiagnosticSeverityHint DiagnosticSeverity = 4
)

func (e *DiagnosticSeverity) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = DiagnosticSeverity(v)
	return nil
}

// The diagnostic tags.
//
// Since: 3.15.0
type DiagnosticTag uint32

const (
	// Unused or unnecessary code.
	//
	// Clients are allowed to render diagnostics with this tag faded out instead of having
	// an error squiggle.
	DiagnosticTagUnnecessary DiagnosticTag = 1
	// Deprecated or obsolete code.
	//
	// Clients are allowed to rendered diagnostics with this tag strike through.
	DiagnosticTagDeprecated DiagnosticTag = 2
)

func (e *DiagnosticTag) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = DiagnosticTag(v)
	return nil
}

// How a completion was triggered
type CompletionTriggerKind uint32

const (
	// Completion was triggered by typing an identifier (24x7 code
	// complete), manual invocation (e.g Ctrl+Space) or via API.
	CompletionTriggerKindInvoked CompletionTriggerKind = 1
	// Completion was triggered by a trigger character specified by
	// the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
	CompletionTriggerKindTriggerCharacter CompletionTriggerKind = 2
	// Completion was re-triggered as current completion list is incomplete
	CompletionTriggerKindTriggerForIncompleteCompletions CompletionTriggerKind = 3
)

func (e *CompletionTriggerKind) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = CompletionTriggerKind(v)
	return nil
}

// Defines how values from a set of defaults and an individual item will be
// merged.
//
// Since: 3.18.0
type ApplyKind uint32

const (
	// The value from the individual item (if provided and not `null`) will be
	// used instead of the default.
	ApplyKindReplace ApplyKind = 1
	// The value from the item will be merged with the default.
	//
	// The specific rules for mergeing values are defined against each field
	// that supports merging.
	ApplyKindMerge ApplyKind = 2
)

func (e *ApplyKind) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = ApplyKind(v)
	return nil
}

// How a signature help was triggered.
//
// Since: 3.15.0
type SignatureHelpTriggerKind uint32

const (
	// Signature help was invoked manually by the user or by a command.
	SignatureHelpTriggerKindInvoked SignatureHelpTriggerKind = 1
	// Signature help was triggered by a trigger character.
	SignatureHelpTriggerKindTriggerCharacter SignatureHelpTriggerKind = 2
	// Signature help was triggered by the cursor moving or by the document content changing.
	SignatureHelpTriggerKindContentChange SignatureHelpTriggerKind = 3
)

func (e *SignatureHelpTriggerKind) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = SignatureHelpTriggerKind(v)
	return nil
}

// The reason why code actions were requested.
//
// Since: 3.17.0
type CodeActionTriggerKind uint32

const (
	// Code actions were explicitly requested by the user or by an extension.
	CodeActionTriggerKindInvoked CodeActionTriggerKind = 1
	// Code actions were requested automatically.
	//
	// This typically happens when current selection in a file changes, but can
	// also be triggered when file content changes.
	CodeActionTriggerKindAutomatic CodeActionTriggerKind = 2
)

func (e *CodeActionTriggerKind) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = CodeActionTriggerKind(v)
	return nil
}

// A pattern kind describing if a glob pattern matches a file a folder or
// both.
//
// Since: 3.16.0
type FileOperationPatternKind string

const (
	// The pattern matches a file only.
	FileOperationPatternKindfile FileOperationPatternKind = "file"
	// The pattern matches a folder only.
	FileOperationPatternKindfolder FileOperationPatternKind = "folder"
)

func (e *FileOperationPatternKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = FileOperationPatternKind(v)
	return nil
}

// A notebook cell kind.
//
// Since: 3.17.0
type NotebookCellKind uint32

const (
	// A markup-cell is formatted source that is used for display.
	NotebookCellKindMarkup NotebookCellKind = 1
	// A code-cell is source code.
	NotebookCellKindCode NotebookCellKind = 2
)

func (e *NotebookCellKind) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = NotebookCellKind(v)
	return nil
}

type ResourceOperationKind string

const (
	// Supports creating new files and folders.
	ResourceOperationKindCreate ResourceOperationKind = "create"
	// Supports renaming existing files and folders.
	ResourceOperationKindRename ResourceOperationKind = "rename"
	// Supports deleting existing files and folders.
	ResourceOperationKindDelete ResourceOperationKind = "delete"
)

func (e *ResourceOperationKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = ResourceOperationKind(v)
	return nil
}

type FailureHandlingKind string

const (
	// Applying the workspace change is simply aborted if one of the changes provided
	// fails. All operations executed before the failing operation stay executed.
	FailureHandlingKindAbort FailureHandlingKind = "abort"
	// All operations are executed transactional. That means they either all
	// succeed or no changes at all are applied to the workspace.
	FailureHandlingKindTransactional FailureHandlingKind = "transactional"
	// If the workspace edit contains only textual file changes they are executed transactional.
	// If resource changes (create, rename or delete file) are part of the change the failure
	// handling strategy is abort.
	FailureHandlingKindTextOnlyTransactional FailureHandlingKind = "textOnlyTransactional"
	// The client tries to undo the operations already executed. But there is no
	// guarantee that this is succeeding.
	FailureHandlingKindUndo FailureHandlingKind = "undo"
)

func (e *FailureHandlingKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = FailureHandlingKind(v)
	return nil
}

type PrepareSupportDefaultBehavior uint32

const (
	// The client's default behavior is to select the identifier
	// according the to language's syntax rule.
	PrepareSupportDefaultBehaviorIdentifier PrepareSupportDefaultBehavior = 1
)

func (e *PrepareSupportDefaultBehavior) UnmarshalJSON(data []byte) error {
	var v uint32
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = PrepareSupportDefaultBehavior(v)
	return nil
}

type TokenFormat string

const (
	TokenFormatRelative TokenFormat = "relative"
)

func (e *TokenFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	*e = TokenFormat(v)
	return nil
}

func unmarshalParams(method Method, data []byte) (any, error) {
	switch method {
	case MethodTextDocumentImplementation:
		return unmarshalPtrTo[ImplementationParams](data)
	case MethodTextDocumentTypeDefinition:
		return unmarshalPtrTo[TypeDefinitionParams](data)
	case MethodWorkspaceWorkspaceFolders:
		return unmarshalEmpty(data)
	case MethodWorkspaceConfiguration:
		return unmarshalPtrTo[ConfigurationParams](data)
	case MethodTextDocumentDocumentColor:
		return unmarshalPtrTo[DocumentColorParams](data)
	case MethodTextDocumentColorPresentation:
		return unmarshalPtrTo[ColorPresentationParams](data)
	case MethodTextDocumentFoldingRange:
		return unmarshalPtrTo[FoldingRangeParams](data)
	case MethodWorkspaceFoldingRangeRefresh:
		return unmarshalEmpty(data)
	case MethodTextDocumentDeclaration:
		return unmarshalPtrTo[DeclarationParams](data)
	case MethodTextDocumentSelectionRange:
		return unmarshalPtrTo[SelectionRangeParams](data)
	case MethodWindowWorkDoneProgressCreate:
		return unmarshalPtrTo[WorkDoneProgressCreateParams](data)
	case MethodTextDocumentPrepareCallHierarchy:
		return unmarshalPtrTo[CallHierarchyPrepareParams](data)
	case MethodCallHierarchyIncomingCalls:
		return unmarshalPtrTo[CallHierarchyIncomingCallsParams](data)
	case MethodCallHierarchyOutgoingCalls:
		return unmarshalPtrTo[CallHierarchyOutgoingCallsParams](data)
	case MethodTextDocumentSemanticTokensFull:
		return unmarshalPtrTo[SemanticTokensParams](data)
	case MethodTextDocumentSemanticTokensFullDelta:
		return unmarshalPtrTo[SemanticTokensDeltaParams](data)
	case MethodTextDocumentSemanticTokensRange:
		return unmarshalPtrTo[SemanticTokensRangeParams](data)
	case MethodWorkspaceSemanticTokensRefresh:
		return unmarshalEmpty(data)
	case MethodWindowShowDocument:
		return unmarshalPtrTo[ShowDocumentParams](data)
	case MethodTextDocumentLinkedEditingRange:
		return unmarshalPtrTo[LinkedEditingRangeParams](data)
	case MethodWorkspaceWillCreateFiles:
		return unmarshalPtrTo[CreateFilesParams](data)
	case MethodWorkspaceWillRenameFiles:
		return unmarshalPtrTo[RenameFilesParams](data)
	case MethodWorkspaceWillDeleteFiles:
		return unmarshalPtrTo[DeleteFilesParams](data)
	case MethodTextDocumentMoniker:
		return unmarshalPtrTo[MonikerParams](data)
	case MethodTextDocumentPrepareTypeHierarchy:
		return unmarshalPtrTo[TypeHierarchyPrepareParams](data)
	case MethodTypeHierarchySupertypes:
		return unmarshalPtrTo[TypeHierarchySupertypesParams](data)
	case MethodTypeHierarchySubtypes:
		return unmarshalPtrTo[TypeHierarchySubtypesParams](data)
	case MethodTextDocumentInlineValue:
		return unmarshalPtrTo[InlineValueParams](data)
	case MethodWorkspaceInlineValueRefresh:
		return unmarshalEmpty(data)
	case MethodTextDocumentInlayHint:
		return unmarshalPtrTo[InlayHintParams](data)
	case MethodInlayHintResolve:
		return unmarshalPtrTo[InlayHint](data)
	case MethodWorkspaceInlayHintRefresh:
		return unmarshalEmpty(data)
	case MethodTextDocumentDiagnostic:
		return unmarshalPtrTo[DocumentDiagnosticParams](data)
	case MethodWorkspaceDiagnostic:
		return unmarshalPtrTo[WorkspaceDiagnosticParams](data)
	case MethodWorkspaceDiagnosticRefresh:
		return unmarshalEmpty(data)
	case MethodTextDocumentInlineCompletion:
		return unmarshalPtrTo[InlineCompletionParams](data)
	case MethodWorkspaceTextDocumentContent:
		return unmarshalPtrTo[TextDocumentContentParams](data)
	case MethodWorkspaceTextDocumentContentRefresh:
		return unmarshalPtrTo[TextDocumentContentRefreshParams](data)
	case MethodClientRegisterCapability:
		return unmarshalPtrTo[RegistrationParams](data)
	case MethodClientUnregisterCapability:
		return unmarshalPtrTo[UnregistrationParams](data)
	case MethodInitialize:
		return unmarshalPtrTo[InitializeParams](data)
	case MethodShutdown:
		return unmarshalEmpty(data)
	case MethodWindowShowMessageRequest:
		return unmarshalPtrTo[ShowMessageRequestParams](data)
	case MethodTextDocumentWillSaveWaitUntil:
		return unmarshalPtrTo[WillSaveTextDocumentParams](data)
	case MethodTextDocumentCompletion:
		return unmarshalPtrTo[CompletionParams](data)
	case MethodCompletionItemResolve:
		return unmarshalPtrTo[CompletionItem](data)
	case MethodTextDocumentHover:
		return unmarshalPtrTo[HoverParams](data)
	case MethodTextDocumentSignatureHelp:
		return unmarshalPtrTo[SignatureHelpParams](data)
	case MethodTextDocumentDefinition:
		return unmarshalPtrTo[DefinitionParams](data)
	case MethodTextDocumentReferences:
		return unmarshalPtrTo[ReferenceParams](data)
	case MethodTextDocumentDocumentHighlight:
		return unmarshalPtrTo[DocumentHighlightParams](data)
	case MethodTextDocumentDocumentSymbol:
		return unmarshalPtrTo[DocumentSymbolParams](data)
	case MethodTextDocumentCodeAction:
		return unmarshalPtrTo[CodeActionParams](data)
	case MethodCodeActionResolve:
		return unmarshalPtrTo[CodeAction](data)
	case MethodWorkspaceSymbol:
		return unmarshalPtrTo[WorkspaceSymbolParams](data)
	case MethodWorkspaceSymbolResolve:
		return unmarshalPtrTo[WorkspaceSymbol](data)
	case MethodTextDocumentCodeLens:
		return unmarshalPtrTo[CodeLensParams](data)
	case MethodCodeLensResolve:
		return unmarshalPtrTo[CodeLens](data)
	case MethodWorkspaceCodeLensRefresh:
		return unmarshalEmpty(data)
	case MethodTextDocumentDocumentLink:
		return unmarshalPtrTo[DocumentLinkParams](data)
	case MethodDocumentLinkResolve:
		return unmarshalPtrTo[DocumentLink](data)
	case MethodTextDocumentFormatting:
		return unmarshalPtrTo[DocumentFormattingParams](data)
	case MethodTextDocumentRangeFormatting:
		return unmarshalPtrTo[DocumentRangeFormattingParams](data)
	case MethodTextDocumentRangesFormatting:
		return unmarshalPtrTo[DocumentRangesFormattingParams](data)
	case MethodTextDocumentOnTypeFormatting:
		return unmarshalPtrTo[DocumentOnTypeFormattingParams](data)
	case MethodTextDocumentRename:
		return unmarshalPtrTo[RenameParams](data)
	case MethodTextDocumentPrepareRename:
		return unmarshalPtrTo[PrepareRenameParams](data)
	case MethodWorkspaceExecuteCommand:
		return unmarshalPtrTo[ExecuteCommandParams](data)
	case MethodWorkspaceApplyEdit:
		return unmarshalPtrTo[ApplyWorkspaceEditParams](data)
	case MethodWorkspaceDidChangeWorkspaceFolders:
		return unmarshalPtrTo[DidChangeWorkspaceFoldersParams](data)
	case MethodWindowWorkDoneProgressCancel:
		return unmarshalPtrTo[WorkDoneProgressCancelParams](data)
	case MethodWorkspaceDidCreateFiles:
		return unmarshalPtrTo[CreateFilesParams](data)
	case MethodWorkspaceDidRenameFiles:
		return unmarshalPtrTo[RenameFilesParams](data)
	case MethodWorkspaceDidDeleteFiles:
		return unmarshalPtrTo[DeleteFilesParams](data)
	case MethodNotebookDocumentDidOpen:
		return unmarshalPtrTo[DidOpenNotebookDocumentParams](data)
	case MethodNotebookDocumentDidChange:
		return unmarshalPtrTo[DidChangeNotebookDocumentParams](data)
	case MethodNotebookDocumentDidSave:
		return unmarshalPtrTo[DidSaveNotebookDocumentParams](data)
	case MethodNotebookDocumentDidClose:
		return unmarshalPtrTo[DidCloseNotebookDocumentParams](data)
	case MethodInitialized:
		return unmarshalPtrTo[InitializedParams](data)
	case MethodExit:
		return unmarshalEmpty(data)
	case MethodWorkspaceDidChangeConfiguration:
		return unmarshalPtrTo[DidChangeConfigurationParams](data)
	case MethodWindowShowMessage:
		return unmarshalPtrTo[ShowMessageParams](data)
	case MethodWindowLogMessage:
		return unmarshalPtrTo[LogMessageParams](data)
	case MethodTelemetryEvent:
		return unmarshalAny(data)
	case MethodTextDocumentDidOpen:
		return unmarshalPtrTo[DidOpenTextDocumentParams](data)
	case MethodTextDocumentDidChange:
		return unmarshalPtrTo[DidChangeTextDocumentParams](data)
	case MethodTextDocumentDidClose:
		return unmarshalPtrTo[DidCloseTextDocumentParams](data)
	case MethodTextDocumentDidSave:
		return unmarshalPtrTo[DidSaveTextDocumentParams](data)
	case MethodTextDocumentWillSave:
		return unmarshalPtrTo[WillSaveTextDocumentParams](data)
	case MethodWorkspaceDidChangeWatchedFiles:
		return unmarshalPtrTo[DidChangeWatchedFilesParams](data)
	case MethodTextDocumentPublishDiagnostics:
		return unmarshalPtrTo[PublishDiagnosticsParams](data)
	case MethodSetTrace:
		return unmarshalPtrTo[SetTraceParams](data)
	case MethodLogTrace:
		return unmarshalPtrTo[LogTraceParams](data)
	case MethodCancelRequest:
		return unmarshalPtrTo[CancelParams](data)
	case MethodProgress:
		return unmarshalPtrTo[ProgressParams](data)
	default:
		return unmarshalAny(data)
	}
}

// Methods
const (
	// A request to resolve the implementation locations of a symbol at a given text
	// document position. The request's parameter is of type TextDocumentPositionParams
	// the response is of type Definition or a Thenable that resolves to such.
	MethodTextDocumentImplementation Method = "textDocument/implementation"
	// A request to resolve the type definition locations of a symbol at a given text
	// document position. The request's parameter is of type TextDocumentPositionParams
	// the response is of type Definition or a Thenable that resolves to such.
	MethodTextDocumentTypeDefinition Method = "textDocument/typeDefinition"
	// The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
	MethodWorkspaceWorkspaceFolders Method = "workspace/workspaceFolders"
	// The 'workspace/configuration' request is sent from the server to the client to fetch a certain
	// configuration setting.
	//
	// This pull model replaces the old push model were the client signaled configuration change via an
	// event. If the server still needs to react to configuration changes (since the server caches the
	// result of `workspace/configuration` requests) the server should register for an empty configuration
	// change event and empty the cache if such an event is received.
	MethodWorkspaceConfiguration Method = "workspace/configuration"
	// A request to list all color symbols found in a given text document. The request's
	// parameter is of type DocumentColorParams the
	// response is of type ColorInformation[] or a Thenable
	// that resolves to such.
	MethodTextDocumentDocumentColor Method = "textDocument/documentColor"
	// A request to list all presentation for a color. The request's
	// parameter is of type ColorPresentationParams the
	// response is of type ColorInformation[] or a Thenable
	// that resolves to such.
	MethodTextDocumentColorPresentation Method = "textDocument/colorPresentation"
	// A request to provide folding ranges in a document. The request's
	// parameter is of type FoldingRangeParams, the
	// response is of type FoldingRangeList or a Thenable
	// that resolves to such.
	MethodTextDocumentFoldingRange Method = "textDocument/foldingRange"
	// Since: 3.18.0
	//
	// Proposed.
	MethodWorkspaceFoldingRangeRefresh Method = "workspace/foldingRange/refresh"
	// A request to resolve the type definition locations of a symbol at a given text
	// document position. The request's parameter is of type TextDocumentPositionParams
	// the response is of type Declaration or a typed array of DeclarationLink
	// or a Thenable that resolves to such.
	MethodTextDocumentDeclaration Method = "textDocument/declaration"
	// A request to provide selection ranges in a document. The request's
	// parameter is of type SelectionRangeParams, the
	// response is of type SelectionRange[] or a Thenable
	// that resolves to such.
	MethodTextDocumentSelectionRange Method = "textDocument/selectionRange"
	// The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
	// reporting from the server.
	MethodWindowWorkDoneProgressCreate Method = "window/workDoneProgress/create"
	// A request to result a `CallHierarchyItem` in a document at a given position.
	// Can be used as an input to an incoming or outgoing call hierarchy.
	//
	// Since: 3.16.0
	MethodTextDocumentPrepareCallHierarchy Method = "textDocument/prepareCallHierarchy"
	// A request to resolve the incoming calls for a given `CallHierarchyItem`.
	//
	// Since: 3.16.0
	MethodCallHierarchyIncomingCalls Method = "callHierarchy/incomingCalls"
	// A request to resolve the outgoing calls for a given `CallHierarchyItem`.
	//
	// Since: 3.16.0
	MethodCallHierarchyOutgoingCalls Method = "callHierarchy/outgoingCalls"
	// Since: 3.16.0
	MethodTextDocumentSemanticTokensFull Method = "textDocument/semanticTokens/full"
	// Since: 3.16.0
	MethodTextDocumentSemanticTokensFullDelta Method = "textDocument/semanticTokens/full/delta"
	// Since: 3.16.0
	MethodTextDocumentSemanticTokensRange Method = "textDocument/semanticTokens/range"
	// Since: 3.16.0
	MethodWorkspaceSemanticTokensRefresh Method = "workspace/semanticTokens/refresh"
	// A request to show a document. This request might open an
	// external program depending on the value of the URI to open.
	// For example a request to open `https://code.visualstudio.com/`
	// will very likely open the URI in a WEB browser.
	//
	// Since: 3.16.0
	MethodWindowShowDocument Method = "window/showDocument"
	// A request to provide ranges that can be edited together.
	//
	// Since: 3.16.0
	MethodTextDocumentLinkedEditingRange Method = "textDocument/linkedEditingRange"
	// The will create files request is sent from the client to the server before files are actually
	// created as long as the creation is triggered from within the client.
	//
	// The request can return a `WorkspaceEdit` which will be applied to workspace before the
	// files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
	// to be created.
	//
	// Since: 3.16.0
	MethodWorkspaceWillCreateFiles Method = "workspace/willCreateFiles"
	// The will rename files request is sent from the client to the server before files are actually
	// renamed as long as the rename is triggered from within the client.
	//
	// Since: 3.16.0
	MethodWorkspaceWillRenameFiles Method = "workspace/willRenameFiles"
	// The did delete files notification is sent from the client to the server when
	// files were deleted from within the client.
	//
	// Since: 3.16.0
	MethodWorkspaceWillDeleteFiles Method = "workspace/willDeleteFiles"
	// A request to get the moniker of a symbol at a given text document position.
	// The request parameter is of type TextDocumentPositionParams.
	// The response is of type Moniker[] or `null`.
	MethodTextDocumentMoniker Method = "textDocument/moniker"
	// A request to result a `TypeHierarchyItem` in a document at a given position.
	// Can be used as an input to a subtypes or supertypes type hierarchy.
	//
	// Since: 3.17.0
	MethodTextDocumentPrepareTypeHierarchy Method = "textDocument/prepareTypeHierarchy"
	// A request to resolve the supertypes for a given `TypeHierarchyItem`.
	//
	// Since: 3.17.0
	MethodTypeHierarchySupertypes Method = "typeHierarchy/supertypes"
	// A request to resolve the subtypes for a given `TypeHierarchyItem`.
	//
	// Since: 3.17.0
	MethodTypeHierarchySubtypes Method = "typeHierarchy/subtypes"
	// A request to provide inline values in a document. The request's parameter is of
	// type InlineValueParams, the response is of type
	// InlineValue[] or a Thenable that resolves to such.
	//
	// Since: 3.17.0
	MethodTextDocumentInlineValue Method = "textDocument/inlineValue"
	// Since: 3.17.0
	MethodWorkspaceInlineValueRefresh Method = "workspace/inlineValue/refresh"
	// A request to provide inlay hints in a document. The request's parameter is of
	// type InlayHintsParams, the response is of type
	// InlayHint[] or a Thenable that resolves to such.
	//
	// Since: 3.17.0
	MethodTextDocumentInlayHint Method = "textDocument/inlayHint"
	// A request to resolve additional properties for an inlay hint.
	// The request's parameter is of type InlayHint, the response is
	// of type InlayHint or a Thenable that resolves to such.
	//
	// Since: 3.17.0
	MethodInlayHintResolve Method = "inlayHint/resolve"
	// Since: 3.17.0
	MethodWorkspaceInlayHintRefresh Method = "workspace/inlayHint/refresh"
	// The document diagnostic request definition.
	//
	// Since: 3.17.0
	MethodTextDocumentDiagnostic Method = "textDocument/diagnostic"
	// The workspace diagnostic request definition.
	//
	// Since: 3.17.0
	MethodWorkspaceDiagnostic Method = "workspace/diagnostic"
	// The diagnostic refresh request definition.
	//
	// Since: 3.17.0
	MethodWorkspaceDiagnosticRefresh Method = "workspace/diagnostic/refresh"
	// A request to provide inline completions in a document. The request's parameter is of
	// type InlineCompletionParams, the response is of type
	// InlineCompletion[] or a Thenable that resolves to such.
	//
	// Since: 3.18.0
	//
	// Proposed.
	MethodTextDocumentInlineCompletion Method = "textDocument/inlineCompletion"
	// The `workspace/textDocumentContent` request is sent from the client to the
	// server to request the content of a text document.
	//
	// Since: 3.18.0
	//
	// Proposed.
	MethodWorkspaceTextDocumentContent Method = "workspace/textDocumentContent"
	// The `workspace/textDocumentContent` request is sent from the server to the client to refresh
	// the content of a specific text document.
	//
	// Since: 3.18.0
	//
	// Proposed.
	MethodWorkspaceTextDocumentContentRefresh Method = "workspace/textDocumentContent/refresh"
	// The `client/registerCapability` request is sent from the server to the client to register a new capability
	// handler on the client side.
	MethodClientRegisterCapability Method = "client/registerCapability"
	// The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
	// handler on the client side.
	MethodClientUnregisterCapability Method = "client/unregisterCapability"
	// The initialize request is sent from the client to the server.
	// It is sent once as the request after starting up the server.
	// The requests parameter is of type InitializeParams
	// the response if of type InitializeResult of a Thenable that
	// resolves to such.
	MethodInitialize Method = "initialize"
	// A shutdown request is sent from the client to the server.
	// It is sent once when the client decides to shutdown the
	// server. The only notification that is sent after a shutdown request
	// is the exit event.
	MethodShutdown Method = "shutdown"
	// The show message request is sent from the server to the client to show a message
	// and a set of options actions to the user.
	MethodWindowShowMessageRequest Method = "window/showMessageRequest"
	// A document will save request is sent from the client to the server before
	// the document is actually saved. The request can return an array of TextEdits
	// which will be applied to the text document before it is saved. Please note that
	// clients might drop results if computing the text edits took too long or if a
	// server constantly fails on this request. This is done to keep the save fast and
	// reliable.
	MethodTextDocumentWillSaveWaitUntil Method = "textDocument/willSaveWaitUntil"
	// Request to request completion at a given text document position. The request's
	// parameter is of type TextDocumentPosition the response
	// is of type CompletionItem[] or CompletionList
	// or a Thenable that resolves to such.
	//
	// The request can delay the computation of the `detail`
	// and `documentation` properties to the `completionItem/resolve`
	// request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
	// `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
	MethodTextDocumentCompletion Method = "textDocument/completion"
	// Request to resolve additional information for a given completion item.The request's
	// parameter is of type CompletionItem the response
	// is of type CompletionItem or a Thenable that resolves to such.
	MethodCompletionItemResolve Method = "completionItem/resolve"
	// Request to request hover information at a given text document position. The request's
	// parameter is of type TextDocumentPosition the response is of
	// type Hover or a Thenable that resolves to such.
	MethodTextDocumentHover         Method = "textDocument/hover"
	MethodTextDocumentSignatureHelp Method = "textDocument/signatureHelp"
	// A request to resolve the definition location of a symbol at a given text
	// document position. The request's parameter is of type TextDocumentPosition
	// the response is of either type Definition or a typed array of
	// DefinitionLink or a Thenable that resolves to such.
	MethodTextDocumentDefinition Method = "textDocument/definition"
	// A request to resolve project-wide references for the symbol denoted
	// by the given text document position. The request's parameter is of
	// type ReferenceParams the response is of type
	// Location[] or a Thenable that resolves to such.
	MethodTextDocumentReferences Method = "textDocument/references"
	// Request to resolve a DocumentHighlight for a given
	// text document position. The request's parameter is of type TextDocumentPosition
	// the request response is an array of type DocumentHighlight
	// or a Thenable that resolves to such.
	MethodTextDocumentDocumentHighlight Method = "textDocument/documentHighlight"
	// A request to list all symbols found in a given text document. The request's
	// parameter is of type TextDocumentIdentifier the
	// response is of type SymbolInformation[] or a Thenable
	// that resolves to such.
	MethodTextDocumentDocumentSymbol Method = "textDocument/documentSymbol"
	// A request to provide commands for the given text document and range.
	MethodTextDocumentCodeAction Method = "textDocument/codeAction"
	// Request to resolve additional information for a given code action.The request's
	// parameter is of type CodeAction the response
	// is of type CodeAction or a Thenable that resolves to such.
	MethodCodeActionResolve Method = "codeAction/resolve"
	// A request to list project-wide symbols matching the query string given
	// by the WorkspaceSymbolParams. The response is
	// of type SymbolInformation[] or a Thenable that
	// resolves to such.
	//
	// Since: 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
	//  need to advertise support for WorkspaceSymbols via the client capability
	//  `workspace.symbol.resolveSupport`.
	MethodWorkspaceSymbol Method = "workspace/symbol"
	// A request to resolve the range inside the workspace
	// symbol's location.
	//
	// Since: 3.17.0
	MethodWorkspaceSymbolResolve Method = "workspaceSymbol/resolve"
	// A request to provide code lens for the given text document.
	MethodTextDocumentCodeLens Method = "textDocument/codeLens"
	// A request to resolve a command for a given code lens.
	MethodCodeLensResolve Method = "codeLens/resolve"
	// A request to refresh all code actions
	//
	// Since: 3.16.0
	MethodWorkspaceCodeLensRefresh Method = "workspace/codeLens/refresh"
	// A request to provide document links
	MethodTextDocumentDocumentLink Method = "textDocument/documentLink"
	// Request to resolve additional information for a given document link. The request's
	// parameter is of type DocumentLink the response
	// is of type DocumentLink or a Thenable that resolves to such.
	MethodDocumentLinkResolve Method = "documentLink/resolve"
	// A request to format a whole document.
	MethodTextDocumentFormatting Method = "textDocument/formatting"
	// A request to format a range in a document.
	MethodTextDocumentRangeFormatting Method = "textDocument/rangeFormatting"
	// A request to format ranges in a document.
	//
	// Since: 3.18.0
	//
	// Proposed.
	MethodTextDocumentRangesFormatting Method = "textDocument/rangesFormatting"
	// A request to format a document on type.
	MethodTextDocumentOnTypeFormatting Method = "textDocument/onTypeFormatting"
	// A request to rename a symbol.
	MethodTextDocumentRename Method = "textDocument/rename"
	// A request to test and perform the setup necessary for a rename.
	//
	// Since: 3.16 - support for default behavior
	MethodTextDocumentPrepareRename Method = "textDocument/prepareRename"
	// A request send from the client to the server to execute a command. The request might return
	// a workspace edit which the client will apply to the workspace.
	MethodWorkspaceExecuteCommand Method = "workspace/executeCommand"
	// A request sent from the server to the client to modified certain resources.
	MethodWorkspaceApplyEdit Method = "workspace/applyEdit"
	// The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
	// folder configuration changes.
	MethodWorkspaceDidChangeWorkspaceFolders Method = "workspace/didChangeWorkspaceFolders"
	// The `window/workDoneProgress/cancel` notification is sent from the client to the server to cancel a progress
	// initiated on the server side.
	MethodWindowWorkDoneProgressCancel Method = "window/workDoneProgress/cancel"
	// The did create files notification is sent from the client to the server when
	// files were created from within the client.
	//
	// Since: 3.16.0
	MethodWorkspaceDidCreateFiles Method = "workspace/didCreateFiles"
	// The did rename files notification is sent from the client to the server when
	// files were renamed from within the client.
	//
	// Since: 3.16.0
	MethodWorkspaceDidRenameFiles Method = "workspace/didRenameFiles"
	// The will delete files request is sent from the client to the server before files are actually
	// deleted as long as the deletion is triggered from within the client.
	//
	// Since: 3.16.0
	MethodWorkspaceDidDeleteFiles Method = "workspace/didDeleteFiles"
	// A notification sent when a notebook opens.
	//
	// Since: 3.17.0
	MethodNotebookDocumentDidOpen   Method = "notebookDocument/didOpen"
	MethodNotebookDocumentDidChange Method = "notebookDocument/didChange"
	// A notification sent when a notebook document is saved.
	//
	// Since: 3.17.0
	MethodNotebookDocumentDidSave Method = "notebookDocument/didSave"
	// A notification sent when a notebook closes.
	//
	// Since: 3.17.0
	MethodNotebookDocumentDidClose Method = "notebookDocument/didClose"
	// The initialized notification is sent from the client to the
	// server after the client is fully initialized and the server
	// is allowed to send requests from the server to the client.
	MethodInitialized Method = "initialized"
	// The exit event is sent from the client to the server to
	// ask the server to exit its process.
	MethodExit Method = "exit"
	// The configuration change notification is sent from the client to the server
	// when the client's configuration has changed. The notification contains
	// the changed configuration as defined by the language client.
	MethodWorkspaceDidChangeConfiguration Method = "workspace/didChangeConfiguration"
	// The show message notification is sent from a server to a client to ask
	// the client to display a particular message in the user interface.
	MethodWindowShowMessage Method = "window/showMessage"
	// The log message notification is sent from the server to the client to ask
	// the client to log a particular message.
	MethodWindowLogMessage Method = "window/logMessage"
	// The telemetry event notification is sent from the server to the client to ask
	// the client to log telemetry data.
	MethodTelemetryEvent Method = "telemetry/event"
	// The document open notification is sent from the client to the server to signal
	// newly opened text documents. The document's truth is now managed by the client
	// and the server must not try to read the document's truth using the document's
	// uri. Open in this sense means it is managed by the client. It doesn't necessarily
	// mean that its content is presented in an editor. An open notification must not
	// be sent more than once without a corresponding close notification send before.
	// This means open and close notification must be balanced and the max open count
	// is one.
	MethodTextDocumentDidOpen Method = "textDocument/didOpen"
	// The document change notification is sent from the client to the server to signal
	// changes to a text document.
	MethodTextDocumentDidChange Method = "textDocument/didChange"
	// The document close notification is sent from the client to the server when
	// the document got closed in the client. The document's truth now exists where
	// the document's uri points to (e.g. if the document's uri is a file uri the
	// truth now exists on disk). As with the open notification the close notification
	// is about managing the document's content. Receiving a close notification
	// doesn't mean that the document was open in an editor before. A close
	// notification requires a previous open notification to be sent.
	MethodTextDocumentDidClose Method = "textDocument/didClose"
	// The document save notification is sent from the client to the server when
	// the document got saved in the client.
	MethodTextDocumentDidSave Method = "textDocument/didSave"
	// A document will save notification is sent from the client to the server before
	// the document is actually saved.
	MethodTextDocumentWillSave Method = "textDocument/willSave"
	// The watched files notification is sent from the client to the server when
	// the client detects changes to file watched by the language client.
	MethodWorkspaceDidChangeWatchedFiles Method = "workspace/didChangeWatchedFiles"
	// Diagnostics notification are sent from the server to the client to signal
	// results of validation runs.
	MethodTextDocumentPublishDiagnostics Method = "textDocument/publishDiagnostics"
	MethodSetTrace                       Method = "$/setTrace"
	MethodLogTrace                       Method = "$/logTrace"
	MethodCancelRequest                  Method = "$/cancelRequest"
	MethodProgress                       Method = "$/progress"
)

// Request response types

// Response type for `textDocument/implementation`
type ImplementationResponse = LocationOrLocationsOrDefinitionLinksOrNull

// Type mapping info for `textDocument/implementation`
var TextDocumentImplementationInfo = RequestInfo[*ImplementationParams, ImplementationResponse]{Method: MethodTextDocumentImplementation}

// Response type for `textDocument/typeDefinition`
type TypeDefinitionResponse = LocationOrLocationsOrDefinitionLinksOrNull

// Type mapping info for `textDocument/typeDefinition`
var TextDocumentTypeDefinitionInfo = RequestInfo[*TypeDefinitionParams, TypeDefinitionResponse]{Method: MethodTextDocumentTypeDefinition}

// Response type for `workspace/workspaceFolders`
type WorkspaceFoldersResponse = WorkspaceFoldersOrNull

// Type mapping info for `workspace/workspaceFolders`
var WorkspaceWorkspaceFoldersInfo = RequestInfo[any, WorkspaceFoldersResponse]{Method: MethodWorkspaceWorkspaceFolders}

// Response type for `workspace/configuration`
type ConfigurationResponse = []any

// Type mapping info for `workspace/configuration`
var WorkspaceConfigurationInfo = RequestInfo[*ConfigurationParams, ConfigurationResponse]{Method: MethodWorkspaceConfiguration}

// Response type for `textDocument/documentColor`
type DocumentColorResponse = []*ColorInformation

// Type mapping info for `textDocument/documentColor`
var TextDocumentDocumentColorInfo = RequestInfo[*DocumentColorParams, DocumentColorResponse]{Method: MethodTextDocumentDocumentColor}

// Response type for `textDocument/colorPresentation`
type ColorPresentationResponse = []*ColorPresentation

// Type mapping info for `textDocument/colorPresentation`
var TextDocumentColorPresentationInfo = RequestInfo[*ColorPresentationParams, ColorPresentationResponse]{Method: MethodTextDocumentColorPresentation}

// Response type for `textDocument/foldingRange`
type FoldingRangeResponse = FoldingRangesOrNull

// Type mapping info for `textDocument/foldingRange`
var TextDocumentFoldingRangeInfo = RequestInfo[*FoldingRangeParams, FoldingRangeResponse]{Method: MethodTextDocumentFoldingRange}

// Response type for `workspace/foldingRange/refresh`
type FoldingRangeRefreshResponse = any

// Type mapping info for `workspace/foldingRange/refresh`
var WorkspaceFoldingRangeRefreshInfo = RequestInfo[any, FoldingRangeRefreshResponse]{Method: MethodWorkspaceFoldingRangeRefresh}

// Response type for `textDocument/declaration`
type DeclarationResponse = LocationOrLocationsOrDeclarationLinksOrNull

// Type mapping info for `textDocument/declaration`
var TextDocumentDeclarationInfo = RequestInfo[*DeclarationParams, DeclarationResponse]{Method: MethodTextDocumentDeclaration}

// Response type for `textDocument/selectionRange`
type SelectionRangeResponse = SelectionRangesOrNull

// Type mapping info for `textDocument/selectionRange`
var TextDocumentSelectionRangeInfo = RequestInfo[*SelectionRangeParams, SelectionRangeResponse]{Method: MethodTextDocumentSelectionRange}

// Response type for `window/workDoneProgress/create`
type WorkDoneProgressCreateResponse = any

// Type mapping info for `window/workDoneProgress/create`
var WindowWorkDoneProgressCreateInfo = RequestInfo[*WorkDoneProgressCreateParams, WorkDoneProgressCreateResponse]{Method: MethodWindowWorkDoneProgressCreate}

// Response type for `textDocument/prepareCallHierarchy`
type CallHierarchyPrepareResponse = CallHierarchyItemsOrNull

// Type mapping info for `textDocument/prepareCallHierarchy`
var TextDocumentPrepareCallHierarchyInfo = RequestInfo[*CallHierarchyPrepareParams, CallHierarchyPrepareResponse]{Method: MethodTextDocumentPrepareCallHierarchy}

// Response type for `callHierarchy/incomingCalls`
type CallHierarchyIncomingCallsResponse = CallHierarchyIncomingCallsOrNull

// Type mapping info for `callHierarchy/incomingCalls`
var CallHierarchyIncomingCallsInfo = RequestInfo[*CallHierarchyIncomingCallsParams, CallHierarchyIncomingCallsResponse]{Method: MethodCallHierarchyIncomingCalls}

// Response type for `callHierarchy/outgoingCalls`
type CallHierarchyOutgoingCallsResponse = CallHierarchyOutgoingCallsOrNull

// Type mapping info for `callHierarchy/outgoingCalls`
var CallHierarchyOutgoingCallsInfo = RequestInfo[*CallHierarchyOutgoingCallsParams, CallHierarchyOutgoingCallsResponse]{Method: MethodCallHierarchyOutgoingCalls}

// Response type for `textDocument/semanticTokens/full`
type SemanticTokensResponse = SemanticTokensOrNull

// Type mapping info for `textDocument/semanticTokens/full`
var TextDocumentSemanticTokensFullInfo = RequestInfo[*SemanticTokensParams, SemanticTokensResponse]{Method: MethodTextDocumentSemanticTokensFull}

// Response type for `textDocument/semanticTokens/full/delta`
type SemanticTokensDeltaResponse = SemanticTokensOrSemanticTokensDeltaOrNull

// Type mapping info for `textDocument/semanticTokens/full/delta`
var TextDocumentSemanticTokensFullDeltaInfo = RequestInfo[*SemanticTokensDeltaParams, SemanticTokensDeltaResponse]{Method: MethodTextDocumentSemanticTokensFullDelta}

// Response type for `textDocument/semanticTokens/range`
type SemanticTokensRangeResponse = SemanticTokensOrNull

// Type mapping info for `textDocument/semanticTokens/range`
var TextDocumentSemanticTokensRangeInfo = RequestInfo[*SemanticTokensRangeParams, SemanticTokensRangeResponse]{Method: MethodTextDocumentSemanticTokensRange}

// Response type for `workspace/semanticTokens/refresh`
type SemanticTokensRefreshResponse = any

// Type mapping info for `workspace/semanticTokens/refresh`
var WorkspaceSemanticTokensRefreshInfo = RequestInfo[any, SemanticTokensRefreshResponse]{Method: MethodWorkspaceSemanticTokensRefresh}

// Response type for `window/showDocument`
type ShowDocumentResponse = *ShowDocumentResult

// Type mapping info for `window/showDocument`
var WindowShowDocumentInfo = RequestInfo[*ShowDocumentParams, ShowDocumentResponse]{Method: MethodWindowShowDocument}

// Response type for `textDocument/linkedEditingRange`
type LinkedEditingRangeResponse = LinkedEditingRangesOrNull

// Type mapping info for `textDocument/linkedEditingRange`
var TextDocumentLinkedEditingRangeInfo = RequestInfo[*LinkedEditingRangeParams, LinkedEditingRangeResponse]{Method: MethodTextDocumentLinkedEditingRange}

// Response type for `workspace/willCreateFiles`
type WillCreateFilesResponse = WorkspaceEditOrNull

// Type mapping info for `workspace/willCreateFiles`
var WorkspaceWillCreateFilesInfo = RequestInfo[*CreateFilesParams, WillCreateFilesResponse]{Method: MethodWorkspaceWillCreateFiles}

// Response type for `workspace/willRenameFiles`
type WillRenameFilesResponse = WorkspaceEditOrNull

// Type mapping info for `workspace/willRenameFiles`
var WorkspaceWillRenameFilesInfo = RequestInfo[*RenameFilesParams, WillRenameFilesResponse]{Method: MethodWorkspaceWillRenameFiles}

// Response type for `workspace/willDeleteFiles`
type WillDeleteFilesResponse = WorkspaceEditOrNull

// Type mapping info for `workspace/willDeleteFiles`
var WorkspaceWillDeleteFilesInfo = RequestInfo[*DeleteFilesParams, WillDeleteFilesResponse]{Method: MethodWorkspaceWillDeleteFiles}

// Response type for `textDocument/moniker`
type MonikerResponse = MonikersOrNull

// Type mapping info for `textDocument/moniker`
var TextDocumentMonikerInfo = RequestInfo[*MonikerParams, MonikerResponse]{Method: MethodTextDocumentMoniker}

// Response type for `textDocument/prepareTypeHierarchy`
type TypeHierarchyPrepareResponse = TypeHierarchyItemsOrNull

// Type mapping info for `textDocument/prepareTypeHierarchy`
var TextDocumentPrepareTypeHierarchyInfo = RequestInfo[*TypeHierarchyPrepareParams, TypeHierarchyPrepareResponse]{Method: MethodTextDocumentPrepareTypeHierarchy}

// Response type for `typeHierarchy/supertypes`
type TypeHierarchySupertypesResponse = TypeHierarchyItemsOrNull

// Type mapping info for `typeHierarchy/supertypes`
var TypeHierarchySupertypesInfo = RequestInfo[*TypeHierarchySupertypesParams, TypeHierarchySupertypesResponse]{Method: MethodTypeHierarchySupertypes}

// Response type for `typeHierarchy/subtypes`
type TypeHierarchySubtypesResponse = TypeHierarchyItemsOrNull

// Type mapping info for `typeHierarchy/subtypes`
var TypeHierarchySubtypesInfo = RequestInfo[*TypeHierarchySubtypesParams, TypeHierarchySubtypesResponse]{Method: MethodTypeHierarchySubtypes}

// Response type for `textDocument/inlineValue`
type InlineValueResponse = InlineValuesOrNull

// Type mapping info for `textDocument/inlineValue`
var TextDocumentInlineValueInfo = RequestInfo[*InlineValueParams, InlineValueResponse]{Method: MethodTextDocumentInlineValue}

// Response type for `workspace/inlineValue/refresh`
type InlineValueRefreshResponse = any

// Type mapping info for `workspace/inlineValue/refresh`
var WorkspaceInlineValueRefreshInfo = RequestInfo[any, InlineValueRefreshResponse]{Method: MethodWorkspaceInlineValueRefresh}

// Response type for `textDocument/inlayHint`
type InlayHintResponse = InlayHintsOrNull

// Type mapping info for `textDocument/inlayHint`
var TextDocumentInlayHintInfo = RequestInfo[*InlayHintParams, InlayHintResponse]{Method: MethodTextDocumentInlayHint}

// Response type for `inlayHint/resolve`
type InlayHintResolveResponse = *InlayHint

// Type mapping info for `inlayHint/resolve`
var InlayHintResolveInfo = RequestInfo[*InlayHint, InlayHintResolveResponse]{Method: MethodInlayHintResolve}

// Response type for `workspace/inlayHint/refresh`
type InlayHintRefreshResponse = any

// Type mapping info for `workspace/inlayHint/refresh`
var WorkspaceInlayHintRefreshInfo = RequestInfo[any, InlayHintRefreshResponse]{Method: MethodWorkspaceInlayHintRefresh}

// Response type for `textDocument/diagnostic`
type DocumentDiagnosticResponse = RelatedFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport

// Type mapping info for `textDocument/diagnostic`
var TextDocumentDiagnosticInfo = RequestInfo[*DocumentDiagnosticParams, DocumentDiagnosticResponse]{Method: MethodTextDocumentDiagnostic}

// Response type for `workspace/diagnostic`
type WorkspaceDiagnosticResponse = *WorkspaceDiagnosticReport

// Type mapping info for `workspace/diagnostic`
var WorkspaceDiagnosticInfo = RequestInfo[*WorkspaceDiagnosticParams, WorkspaceDiagnosticResponse]{Method: MethodWorkspaceDiagnostic}

// Response type for `workspace/diagnostic/refresh`
type DiagnosticRefreshResponse = any

// Type mapping info for `workspace/diagnostic/refresh`
var WorkspaceDiagnosticRefreshInfo = RequestInfo[any, DiagnosticRefreshResponse]{Method: MethodWorkspaceDiagnosticRefresh}

// Response type for `textDocument/inlineCompletion`
type InlineCompletionResponse = InlineCompletionListOrItemsOrNull

// Type mapping info for `textDocument/inlineCompletion`
var TextDocumentInlineCompletionInfo = RequestInfo[*InlineCompletionParams, InlineCompletionResponse]{Method: MethodTextDocumentInlineCompletion}

// Response type for `workspace/textDocumentContent`
type TextDocumentContentResponse = *TextDocumentContentResult

// Type mapping info for `workspace/textDocumentContent`
var WorkspaceTextDocumentContentInfo = RequestInfo[*TextDocumentContentParams, TextDocumentContentResponse]{Method: MethodWorkspaceTextDocumentContent}

// Response type for `workspace/textDocumentContent/refresh`
type TextDocumentContentRefreshResponse = any

// Type mapping info for `workspace/textDocumentContent/refresh`
var WorkspaceTextDocumentContentRefreshInfo = RequestInfo[*TextDocumentContentRefreshParams, TextDocumentContentRefreshResponse]{Method: MethodWorkspaceTextDocumentContentRefresh}

// Response type for `client/registerCapability`
type RegistrationResponse = any

// Type mapping info for `client/registerCapability`
var ClientRegisterCapabilityInfo = RequestInfo[*RegistrationParams, RegistrationResponse]{Method: MethodClientRegisterCapability}

// Response type for `client/unregisterCapability`
type UnregistrationResponse = any

// Type mapping info for `client/unregisterCapability`
var ClientUnregisterCapabilityInfo = RequestInfo[*UnregistrationParams, UnregistrationResponse]{Method: MethodClientUnregisterCapability}

// Response type for `initialize`
type InitializeResponse = *InitializeResult

// Type mapping info for `initialize`
var InitializeInfo = RequestInfo[*InitializeParams, InitializeResponse]{Method: MethodInitialize}

// Response type for `shutdown`
type ShutdownResponse = any

// Type mapping info for `shutdown`
var ShutdownInfo = RequestInfo[any, ShutdownResponse]{Method: MethodShutdown}

// Response type for `window/showMessageRequest`
type ShowMessageResponse = MessageActionItemOrNull

// Type mapping info for `window/showMessageRequest`
var WindowShowMessageRequestInfo = RequestInfo[*ShowMessageRequestParams, ShowMessageResponse]{Method: MethodWindowShowMessageRequest}

// Response type for `textDocument/willSaveWaitUntil`
type WillSaveTextDocumentWaitUntilResponse = TextEditsOrNull

// Type mapping info for `textDocument/willSaveWaitUntil`
var TextDocumentWillSaveWaitUntilInfo = RequestInfo[*WillSaveTextDocumentParams, WillSaveTextDocumentWaitUntilResponse]{Method: MethodTextDocumentWillSaveWaitUntil}

// Response type for `textDocument/completion`
type CompletionResponse = CompletionItemsOrListOrNull

// Type mapping info for `textDocument/completion`
var TextDocumentCompletionInfo = RequestInfo[*CompletionParams, CompletionResponse]{Method: MethodTextDocumentCompletion}

// Response type for `completionItem/resolve`
type CompletionResolveResponse = *CompletionItem

// Type mapping info for `completionItem/resolve`
var CompletionItemResolveInfo = RequestInfo[*CompletionItem, CompletionResolveResponse]{Method: MethodCompletionItemResolve}

// Response type for `textDocument/hover`
type HoverResponse = HoverOrNull

// Type mapping info for `textDocument/hover`
var TextDocumentHoverInfo = RequestInfo[*HoverParams, HoverResponse]{Method: MethodTextDocumentHover}

// Response type for `textDocument/signatureHelp`
type SignatureHelpResponse = SignatureHelpOrNull

// Type mapping info for `textDocument/signatureHelp`
var TextDocumentSignatureHelpInfo = RequestInfo[*SignatureHelpParams, SignatureHelpResponse]{Method: MethodTextDocumentSignatureHelp}

// Response type for `textDocument/definition`
type DefinitionResponse = LocationOrLocationsOrDefinitionLinksOrNull

// Type mapping info for `textDocument/definition`
var TextDocumentDefinitionInfo = RequestInfo[*DefinitionParams, DefinitionResponse]{Method: MethodTextDocumentDefinition}

// Response type for `textDocument/references`
type ReferencesResponse = LocationsOrNull

// Type mapping info for `textDocument/references`
var TextDocumentReferencesInfo = RequestInfo[*ReferenceParams, ReferencesResponse]{Method: MethodTextDocumentReferences}

// Response type for `textDocument/documentHighlight`
type DocumentHighlightResponse = DocumentHighlightsOrNull

// Type mapping info for `textDocument/documentHighlight`
var TextDocumentDocumentHighlightInfo = RequestInfo[*DocumentHighlightParams, DocumentHighlightResponse]{Method: MethodTextDocumentDocumentHighlight}

// Response type for `textDocument/documentSymbol`
type DocumentSymbolResponse = SymbolInformationsOrDocumentSymbolsOrNull

// Type mapping info for `textDocument/documentSymbol`
var TextDocumentDocumentSymbolInfo = RequestInfo[*DocumentSymbolParams, DocumentSymbolResponse]{Method: MethodTextDocumentDocumentSymbol}

// Response type for `textDocument/codeAction`
type CodeActionResponse = CommandOrCodeActionArrayOrNull

// Type mapping info for `textDocument/codeAction`
var TextDocumentCodeActionInfo = RequestInfo[*CodeActionParams, CodeActionResponse]{Method: MethodTextDocumentCodeAction}

// Response type for `codeAction/resolve`
type CodeActionResolveResponse = *CodeAction

// Type mapping info for `codeAction/resolve`
var CodeActionResolveInfo = RequestInfo[*CodeAction, CodeActionResolveResponse]{Method: MethodCodeActionResolve}

// Response type for `workspace/symbol`
type WorkspaceSymbolResponse = SymbolInformationsOrWorkspaceSymbolsOrNull

// Type mapping info for `workspace/symbol`
var WorkspaceSymbolInfo = RequestInfo[*WorkspaceSymbolParams, WorkspaceSymbolResponse]{Method: MethodWorkspaceSymbol}

// Response type for `workspaceSymbol/resolve`
type WorkspaceSymbolResolveResponse = *WorkspaceSymbol

// Type mapping info for `workspaceSymbol/resolve`
var WorkspaceSymbolResolveInfo = RequestInfo[*WorkspaceSymbol, WorkspaceSymbolResolveResponse]{Method: MethodWorkspaceSymbolResolve}

// Response type for `textDocument/codeLens`
type CodeLensResponse = CodeLenssOrNull

// Type mapping info for `textDocument/codeLens`
var TextDocumentCodeLensInfo = RequestInfo[*CodeLensParams, CodeLensResponse]{Method: MethodTextDocumentCodeLens}

// Response type for `codeLens/resolve`
type CodeLensResolveResponse = *CodeLens

// Type mapping info for `codeLens/resolve`
var CodeLensResolveInfo = RequestInfo[*CodeLens, CodeLensResolveResponse]{Method: MethodCodeLensResolve}

// Response type for `workspace/codeLens/refresh`
type CodeLensRefreshResponse = any

// Type mapping info for `workspace/codeLens/refresh`
var WorkspaceCodeLensRefreshInfo = RequestInfo[any, CodeLensRefreshResponse]{Method: MethodWorkspaceCodeLensRefresh}

// Response type for `textDocument/documentLink`
type DocumentLinkResponse = DocumentLinksOrNull

// Type mapping info for `textDocument/documentLink`
var TextDocumentDocumentLinkInfo = RequestInfo[*DocumentLinkParams, DocumentLinkResponse]{Method: MethodTextDocumentDocumentLink}

// Response type for `documentLink/resolve`
type DocumentLinkResolveResponse = *DocumentLink

// Type mapping info for `documentLink/resolve`
var DocumentLinkResolveInfo = RequestInfo[*DocumentLink, DocumentLinkResolveResponse]{Method: MethodDocumentLinkResolve}

// Response type for `textDocument/formatting`
type DocumentFormattingResponse = TextEditsOrNull

// Type mapping info for `textDocument/formatting`
var TextDocumentFormattingInfo = RequestInfo[*DocumentFormattingParams, DocumentFormattingResponse]{Method: MethodTextDocumentFormatting}

// Response type for `textDocument/rangeFormatting`
type DocumentRangeFormattingResponse = TextEditsOrNull

// Type mapping info for `textDocument/rangeFormatting`
var TextDocumentRangeFormattingInfo = RequestInfo[*DocumentRangeFormattingParams, DocumentRangeFormattingResponse]{Method: MethodTextDocumentRangeFormatting}

// Response type for `textDocument/rangesFormatting`
type DocumentRangesFormattingResponse = TextEditsOrNull

// Type mapping info for `textDocument/rangesFormatting`
var TextDocumentRangesFormattingInfo = RequestInfo[*DocumentRangesFormattingParams, DocumentRangesFormattingResponse]{Method: MethodTextDocumentRangesFormatting}

// Response type for `textDocument/onTypeFormatting`
type DocumentOnTypeFormattingResponse = TextEditsOrNull

// Type mapping info for `textDocument/onTypeFormatting`
var TextDocumentOnTypeFormattingInfo = RequestInfo[*DocumentOnTypeFormattingParams, DocumentOnTypeFormattingResponse]{Method: MethodTextDocumentOnTypeFormatting}

// Response type for `textDocument/rename`
type RenameResponse = WorkspaceEditOrNull

// Type mapping info for `textDocument/rename`
var TextDocumentRenameInfo = RequestInfo[*RenameParams, RenameResponse]{Method: MethodTextDocumentRename}

// Response type for `textDocument/prepareRename`
type PrepareRenameResponse = RangeOrPrepareRenamePlaceholderOrPrepareRenameDefaultBehaviorOrNull

// Type mapping info for `textDocument/prepareRename`
var TextDocumentPrepareRenameInfo = RequestInfo[*PrepareRenameParams, PrepareRenameResponse]{Method: MethodTextDocumentPrepareRename}

// Response type for `workspace/executeCommand`
type ExecuteCommandResponse = LSPAnyOrNull

// Type mapping info for `workspace/executeCommand`
var WorkspaceExecuteCommandInfo = RequestInfo[*ExecuteCommandParams, ExecuteCommandResponse]{Method: MethodWorkspaceExecuteCommand}

// Response type for `workspace/applyEdit`
type ApplyWorkspaceEditResponse = *ApplyWorkspaceEditResult

// Type mapping info for `workspace/applyEdit`
var WorkspaceApplyEditInfo = RequestInfo[*ApplyWorkspaceEditParams, ApplyWorkspaceEditResponse]{Method: MethodWorkspaceApplyEdit}

// Type mapping info for `workspace/didChangeWorkspaceFolders`
var WorkspaceDidChangeWorkspaceFoldersInfo = NotificationInfo[*DidChangeWorkspaceFoldersParams]{Method: MethodWorkspaceDidChangeWorkspaceFolders}

// Type mapping info for `window/workDoneProgress/cancel`
var WindowWorkDoneProgressCancelInfo = NotificationInfo[*WorkDoneProgressCancelParams]{Method: MethodWindowWorkDoneProgressCancel}

// Type mapping info for `workspace/didCreateFiles`
var WorkspaceDidCreateFilesInfo = NotificationInfo[*CreateFilesParams]{Method: MethodWorkspaceDidCreateFiles}

// Type mapping info for `workspace/didRenameFiles`
var WorkspaceDidRenameFilesInfo = NotificationInfo[*RenameFilesParams]{Method: MethodWorkspaceDidRenameFiles}

// Type mapping info for `workspace/didDeleteFiles`
var WorkspaceDidDeleteFilesInfo = NotificationInfo[*DeleteFilesParams]{Method: MethodWorkspaceDidDeleteFiles}

// Type mapping info for `notebookDocument/didOpen`
var NotebookDocumentDidOpenInfo = NotificationInfo[*DidOpenNotebookDocumentParams]{Method: MethodNotebookDocumentDidOpen}

// Type mapping info for `notebookDocument/didChange`
var NotebookDocumentDidChangeInfo = NotificationInfo[*DidChangeNotebookDocumentParams]{Method: MethodNotebookDocumentDidChange}

// Type mapping info for `notebookDocument/didSave`
var NotebookDocumentDidSaveInfo = NotificationInfo[*DidSaveNotebookDocumentParams]{Method: MethodNotebookDocumentDidSave}

// Type mapping info for `notebookDocument/didClose`
var NotebookDocumentDidCloseInfo = NotificationInfo[*DidCloseNotebookDocumentParams]{Method: MethodNotebookDocumentDidClose}

// Type mapping info for `initialized`
var InitializedInfo = NotificationInfo[*InitializedParams]{Method: MethodInitialized}

// Type mapping info for `exit`
var ExitInfo = NotificationInfo[any]{Method: MethodExit}

// Type mapping info for `workspace/didChangeConfiguration`
var WorkspaceDidChangeConfigurationInfo = NotificationInfo[*DidChangeConfigurationParams]{Method: MethodWorkspaceDidChangeConfiguration}

// Type mapping info for `window/showMessage`
var WindowShowMessageInfo = NotificationInfo[*ShowMessageParams]{Method: MethodWindowShowMessage}

// Type mapping info for `window/logMessage`
var WindowLogMessageInfo = NotificationInfo[*LogMessageParams]{Method: MethodWindowLogMessage}

// Type mapping info for `telemetry/event`
var TelemetryEventInfo = NotificationInfo[any]{Method: MethodTelemetryEvent}

// Type mapping info for `textDocument/didOpen`
var TextDocumentDidOpenInfo = NotificationInfo[*DidOpenTextDocumentParams]{Method: MethodTextDocumentDidOpen}

// Type mapping info for `textDocument/didChange`
var TextDocumentDidChangeInfo = NotificationInfo[*DidChangeTextDocumentParams]{Method: MethodTextDocumentDidChange}

// Type mapping info for `textDocument/didClose`
var TextDocumentDidCloseInfo = NotificationInfo[*DidCloseTextDocumentParams]{Method: MethodTextDocumentDidClose}

// Type mapping info for `textDocument/didSave`
var TextDocumentDidSaveInfo = NotificationInfo[*DidSaveTextDocumentParams]{Method: MethodTextDocumentDidSave}

// Type mapping info for `textDocument/willSave`
var TextDocumentWillSaveInfo = NotificationInfo[*WillSaveTextDocumentParams]{Method: MethodTextDocumentWillSave}

// Type mapping info for `workspace/didChangeWatchedFiles`
var WorkspaceDidChangeWatchedFilesInfo = NotificationInfo[*DidChangeWatchedFilesParams]{Method: MethodWorkspaceDidChangeWatchedFiles}

// Type mapping info for `textDocument/publishDiagnostics`
var TextDocumentPublishDiagnosticsInfo = NotificationInfo[*PublishDiagnosticsParams]{Method: MethodTextDocumentPublishDiagnostics}

// Type mapping info for `$/setTrace`
var SetTraceInfo = NotificationInfo[*SetTraceParams]{Method: MethodSetTrace}

// Type mapping info for `$/logTrace`
var LogTraceInfo = NotificationInfo[*LogTraceParams]{Method: MethodLogTrace}

// Type mapping info for `$/cancelRequest`
var CancelRequestInfo = NotificationInfo[*CancelParams]{Method: MethodCancelRequest}

// Type mapping info for `$/progress`
var ProgressInfo = NotificationInfo[*ProgressParams]{Method: MethodProgress}

// Union types

type IntegerOrString struct {
	Integer *int32
	String  *string
}

func (o IntegerOrString) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of IntegerOrString is set", o.Integer != nil, o.String != nil)

	if o.Integer != nil {
		return json.Marshal(*o.Integer)
	}
	if o.String != nil {
		return json.Marshal(*o.String)
	}
	panic("unreachable")
}

func (o *IntegerOrString) UnmarshalJSON(data []byte) error {
	*o = IntegerOrString{}

	var vInteger int32
	if err := json.Unmarshal(data, &vInteger); err == nil {
		o.Integer = &vInteger
		return nil
	}
	var vString string
	if err := json.Unmarshal(data, &vString); err == nil {
		o.String = &vString
		return nil
	}
	return fmt.Errorf("invalid IntegerOrString: %s", data)
}

type DocumentSelectorOrNull struct {
	DocumentSelector *[]TextDocumentFilterLanguageOrTextDocumentFilterSchemeOrTextDocumentFilterPatternOrNotebookCellTextDocumentFilter
}

func (o DocumentSelectorOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of DocumentSelectorOrNull is set", o.DocumentSelector != nil)

	if o.DocumentSelector != nil {
		return json.Marshal(*o.DocumentSelector)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *DocumentSelectorOrNull) UnmarshalJSON(data []byte) error {
	*o = DocumentSelectorOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vDocumentSelector []TextDocumentFilterLanguageOrTextDocumentFilterSchemeOrTextDocumentFilterPatternOrNotebookCellTextDocumentFilter
	if err := json.Unmarshal(data, &vDocumentSelector); err == nil {
		o.DocumentSelector = &vDocumentSelector
		return nil
	}
	return fmt.Errorf("invalid DocumentSelectorOrNull: %s", data)
}

type BooleanOrEmptyObject struct {
	Boolean     *bool
	EmptyObject *struct{}
}

func (o BooleanOrEmptyObject) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrEmptyObject is set", o.Boolean != nil, o.EmptyObject != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.EmptyObject != nil {
		return json.Marshal(*o.EmptyObject)
	}
	panic("unreachable")
}

func (o *BooleanOrEmptyObject) UnmarshalJSON(data []byte) error {
	*o = BooleanOrEmptyObject{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vEmptyObject struct{}
	if err := json.Unmarshal(data, &vEmptyObject); err == nil {
		o.EmptyObject = &vEmptyObject
		return nil
	}
	return fmt.Errorf("invalid BooleanOrEmptyObject: %s", data)
}

type BooleanOrSemanticTokensFullDelta struct {
	Boolean                 *bool
	SemanticTokensFullDelta *SemanticTokensFullDelta
}

func (o BooleanOrSemanticTokensFullDelta) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrSemanticTokensFullDelta is set", o.Boolean != nil, o.SemanticTokensFullDelta != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.SemanticTokensFullDelta != nil {
		return json.Marshal(*o.SemanticTokensFullDelta)
	}
	panic("unreachable")
}

func (o *BooleanOrSemanticTokensFullDelta) UnmarshalJSON(data []byte) error {
	*o = BooleanOrSemanticTokensFullDelta{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vSemanticTokensFullDelta SemanticTokensFullDelta
	if err := json.Unmarshal(data, &vSemanticTokensFullDelta); err == nil {
		o.SemanticTokensFullDelta = &vSemanticTokensFullDelta
		return nil
	}
	return fmt.Errorf("invalid BooleanOrSemanticTokensFullDelta: %s", data)
}

type TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile struct {
	TextDocumentEdit *TextDocumentEdit
	CreateFile       *CreateFile
	RenameFile       *RenameFile
	DeleteFile       *DeleteFile
}

func (o TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile is set", o.TextDocumentEdit != nil, o.CreateFile != nil, o.RenameFile != nil, o.DeleteFile != nil)

	if o.TextDocumentEdit != nil {
		return json.Marshal(*o.TextDocumentEdit)
	}
	if o.CreateFile != nil {
		return json.Marshal(*o.CreateFile)
	}
	if o.RenameFile != nil {
		return json.Marshal(*o.RenameFile)
	}
	if o.DeleteFile != nil {
		return json.Marshal(*o.DeleteFile)
	}
	panic("unreachable")
}

func (o *TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile) UnmarshalJSON(data []byte) error {
	*o = TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile{}

	var vTextDocumentEdit TextDocumentEdit
	if err := json.Unmarshal(data, &vTextDocumentEdit); err == nil {
		o.TextDocumentEdit = &vTextDocumentEdit
		return nil
	}
	var vCreateFile CreateFile
	if err := json.Unmarshal(data, &vCreateFile); err == nil {
		o.CreateFile = &vCreateFile
		return nil
	}
	var vRenameFile RenameFile
	if err := json.Unmarshal(data, &vRenameFile); err == nil {
		o.RenameFile = &vRenameFile
		return nil
	}
	var vDeleteFile DeleteFile
	if err := json.Unmarshal(data, &vDeleteFile); err == nil {
		o.DeleteFile = &vDeleteFile
		return nil
	}
	return fmt.Errorf("invalid TextDocumentEditOrCreateFileOrRenameFileOrDeleteFile: %s", data)
}

type StringOrInlayHintLabelParts struct {
	String              *string
	InlayHintLabelParts *[]*InlayHintLabelPart
}

func (o StringOrInlayHintLabelParts) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of StringOrInlayHintLabelParts is set", o.String != nil, o.InlayHintLabelParts != nil)

	if o.String != nil {
		return json.Marshal(*o.String)
	}
	if o.InlayHintLabelParts != nil {
		return json.Marshal(*o.InlayHintLabelParts)
	}
	panic("unreachable")
}

func (o *StringOrInlayHintLabelParts) UnmarshalJSON(data []byte) error {
	*o = StringOrInlayHintLabelParts{}

	var vString string
	if err := json.Unmarshal(data, &vString); err == nil {
		o.String = &vString
		return nil
	}
	var vInlayHintLabelParts []*InlayHintLabelPart
	if err := json.Unmarshal(data, &vInlayHintLabelParts); err == nil {
		o.InlayHintLabelParts = &vInlayHintLabelParts
		return nil
	}
	return fmt.Errorf("invalid StringOrInlayHintLabelParts: %s", data)
}

type StringOrMarkupContent struct {
	String        *string
	MarkupContent *MarkupContent
}

func (o StringOrMarkupContent) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of StringOrMarkupContent is set", o.String != nil, o.MarkupContent != nil)

	if o.String != nil {
		return json.Marshal(*o.String)
	}
	if o.MarkupContent != nil {
		return json.Marshal(*o.MarkupContent)
	}
	panic("unreachable")
}

func (o *StringOrMarkupContent) UnmarshalJSON(data []byte) error {
	*o = StringOrMarkupContent{}

	var vString string
	if err := json.Unmarshal(data, &vString); err == nil {
		o.String = &vString
		return nil
	}
	var vMarkupContent MarkupContent
	if err := json.Unmarshal(data, &vMarkupContent); err == nil {
		o.MarkupContent = &vMarkupContent
		return nil
	}
	return fmt.Errorf("invalid StringOrMarkupContent: %s", data)
}

type FullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport struct {
	FullDocumentDiagnosticReport      *FullDocumentDiagnosticReport
	UnchangedDocumentDiagnosticReport *UnchangedDocumentDiagnosticReport
}

func (o FullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of FullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport is set", o.FullDocumentDiagnosticReport != nil, o.UnchangedDocumentDiagnosticReport != nil)

	if o.FullDocumentDiagnosticReport != nil {
		return json.Marshal(*o.FullDocumentDiagnosticReport)
	}
	if o.UnchangedDocumentDiagnosticReport != nil {
		return json.Marshal(*o.UnchangedDocumentDiagnosticReport)
	}
	panic("unreachable")
}

func (o *FullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	*o = FullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport{}

	var vFullDocumentDiagnosticReport FullDocumentDiagnosticReport
	if err := json.Unmarshal(data, &vFullDocumentDiagnosticReport); err == nil {
		o.FullDocumentDiagnosticReport = &vFullDocumentDiagnosticReport
		return nil
	}
	var vUnchangedDocumentDiagnosticReport UnchangedDocumentDiagnosticReport
	if err := json.Unmarshal(data, &vUnchangedDocumentDiagnosticReport); err == nil {
		o.UnchangedDocumentDiagnosticReport = &vUnchangedDocumentDiagnosticReport
		return nil
	}
	return fmt.Errorf("invalid FullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport: %s", data)
}

type WorkspaceFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport struct {
	FullDocumentDiagnosticReport      *WorkspaceFullDocumentDiagnosticReport
	UnchangedDocumentDiagnosticReport *WorkspaceUnchangedDocumentDiagnosticReport
}

func (o WorkspaceFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of WorkspaceFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport is set", o.FullDocumentDiagnosticReport != nil, o.UnchangedDocumentDiagnosticReport != nil)

	if o.FullDocumentDiagnosticReport != nil {
		return json.Marshal(*o.FullDocumentDiagnosticReport)
	}
	if o.UnchangedDocumentDiagnosticReport != nil {
		return json.Marshal(*o.UnchangedDocumentDiagnosticReport)
	}
	panic("unreachable")
}

func (o *WorkspaceFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	*o = WorkspaceFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport{}

	var vFullDocumentDiagnosticReport WorkspaceFullDocumentDiagnosticReport
	if err := json.Unmarshal(data, &vFullDocumentDiagnosticReport); err == nil {
		o.FullDocumentDiagnosticReport = &vFullDocumentDiagnosticReport
		return nil
	}
	var vUnchangedDocumentDiagnosticReport WorkspaceUnchangedDocumentDiagnosticReport
	if err := json.Unmarshal(data, &vUnchangedDocumentDiagnosticReport); err == nil {
		o.UnchangedDocumentDiagnosticReport = &vUnchangedDocumentDiagnosticReport
		return nil
	}
	return fmt.Errorf("invalid WorkspaceFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport: %s", data)
}

type NotebookDocumentFilterWithNotebookOrCells struct {
	Notebook *NotebookDocumentFilterWithNotebook
	Cells    *NotebookDocumentFilterWithCells
}

func (o NotebookDocumentFilterWithNotebookOrCells) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of NotebookDocumentFilterWithNotebookOrCells is set", o.Notebook != nil, o.Cells != nil)

	if o.Notebook != nil {
		return json.Marshal(*o.Notebook)
	}
	if o.Cells != nil {
		return json.Marshal(*o.Cells)
	}
	panic("unreachable")
}

func (o *NotebookDocumentFilterWithNotebookOrCells) UnmarshalJSON(data []byte) error {
	*o = NotebookDocumentFilterWithNotebookOrCells{}

	var vNotebook NotebookDocumentFilterWithNotebook
	if err := json.Unmarshal(data, &vNotebook); err == nil {
		o.Notebook = &vNotebook
		return nil
	}
	var vCells NotebookDocumentFilterWithCells
	if err := json.Unmarshal(data, &vCells); err == nil {
		o.Cells = &vCells
		return nil
	}
	return fmt.Errorf("invalid NotebookDocumentFilterWithNotebookOrCells: %s", data)
}

type StringOrStringValue struct {
	String      *string
	StringValue *StringValue
}

func (o StringOrStringValue) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of StringOrStringValue is set", o.String != nil, o.StringValue != nil)

	if o.String != nil {
		return json.Marshal(*o.String)
	}
	if o.StringValue != nil {
		return json.Marshal(*o.StringValue)
	}
	panic("unreachable")
}

func (o *StringOrStringValue) UnmarshalJSON(data []byte) error {
	*o = StringOrStringValue{}

	var vString string
	if err := json.Unmarshal(data, &vString); err == nil {
		o.String = &vString
		return nil
	}
	var vStringValue StringValue
	if err := json.Unmarshal(data, &vStringValue); err == nil {
		o.StringValue = &vStringValue
		return nil
	}
	return fmt.Errorf("invalid StringOrStringValue: %s", data)
}

type IntegerOrNull struct {
	Integer *int32
}

func (o IntegerOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of IntegerOrNull is set", o.Integer != nil)

	if o.Integer != nil {
		return json.Marshal(*o.Integer)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *IntegerOrNull) UnmarshalJSON(data []byte) error {
	*o = IntegerOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vInteger int32
	if err := json.Unmarshal(data, &vInteger); err == nil {
		o.Integer = &vInteger
		return nil
	}
	return fmt.Errorf("invalid IntegerOrNull: %s", data)
}

type StringOrNull struct {
	String *string
}

func (o StringOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of StringOrNull is set", o.String != nil)

	if o.String != nil {
		return json.Marshal(*o.String)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *StringOrNull) UnmarshalJSON(data []byte) error {
	*o = StringOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vString string
	if err := json.Unmarshal(data, &vString); err == nil {
		o.String = &vString
		return nil
	}
	return fmt.Errorf("invalid StringOrNull: %s", data)
}

type DocumentUriOrNull struct {
	DocumentUri *DocumentUri
}

func (o DocumentUriOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of DocumentUriOrNull is set", o.DocumentUri != nil)

	if o.DocumentUri != nil {
		return json.Marshal(*o.DocumentUri)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *DocumentUriOrNull) UnmarshalJSON(data []byte) error {
	*o = DocumentUriOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vDocumentUri DocumentUri
	if err := json.Unmarshal(data, &vDocumentUri); err == nil {
		o.DocumentUri = &vDocumentUri
		return nil
	}
	return fmt.Errorf("invalid DocumentUriOrNull: %s", data)
}

type WorkspaceFoldersOrNull struct {
	WorkspaceFolders *[]*WorkspaceFolder
}

func (o WorkspaceFoldersOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of WorkspaceFoldersOrNull is set", o.WorkspaceFolders != nil)

	if o.WorkspaceFolders != nil {
		return json.Marshal(*o.WorkspaceFolders)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *WorkspaceFoldersOrNull) UnmarshalJSON(data []byte) error {
	*o = WorkspaceFoldersOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vWorkspaceFolders []*WorkspaceFolder
	if err := json.Unmarshal(data, &vWorkspaceFolders); err == nil {
		o.WorkspaceFolders = &vWorkspaceFolders
		return nil
	}
	return fmt.Errorf("invalid WorkspaceFoldersOrNull: %s", data)
}

type StringOrStrings struct {
	String  *string
	Strings *[]string
}

func (o StringOrStrings) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of StringOrStrings is set", o.String != nil, o.Strings != nil)

	if o.String != nil {
		return json.Marshal(*o.String)
	}
	if o.Strings != nil {
		return json.Marshal(*o.Strings)
	}
	panic("unreachable")
}

func (o *StringOrStrings) UnmarshalJSON(data []byte) error {
	*o = StringOrStrings{}

	var vString string
	if err := json.Unmarshal(data, &vString); err == nil {
		o.String = &vString
		return nil
	}
	var vStrings []string
	if err := json.Unmarshal(data, &vStrings); err == nil {
		o.Strings = &vStrings
		return nil
	}
	return fmt.Errorf("invalid StringOrStrings: %s", data)
}

type TextDocumentContentChangePartialOrWholeDocument struct {
	Partial       *TextDocumentContentChangePartial
	WholeDocument *TextDocumentContentChangeWholeDocument
}

func (o TextDocumentContentChangePartialOrWholeDocument) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of TextDocumentContentChangePartialOrWholeDocument is set", o.Partial != nil, o.WholeDocument != nil)

	if o.Partial != nil {
		return json.Marshal(*o.Partial)
	}
	if o.WholeDocument != nil {
		return json.Marshal(*o.WholeDocument)
	}
	panic("unreachable")
}

func (o *TextDocumentContentChangePartialOrWholeDocument) UnmarshalJSON(data []byte) error {
	*o = TextDocumentContentChangePartialOrWholeDocument{}

	var vPartial TextDocumentContentChangePartial
	if err := json.Unmarshal(data, &vPartial); err == nil {
		o.Partial = &vPartial
		return nil
	}
	var vWholeDocument TextDocumentContentChangeWholeDocument
	if err := json.Unmarshal(data, &vWholeDocument); err == nil {
		o.WholeDocument = &vWholeDocument
		return nil
	}
	return fmt.Errorf("invalid TextDocumentContentChangePartialOrWholeDocument: %s", data)
}

type TextEditOrInsertReplaceEdit struct {
	TextEdit          *TextEdit
	InsertReplaceEdit *InsertReplaceEdit
}

func (o TextEditOrInsertReplaceEdit) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of TextEditOrInsertReplaceEdit is set", o.TextEdit != nil, o.InsertReplaceEdit != nil)

	if o.TextEdit != nil {
		return json.Marshal(*o.TextEdit)
	}
	if o.InsertReplaceEdit != nil {
		return json.Marshal(*o.InsertReplaceEdit)
	}
	panic("unreachable")
}

func (o *TextEditOrInsertReplaceEdit) UnmarshalJSON(data []byte) error {
	*o = TextEditOrInsertReplaceEdit{}

	var vTextEdit TextEdit
	if err := json.Unmarshal(data, &vTextEdit); err == nil {
		o.TextEdit = &vTextEdit
		return nil
	}
	var vInsertReplaceEdit InsertReplaceEdit
	if err := json.Unmarshal(data, &vInsertReplaceEdit); err == nil {
		o.InsertReplaceEdit = &vInsertReplaceEdit
		return nil
	}
	return fmt.Errorf("invalid TextEditOrInsertReplaceEdit: %s", data)
}

type MarkupContentOrStringOrMarkedStringWithLanguageOrMarkedStrings struct {
	MarkupContent            *MarkupContent
	String                   *string
	MarkedStringWithLanguage *MarkedStringWithLanguage
	MarkedStrings            *[]StringOrMarkedStringWithLanguage
}

func (o MarkupContentOrStringOrMarkedStringWithLanguageOrMarkedStrings) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of MarkupContentOrStringOrMarkedStringWithLanguageOrMarkedStrings is set", o.MarkupContent != nil, o.String != nil, o.MarkedStringWithLanguage != nil, o.MarkedStrings != nil)

	if o.MarkupContent != nil {
		return json.Marshal(*o.MarkupContent)
	}
	if o.String != nil {
		return json.Marshal(*o.String)
	}
	if o.MarkedStringWithLanguage != nil {
		return json.Marshal(*o.MarkedStringWithLanguage)
	}
	if o.MarkedStrings != nil {
		return json.Marshal(*o.MarkedStrings)
	}
	panic("unreachable")
}

func (o *MarkupContentOrStringOrMarkedStringWithLanguageOrMarkedStrings) UnmarshalJSON(data []byte) error {
	*o = MarkupContentOrStringOrMarkedStringWithLanguageOrMarkedStrings{}

	var vMarkupContent MarkupContent
	if err := json.Unmarshal(data, &vMarkupContent); err == nil {
		o.MarkupContent = &vMarkupContent
		return nil
	}
	var vString string
	if err := json.Unmarshal(data, &vString); err == nil {
		o.String = &vString
		return nil
	}
	var vMarkedStringWithLanguage MarkedStringWithLanguage
	if err := json.Unmarshal(data, &vMarkedStringWithLanguage); err == nil {
		o.MarkedStringWithLanguage = &vMarkedStringWithLanguage
		return nil
	}
	var vMarkedStrings []StringOrMarkedStringWithLanguage
	if err := json.Unmarshal(data, &vMarkedStrings); err == nil {
		o.MarkedStrings = &vMarkedStrings
		return nil
	}
	return fmt.Errorf("invalid MarkupContentOrStringOrMarkedStringWithLanguageOrMarkedStrings: %s", data)
}

type UintegerOrNull struct {
	Uinteger *uint32
}

func (o UintegerOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of UintegerOrNull is set", o.Uinteger != nil)

	if o.Uinteger != nil {
		return json.Marshal(*o.Uinteger)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *UintegerOrNull) UnmarshalJSON(data []byte) error {
	*o = UintegerOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vUinteger uint32
	if err := json.Unmarshal(data, &vUinteger); err == nil {
		o.Uinteger = &vUinteger
		return nil
	}
	return fmt.Errorf("invalid UintegerOrNull: %s", data)
}

type LocationOrLocationUriOnly struct {
	Location        *Location
	LocationUriOnly *LocationUriOnly
}

func (o LocationOrLocationUriOnly) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of LocationOrLocationUriOnly is set", o.Location != nil, o.LocationUriOnly != nil)

	if o.Location != nil {
		return json.Marshal(*o.Location)
	}
	if o.LocationUriOnly != nil {
		return json.Marshal(*o.LocationUriOnly)
	}
	panic("unreachable")
}

func (o *LocationOrLocationUriOnly) UnmarshalJSON(data []byte) error {
	*o = LocationOrLocationUriOnly{}

	var vLocation Location
	if err := json.Unmarshal(data, &vLocation); err == nil {
		o.Location = &vLocation
		return nil
	}
	var vLocationUriOnly LocationUriOnly
	if err := json.Unmarshal(data, &vLocationUriOnly); err == nil {
		o.LocationUriOnly = &vLocationUriOnly
		return nil
	}
	return fmt.Errorf("invalid LocationOrLocationUriOnly: %s", data)
}

type TextEditOrAnnotatedTextEditOrSnippetTextEdit struct {
	TextEdit          *TextEdit
	AnnotatedTextEdit *AnnotatedTextEdit
	SnippetTextEdit   *SnippetTextEdit
}

func (o TextEditOrAnnotatedTextEditOrSnippetTextEdit) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of TextEditOrAnnotatedTextEditOrSnippetTextEdit is set", o.TextEdit != nil, o.AnnotatedTextEdit != nil, o.SnippetTextEdit != nil)

	if o.TextEdit != nil {
		return json.Marshal(*o.TextEdit)
	}
	if o.AnnotatedTextEdit != nil {
		return json.Marshal(*o.AnnotatedTextEdit)
	}
	if o.SnippetTextEdit != nil {
		return json.Marshal(*o.SnippetTextEdit)
	}
	panic("unreachable")
}

func (o *TextEditOrAnnotatedTextEditOrSnippetTextEdit) UnmarshalJSON(data []byte) error {
	*o = TextEditOrAnnotatedTextEditOrSnippetTextEdit{}

	var vTextEdit TextEdit
	if err := json.Unmarshal(data, &vTextEdit); err == nil {
		o.TextEdit = &vTextEdit
		return nil
	}
	var vAnnotatedTextEdit AnnotatedTextEdit
	if err := json.Unmarshal(data, &vAnnotatedTextEdit); err == nil {
		o.AnnotatedTextEdit = &vAnnotatedTextEdit
		return nil
	}
	var vSnippetTextEdit SnippetTextEdit
	if err := json.Unmarshal(data, &vSnippetTextEdit); err == nil {
		o.SnippetTextEdit = &vSnippetTextEdit
		return nil
	}
	return fmt.Errorf("invalid TextEditOrAnnotatedTextEditOrSnippetTextEdit: %s", data)
}

type TextDocumentSyncOptionsOrKind struct {
	Options *TextDocumentSyncOptions
	Kind    *TextDocumentSyncKind
}

func (o TextDocumentSyncOptionsOrKind) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of TextDocumentSyncOptionsOrKind is set", o.Options != nil, o.Kind != nil)

	if o.Options != nil {
		return json.Marshal(*o.Options)
	}
	if o.Kind != nil {
		return json.Marshal(*o.Kind)
	}
	panic("unreachable")
}

func (o *TextDocumentSyncOptionsOrKind) UnmarshalJSON(data []byte) error {
	*o = TextDocumentSyncOptionsOrKind{}

	var vOptions TextDocumentSyncOptions
	if err := json.Unmarshal(data, &vOptions); err == nil {
		o.Options = &vOptions
		return nil
	}
	var vKind TextDocumentSyncKind
	if err := json.Unmarshal(data, &vKind); err == nil {
		o.Kind = &vKind
		return nil
	}
	return fmt.Errorf("invalid TextDocumentSyncOptionsOrKind: %s", data)
}

type NotebookDocumentSyncOptionsOrRegistrationOptions struct {
	Options             *NotebookDocumentSyncOptions
	RegistrationOptions *NotebookDocumentSyncRegistrationOptions
}

func (o NotebookDocumentSyncOptionsOrRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of NotebookDocumentSyncOptionsOrRegistrationOptions is set", o.Options != nil, o.RegistrationOptions != nil)

	if o.Options != nil {
		return json.Marshal(*o.Options)
	}
	if o.RegistrationOptions != nil {
		return json.Marshal(*o.RegistrationOptions)
	}
	panic("unreachable")
}

func (o *NotebookDocumentSyncOptionsOrRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = NotebookDocumentSyncOptionsOrRegistrationOptions{}

	var vOptions NotebookDocumentSyncOptions
	if err := json.Unmarshal(data, &vOptions); err == nil {
		o.Options = &vOptions
		return nil
	}
	var vRegistrationOptions NotebookDocumentSyncRegistrationOptions
	if err := json.Unmarshal(data, &vRegistrationOptions); err == nil {
		o.RegistrationOptions = &vRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid NotebookDocumentSyncOptionsOrRegistrationOptions: %s", data)
}

type BooleanOrHoverOptions struct {
	Boolean      *bool
	HoverOptions *HoverOptions
}

func (o BooleanOrHoverOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrHoverOptions is set", o.Boolean != nil, o.HoverOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.HoverOptions != nil {
		return json.Marshal(*o.HoverOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrHoverOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrHoverOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vHoverOptions HoverOptions
	if err := json.Unmarshal(data, &vHoverOptions); err == nil {
		o.HoverOptions = &vHoverOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrHoverOptions: %s", data)
}

type BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions struct {
	Boolean                        *bool
	DeclarationOptions             *DeclarationOptions
	DeclarationRegistrationOptions *DeclarationRegistrationOptions
}

func (o BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions is set", o.Boolean != nil, o.DeclarationOptions != nil, o.DeclarationRegistrationOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.DeclarationOptions != nil {
		return json.Marshal(*o.DeclarationOptions)
	}
	if o.DeclarationRegistrationOptions != nil {
		return json.Marshal(*o.DeclarationRegistrationOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vDeclarationOptions DeclarationOptions
	if err := json.Unmarshal(data, &vDeclarationOptions); err == nil {
		o.DeclarationOptions = &vDeclarationOptions
		return nil
	}
	var vDeclarationRegistrationOptions DeclarationRegistrationOptions
	if err := json.Unmarshal(data, &vDeclarationRegistrationOptions); err == nil {
		o.DeclarationRegistrationOptions = &vDeclarationRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrDeclarationOptionsOrDeclarationRegistrationOptions: %s", data)
}

type BooleanOrDefinitionOptions struct {
	Boolean           *bool
	DefinitionOptions *DefinitionOptions
}

func (o BooleanOrDefinitionOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrDefinitionOptions is set", o.Boolean != nil, o.DefinitionOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.DefinitionOptions != nil {
		return json.Marshal(*o.DefinitionOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrDefinitionOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrDefinitionOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vDefinitionOptions DefinitionOptions
	if err := json.Unmarshal(data, &vDefinitionOptions); err == nil {
		o.DefinitionOptions = &vDefinitionOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrDefinitionOptions: %s", data)
}

type BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions struct {
	Boolean                           *bool
	TypeDefinitionOptions             *TypeDefinitionOptions
	TypeDefinitionRegistrationOptions *TypeDefinitionRegistrationOptions
}

func (o BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions is set", o.Boolean != nil, o.TypeDefinitionOptions != nil, o.TypeDefinitionRegistrationOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.TypeDefinitionOptions != nil {
		return json.Marshal(*o.TypeDefinitionOptions)
	}
	if o.TypeDefinitionRegistrationOptions != nil {
		return json.Marshal(*o.TypeDefinitionRegistrationOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vTypeDefinitionOptions TypeDefinitionOptions
	if err := json.Unmarshal(data, &vTypeDefinitionOptions); err == nil {
		o.TypeDefinitionOptions = &vTypeDefinitionOptions
		return nil
	}
	var vTypeDefinitionRegistrationOptions TypeDefinitionRegistrationOptions
	if err := json.Unmarshal(data, &vTypeDefinitionRegistrationOptions); err == nil {
		o.TypeDefinitionRegistrationOptions = &vTypeDefinitionRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrTypeDefinitionOptionsOrTypeDefinitionRegistrationOptions: %s", data)
}

type BooleanOrImplementationOptionsOrImplementationRegistrationOptions struct {
	Boolean                           *bool
	ImplementationOptions             *ImplementationOptions
	ImplementationRegistrationOptions *ImplementationRegistrationOptions
}

func (o BooleanOrImplementationOptionsOrImplementationRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrImplementationOptionsOrImplementationRegistrationOptions is set", o.Boolean != nil, o.ImplementationOptions != nil, o.ImplementationRegistrationOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.ImplementationOptions != nil {
		return json.Marshal(*o.ImplementationOptions)
	}
	if o.ImplementationRegistrationOptions != nil {
		return json.Marshal(*o.ImplementationRegistrationOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrImplementationOptionsOrImplementationRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrImplementationOptionsOrImplementationRegistrationOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vImplementationOptions ImplementationOptions
	if err := json.Unmarshal(data, &vImplementationOptions); err == nil {
		o.ImplementationOptions = &vImplementationOptions
		return nil
	}
	var vImplementationRegistrationOptions ImplementationRegistrationOptions
	if err := json.Unmarshal(data, &vImplementationRegistrationOptions); err == nil {
		o.ImplementationRegistrationOptions = &vImplementationRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrImplementationOptionsOrImplementationRegistrationOptions: %s", data)
}

type BooleanOrReferenceOptions struct {
	Boolean          *bool
	ReferenceOptions *ReferenceOptions
}

func (o BooleanOrReferenceOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrReferenceOptions is set", o.Boolean != nil, o.ReferenceOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.ReferenceOptions != nil {
		return json.Marshal(*o.ReferenceOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrReferenceOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrReferenceOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vReferenceOptions ReferenceOptions
	if err := json.Unmarshal(data, &vReferenceOptions); err == nil {
		o.ReferenceOptions = &vReferenceOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrReferenceOptions: %s", data)
}

type BooleanOrDocumentHighlightOptions struct {
	Boolean                  *bool
	DocumentHighlightOptions *DocumentHighlightOptions
}

func (o BooleanOrDocumentHighlightOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrDocumentHighlightOptions is set", o.Boolean != nil, o.DocumentHighlightOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.DocumentHighlightOptions != nil {
		return json.Marshal(*o.DocumentHighlightOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrDocumentHighlightOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrDocumentHighlightOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vDocumentHighlightOptions DocumentHighlightOptions
	if err := json.Unmarshal(data, &vDocumentHighlightOptions); err == nil {
		o.DocumentHighlightOptions = &vDocumentHighlightOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrDocumentHighlightOptions: %s", data)
}

type BooleanOrDocumentSymbolOptions struct {
	Boolean               *bool
	DocumentSymbolOptions *DocumentSymbolOptions
}

func (o BooleanOrDocumentSymbolOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrDocumentSymbolOptions is set", o.Boolean != nil, o.DocumentSymbolOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.DocumentSymbolOptions != nil {
		return json.Marshal(*o.DocumentSymbolOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrDocumentSymbolOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrDocumentSymbolOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vDocumentSymbolOptions DocumentSymbolOptions
	if err := json.Unmarshal(data, &vDocumentSymbolOptions); err == nil {
		o.DocumentSymbolOptions = &vDocumentSymbolOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrDocumentSymbolOptions: %s", data)
}

type BooleanOrCodeActionOptions struct {
	Boolean           *bool
	CodeActionOptions *CodeActionOptions
}

func (o BooleanOrCodeActionOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrCodeActionOptions is set", o.Boolean != nil, o.CodeActionOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.CodeActionOptions != nil {
		return json.Marshal(*o.CodeActionOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrCodeActionOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrCodeActionOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vCodeActionOptions CodeActionOptions
	if err := json.Unmarshal(data, &vCodeActionOptions); err == nil {
		o.CodeActionOptions = &vCodeActionOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrCodeActionOptions: %s", data)
}

type BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions struct {
	Boolean                          *bool
	DocumentColorOptions             *DocumentColorOptions
	DocumentColorRegistrationOptions *DocumentColorRegistrationOptions
}

func (o BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions is set", o.Boolean != nil, o.DocumentColorOptions != nil, o.DocumentColorRegistrationOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.DocumentColorOptions != nil {
		return json.Marshal(*o.DocumentColorOptions)
	}
	if o.DocumentColorRegistrationOptions != nil {
		return json.Marshal(*o.DocumentColorRegistrationOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vDocumentColorOptions DocumentColorOptions
	if err := json.Unmarshal(data, &vDocumentColorOptions); err == nil {
		o.DocumentColorOptions = &vDocumentColorOptions
		return nil
	}
	var vDocumentColorRegistrationOptions DocumentColorRegistrationOptions
	if err := json.Unmarshal(data, &vDocumentColorRegistrationOptions); err == nil {
		o.DocumentColorRegistrationOptions = &vDocumentColorRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrDocumentColorOptionsOrDocumentColorRegistrationOptions: %s", data)
}

type BooleanOrWorkspaceSymbolOptions struct {
	Boolean                *bool
	WorkspaceSymbolOptions *WorkspaceSymbolOptions
}

func (o BooleanOrWorkspaceSymbolOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrWorkspaceSymbolOptions is set", o.Boolean != nil, o.WorkspaceSymbolOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.WorkspaceSymbolOptions != nil {
		return json.Marshal(*o.WorkspaceSymbolOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrWorkspaceSymbolOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrWorkspaceSymbolOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vWorkspaceSymbolOptions WorkspaceSymbolOptions
	if err := json.Unmarshal(data, &vWorkspaceSymbolOptions); err == nil {
		o.WorkspaceSymbolOptions = &vWorkspaceSymbolOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrWorkspaceSymbolOptions: %s", data)
}

type BooleanOrDocumentFormattingOptions struct {
	Boolean                   *bool
	DocumentFormattingOptions *DocumentFormattingOptions
}

func (o BooleanOrDocumentFormattingOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrDocumentFormattingOptions is set", o.Boolean != nil, o.DocumentFormattingOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.DocumentFormattingOptions != nil {
		return json.Marshal(*o.DocumentFormattingOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrDocumentFormattingOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrDocumentFormattingOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vDocumentFormattingOptions DocumentFormattingOptions
	if err := json.Unmarshal(data, &vDocumentFormattingOptions); err == nil {
		o.DocumentFormattingOptions = &vDocumentFormattingOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrDocumentFormattingOptions: %s", data)
}

type BooleanOrDocumentRangeFormattingOptions struct {
	Boolean                        *bool
	DocumentRangeFormattingOptions *DocumentRangeFormattingOptions
}

func (o BooleanOrDocumentRangeFormattingOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrDocumentRangeFormattingOptions is set", o.Boolean != nil, o.DocumentRangeFormattingOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.DocumentRangeFormattingOptions != nil {
		return json.Marshal(*o.DocumentRangeFormattingOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrDocumentRangeFormattingOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrDocumentRangeFormattingOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vDocumentRangeFormattingOptions DocumentRangeFormattingOptions
	if err := json.Unmarshal(data, &vDocumentRangeFormattingOptions); err == nil {
		o.DocumentRangeFormattingOptions = &vDocumentRangeFormattingOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrDocumentRangeFormattingOptions: %s", data)
}

type BooleanOrRenameOptions struct {
	Boolean       *bool
	RenameOptions *RenameOptions
}

func (o BooleanOrRenameOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrRenameOptions is set", o.Boolean != nil, o.RenameOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.RenameOptions != nil {
		return json.Marshal(*o.RenameOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrRenameOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrRenameOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vRenameOptions RenameOptions
	if err := json.Unmarshal(data, &vRenameOptions); err == nil {
		o.RenameOptions = &vRenameOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrRenameOptions: %s", data)
}

type BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions struct {
	Boolean                         *bool
	FoldingRangeOptions             *FoldingRangeOptions
	FoldingRangeRegistrationOptions *FoldingRangeRegistrationOptions
}

func (o BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions is set", o.Boolean != nil, o.FoldingRangeOptions != nil, o.FoldingRangeRegistrationOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.FoldingRangeOptions != nil {
		return json.Marshal(*o.FoldingRangeOptions)
	}
	if o.FoldingRangeRegistrationOptions != nil {
		return json.Marshal(*o.FoldingRangeRegistrationOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vFoldingRangeOptions FoldingRangeOptions
	if err := json.Unmarshal(data, &vFoldingRangeOptions); err == nil {
		o.FoldingRangeOptions = &vFoldingRangeOptions
		return nil
	}
	var vFoldingRangeRegistrationOptions FoldingRangeRegistrationOptions
	if err := json.Unmarshal(data, &vFoldingRangeRegistrationOptions); err == nil {
		o.FoldingRangeRegistrationOptions = &vFoldingRangeRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrFoldingRangeOptionsOrFoldingRangeRegistrationOptions: %s", data)
}

type BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions struct {
	Boolean                           *bool
	SelectionRangeOptions             *SelectionRangeOptions
	SelectionRangeRegistrationOptions *SelectionRangeRegistrationOptions
}

func (o BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions is set", o.Boolean != nil, o.SelectionRangeOptions != nil, o.SelectionRangeRegistrationOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.SelectionRangeOptions != nil {
		return json.Marshal(*o.SelectionRangeOptions)
	}
	if o.SelectionRangeRegistrationOptions != nil {
		return json.Marshal(*o.SelectionRangeRegistrationOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vSelectionRangeOptions SelectionRangeOptions
	if err := json.Unmarshal(data, &vSelectionRangeOptions); err == nil {
		o.SelectionRangeOptions = &vSelectionRangeOptions
		return nil
	}
	var vSelectionRangeRegistrationOptions SelectionRangeRegistrationOptions
	if err := json.Unmarshal(data, &vSelectionRangeRegistrationOptions); err == nil {
		o.SelectionRangeRegistrationOptions = &vSelectionRangeRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrSelectionRangeOptionsOrSelectionRangeRegistrationOptions: %s", data)
}

type BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions struct {
	Boolean                          *bool
	CallHierarchyOptions             *CallHierarchyOptions
	CallHierarchyRegistrationOptions *CallHierarchyRegistrationOptions
}

func (o BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions is set", o.Boolean != nil, o.CallHierarchyOptions != nil, o.CallHierarchyRegistrationOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.CallHierarchyOptions != nil {
		return json.Marshal(*o.CallHierarchyOptions)
	}
	if o.CallHierarchyRegistrationOptions != nil {
		return json.Marshal(*o.CallHierarchyRegistrationOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vCallHierarchyOptions CallHierarchyOptions
	if err := json.Unmarshal(data, &vCallHierarchyOptions); err == nil {
		o.CallHierarchyOptions = &vCallHierarchyOptions
		return nil
	}
	var vCallHierarchyRegistrationOptions CallHierarchyRegistrationOptions
	if err := json.Unmarshal(data, &vCallHierarchyRegistrationOptions); err == nil {
		o.CallHierarchyRegistrationOptions = &vCallHierarchyRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrCallHierarchyOptionsOrCallHierarchyRegistrationOptions: %s", data)
}

type BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions struct {
	Boolean                               *bool
	LinkedEditingRangeOptions             *LinkedEditingRangeOptions
	LinkedEditingRangeRegistrationOptions *LinkedEditingRangeRegistrationOptions
}

func (o BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions is set", o.Boolean != nil, o.LinkedEditingRangeOptions != nil, o.LinkedEditingRangeRegistrationOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.LinkedEditingRangeOptions != nil {
		return json.Marshal(*o.LinkedEditingRangeOptions)
	}
	if o.LinkedEditingRangeRegistrationOptions != nil {
		return json.Marshal(*o.LinkedEditingRangeRegistrationOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vLinkedEditingRangeOptions LinkedEditingRangeOptions
	if err := json.Unmarshal(data, &vLinkedEditingRangeOptions); err == nil {
		o.LinkedEditingRangeOptions = &vLinkedEditingRangeOptions
		return nil
	}
	var vLinkedEditingRangeRegistrationOptions LinkedEditingRangeRegistrationOptions
	if err := json.Unmarshal(data, &vLinkedEditingRangeRegistrationOptions); err == nil {
		o.LinkedEditingRangeRegistrationOptions = &vLinkedEditingRangeRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrLinkedEditingRangeOptionsOrLinkedEditingRangeRegistrationOptions: %s", data)
}

type SemanticTokensOptionsOrRegistrationOptions struct {
	Options             *SemanticTokensOptions
	RegistrationOptions *SemanticTokensRegistrationOptions
}

func (o SemanticTokensOptionsOrRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of SemanticTokensOptionsOrRegistrationOptions is set", o.Options != nil, o.RegistrationOptions != nil)

	if o.Options != nil {
		return json.Marshal(*o.Options)
	}
	if o.RegistrationOptions != nil {
		return json.Marshal(*o.RegistrationOptions)
	}
	panic("unreachable")
}

func (o *SemanticTokensOptionsOrRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = SemanticTokensOptionsOrRegistrationOptions{}

	var vOptions SemanticTokensOptions
	if err := json.Unmarshal(data, &vOptions); err == nil {
		o.Options = &vOptions
		return nil
	}
	var vRegistrationOptions SemanticTokensRegistrationOptions
	if err := json.Unmarshal(data, &vRegistrationOptions); err == nil {
		o.RegistrationOptions = &vRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid SemanticTokensOptionsOrRegistrationOptions: %s", data)
}

type BooleanOrMonikerOptionsOrMonikerRegistrationOptions struct {
	Boolean                    *bool
	MonikerOptions             *MonikerOptions
	MonikerRegistrationOptions *MonikerRegistrationOptions
}

func (o BooleanOrMonikerOptionsOrMonikerRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrMonikerOptionsOrMonikerRegistrationOptions is set", o.Boolean != nil, o.MonikerOptions != nil, o.MonikerRegistrationOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.MonikerOptions != nil {
		return json.Marshal(*o.MonikerOptions)
	}
	if o.MonikerRegistrationOptions != nil {
		return json.Marshal(*o.MonikerRegistrationOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrMonikerOptionsOrMonikerRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrMonikerOptionsOrMonikerRegistrationOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vMonikerOptions MonikerOptions
	if err := json.Unmarshal(data, &vMonikerOptions); err == nil {
		o.MonikerOptions = &vMonikerOptions
		return nil
	}
	var vMonikerRegistrationOptions MonikerRegistrationOptions
	if err := json.Unmarshal(data, &vMonikerRegistrationOptions); err == nil {
		o.MonikerRegistrationOptions = &vMonikerRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrMonikerOptionsOrMonikerRegistrationOptions: %s", data)
}

type BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions struct {
	Boolean                          *bool
	TypeHierarchyOptions             *TypeHierarchyOptions
	TypeHierarchyRegistrationOptions *TypeHierarchyRegistrationOptions
}

func (o BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions is set", o.Boolean != nil, o.TypeHierarchyOptions != nil, o.TypeHierarchyRegistrationOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.TypeHierarchyOptions != nil {
		return json.Marshal(*o.TypeHierarchyOptions)
	}
	if o.TypeHierarchyRegistrationOptions != nil {
		return json.Marshal(*o.TypeHierarchyRegistrationOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vTypeHierarchyOptions TypeHierarchyOptions
	if err := json.Unmarshal(data, &vTypeHierarchyOptions); err == nil {
		o.TypeHierarchyOptions = &vTypeHierarchyOptions
		return nil
	}
	var vTypeHierarchyRegistrationOptions TypeHierarchyRegistrationOptions
	if err := json.Unmarshal(data, &vTypeHierarchyRegistrationOptions); err == nil {
		o.TypeHierarchyRegistrationOptions = &vTypeHierarchyRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrTypeHierarchyOptionsOrTypeHierarchyRegistrationOptions: %s", data)
}

type BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions struct {
	Boolean                        *bool
	InlineValueOptions             *InlineValueOptions
	InlineValueRegistrationOptions *InlineValueRegistrationOptions
}

func (o BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions is set", o.Boolean != nil, o.InlineValueOptions != nil, o.InlineValueRegistrationOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.InlineValueOptions != nil {
		return json.Marshal(*o.InlineValueOptions)
	}
	if o.InlineValueRegistrationOptions != nil {
		return json.Marshal(*o.InlineValueRegistrationOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vInlineValueOptions InlineValueOptions
	if err := json.Unmarshal(data, &vInlineValueOptions); err == nil {
		o.InlineValueOptions = &vInlineValueOptions
		return nil
	}
	var vInlineValueRegistrationOptions InlineValueRegistrationOptions
	if err := json.Unmarshal(data, &vInlineValueRegistrationOptions); err == nil {
		o.InlineValueRegistrationOptions = &vInlineValueRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrInlineValueOptionsOrInlineValueRegistrationOptions: %s", data)
}

type BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions struct {
	Boolean                      *bool
	InlayHintOptions             *InlayHintOptions
	InlayHintRegistrationOptions *InlayHintRegistrationOptions
}

func (o BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions is set", o.Boolean != nil, o.InlayHintOptions != nil, o.InlayHintRegistrationOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.InlayHintOptions != nil {
		return json.Marshal(*o.InlayHintOptions)
	}
	if o.InlayHintRegistrationOptions != nil {
		return json.Marshal(*o.InlayHintRegistrationOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vInlayHintOptions InlayHintOptions
	if err := json.Unmarshal(data, &vInlayHintOptions); err == nil {
		o.InlayHintOptions = &vInlayHintOptions
		return nil
	}
	var vInlayHintRegistrationOptions InlayHintRegistrationOptions
	if err := json.Unmarshal(data, &vInlayHintRegistrationOptions); err == nil {
		o.InlayHintRegistrationOptions = &vInlayHintRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrInlayHintOptionsOrInlayHintRegistrationOptions: %s", data)
}

type DiagnosticOptionsOrRegistrationOptions struct {
	Options             *DiagnosticOptions
	RegistrationOptions *DiagnosticRegistrationOptions
}

func (o DiagnosticOptionsOrRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of DiagnosticOptionsOrRegistrationOptions is set", o.Options != nil, o.RegistrationOptions != nil)

	if o.Options != nil {
		return json.Marshal(*o.Options)
	}
	if o.RegistrationOptions != nil {
		return json.Marshal(*o.RegistrationOptions)
	}
	panic("unreachable")
}

func (o *DiagnosticOptionsOrRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = DiagnosticOptionsOrRegistrationOptions{}

	var vOptions DiagnosticOptions
	if err := json.Unmarshal(data, &vOptions); err == nil {
		o.Options = &vOptions
		return nil
	}
	var vRegistrationOptions DiagnosticRegistrationOptions
	if err := json.Unmarshal(data, &vRegistrationOptions); err == nil {
		o.RegistrationOptions = &vRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid DiagnosticOptionsOrRegistrationOptions: %s", data)
}

type BooleanOrInlineCompletionOptions struct {
	Boolean                 *bool
	InlineCompletionOptions *InlineCompletionOptions
}

func (o BooleanOrInlineCompletionOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrInlineCompletionOptions is set", o.Boolean != nil, o.InlineCompletionOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.InlineCompletionOptions != nil {
		return json.Marshal(*o.InlineCompletionOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrInlineCompletionOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrInlineCompletionOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vInlineCompletionOptions InlineCompletionOptions
	if err := json.Unmarshal(data, &vInlineCompletionOptions); err == nil {
		o.InlineCompletionOptions = &vInlineCompletionOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrInlineCompletionOptions: %s", data)
}

type PatternOrRelativePattern struct {
	Pattern         *string
	RelativePattern *RelativePattern
}

func (o PatternOrRelativePattern) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of PatternOrRelativePattern is set", o.Pattern != nil, o.RelativePattern != nil)

	if o.Pattern != nil {
		return json.Marshal(*o.Pattern)
	}
	if o.RelativePattern != nil {
		return json.Marshal(*o.RelativePattern)
	}
	panic("unreachable")
}

func (o *PatternOrRelativePattern) UnmarshalJSON(data []byte) error {
	*o = PatternOrRelativePattern{}

	var vPattern string
	if err := json.Unmarshal(data, &vPattern); err == nil {
		o.Pattern = &vPattern
		return nil
	}
	var vRelativePattern RelativePattern
	if err := json.Unmarshal(data, &vRelativePattern); err == nil {
		o.RelativePattern = &vRelativePattern
		return nil
	}
	return fmt.Errorf("invalid PatternOrRelativePattern: %s", data)
}

type RangeOrEditRangeWithInsertReplace struct {
	Range                      *Range
	EditRangeWithInsertReplace *EditRangeWithInsertReplace
}

func (o RangeOrEditRangeWithInsertReplace) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of RangeOrEditRangeWithInsertReplace is set", o.Range != nil, o.EditRangeWithInsertReplace != nil)

	if o.Range != nil {
		return json.Marshal(*o.Range)
	}
	if o.EditRangeWithInsertReplace != nil {
		return json.Marshal(*o.EditRangeWithInsertReplace)
	}
	panic("unreachable")
}

func (o *RangeOrEditRangeWithInsertReplace) UnmarshalJSON(data []byte) error {
	*o = RangeOrEditRangeWithInsertReplace{}

	var vRange Range
	if err := json.Unmarshal(data, &vRange); err == nil {
		o.Range = &vRange
		return nil
	}
	var vEditRangeWithInsertReplace EditRangeWithInsertReplace
	if err := json.Unmarshal(data, &vEditRangeWithInsertReplace); err == nil {
		o.EditRangeWithInsertReplace = &vEditRangeWithInsertReplace
		return nil
	}
	return fmt.Errorf("invalid RangeOrEditRangeWithInsertReplace: %s", data)
}

type StringOrNotebookDocumentFilterNotebookTypeOrNotebookDocumentFilterSchemeOrNotebookDocumentFilterPattern struct {
	String                             *string
	NotebookDocumentFilterNotebookType *NotebookDocumentFilterNotebookType
	NotebookDocumentFilterScheme       *NotebookDocumentFilterScheme
	NotebookDocumentFilterPattern      *NotebookDocumentFilterPattern
}

func (o StringOrNotebookDocumentFilterNotebookTypeOrNotebookDocumentFilterSchemeOrNotebookDocumentFilterPattern) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of StringOrNotebookDocumentFilterNotebookTypeOrNotebookDocumentFilterSchemeOrNotebookDocumentFilterPattern is set", o.String != nil, o.NotebookDocumentFilterNotebookType != nil, o.NotebookDocumentFilterScheme != nil, o.NotebookDocumentFilterPattern != nil)

	if o.String != nil {
		return json.Marshal(*o.String)
	}
	if o.NotebookDocumentFilterNotebookType != nil {
		return json.Marshal(*o.NotebookDocumentFilterNotebookType)
	}
	if o.NotebookDocumentFilterScheme != nil {
		return json.Marshal(*o.NotebookDocumentFilterScheme)
	}
	if o.NotebookDocumentFilterPattern != nil {
		return json.Marshal(*o.NotebookDocumentFilterPattern)
	}
	panic("unreachable")
}

func (o *StringOrNotebookDocumentFilterNotebookTypeOrNotebookDocumentFilterSchemeOrNotebookDocumentFilterPattern) UnmarshalJSON(data []byte) error {
	*o = StringOrNotebookDocumentFilterNotebookTypeOrNotebookDocumentFilterSchemeOrNotebookDocumentFilterPattern{}

	var vString string
	if err := json.Unmarshal(data, &vString); err == nil {
		o.String = &vString
		return nil
	}
	var vNotebookDocumentFilterNotebookType NotebookDocumentFilterNotebookType
	if err := json.Unmarshal(data, &vNotebookDocumentFilterNotebookType); err == nil {
		o.NotebookDocumentFilterNotebookType = &vNotebookDocumentFilterNotebookType
		return nil
	}
	var vNotebookDocumentFilterScheme NotebookDocumentFilterScheme
	if err := json.Unmarshal(data, &vNotebookDocumentFilterScheme); err == nil {
		o.NotebookDocumentFilterScheme = &vNotebookDocumentFilterScheme
		return nil
	}
	var vNotebookDocumentFilterPattern NotebookDocumentFilterPattern
	if err := json.Unmarshal(data, &vNotebookDocumentFilterPattern); err == nil {
		o.NotebookDocumentFilterPattern = &vNotebookDocumentFilterPattern
		return nil
	}
	return fmt.Errorf("invalid StringOrNotebookDocumentFilterNotebookTypeOrNotebookDocumentFilterSchemeOrNotebookDocumentFilterPattern: %s", data)
}

type BooleanOrSaveOptions struct {
	Boolean     *bool
	SaveOptions *SaveOptions
}

func (o BooleanOrSaveOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrSaveOptions is set", o.Boolean != nil, o.SaveOptions != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.SaveOptions != nil {
		return json.Marshal(*o.SaveOptions)
	}
	panic("unreachable")
}

func (o *BooleanOrSaveOptions) UnmarshalJSON(data []byte) error {
	*o = BooleanOrSaveOptions{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vSaveOptions SaveOptions
	if err := json.Unmarshal(data, &vSaveOptions); err == nil {
		o.SaveOptions = &vSaveOptions
		return nil
	}
	return fmt.Errorf("invalid BooleanOrSaveOptions: %s", data)
}

type TextDocumentContentOptionsOrRegistrationOptions struct {
	Options             *TextDocumentContentOptions
	RegistrationOptions *TextDocumentContentRegistrationOptions
}

func (o TextDocumentContentOptionsOrRegistrationOptions) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of TextDocumentContentOptionsOrRegistrationOptions is set", o.Options != nil, o.RegistrationOptions != nil)

	if o.Options != nil {
		return json.Marshal(*o.Options)
	}
	if o.RegistrationOptions != nil {
		return json.Marshal(*o.RegistrationOptions)
	}
	panic("unreachable")
}

func (o *TextDocumentContentOptionsOrRegistrationOptions) UnmarshalJSON(data []byte) error {
	*o = TextDocumentContentOptionsOrRegistrationOptions{}

	var vOptions TextDocumentContentOptions
	if err := json.Unmarshal(data, &vOptions); err == nil {
		o.Options = &vOptions
		return nil
	}
	var vRegistrationOptions TextDocumentContentRegistrationOptions
	if err := json.Unmarshal(data, &vRegistrationOptions); err == nil {
		o.RegistrationOptions = &vRegistrationOptions
		return nil
	}
	return fmt.Errorf("invalid TextDocumentContentOptionsOrRegistrationOptions: %s", data)
}

type StringOrTuple struct {
	String *string
	Tuple  *[2]uint32
}

func (o StringOrTuple) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of StringOrTuple is set", o.String != nil, o.Tuple != nil)

	if o.String != nil {
		return json.Marshal(*o.String)
	}
	if o.Tuple != nil {
		return json.Marshal(*o.Tuple)
	}
	panic("unreachable")
}

func (o *StringOrTuple) UnmarshalJSON(data []byte) error {
	*o = StringOrTuple{}

	var vString string
	if err := json.Unmarshal(data, &vString); err == nil {
		o.String = &vString
		return nil
	}
	var vTuple [2]uint32
	if err := json.Unmarshal(data, &vTuple); err == nil {
		o.Tuple = &vTuple
		return nil
	}
	return fmt.Errorf("invalid StringOrTuple: %s", data)
}

type StringOrBoolean struct {
	String  *string
	Boolean *bool
}

func (o StringOrBoolean) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of StringOrBoolean is set", o.String != nil, o.Boolean != nil)

	if o.String != nil {
		return json.Marshal(*o.String)
	}
	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	panic("unreachable")
}

func (o *StringOrBoolean) UnmarshalJSON(data []byte) error {
	*o = StringOrBoolean{}

	var vString string
	if err := json.Unmarshal(data, &vString); err == nil {
		o.String = &vString
		return nil
	}
	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	return fmt.Errorf("invalid StringOrBoolean: %s", data)
}

type WorkspaceFolderOrURI struct {
	WorkspaceFolder *WorkspaceFolder
	URI             *URI
}

func (o WorkspaceFolderOrURI) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of WorkspaceFolderOrURI is set", o.WorkspaceFolder != nil, o.URI != nil)

	if o.WorkspaceFolder != nil {
		return json.Marshal(*o.WorkspaceFolder)
	}
	if o.URI != nil {
		return json.Marshal(*o.URI)
	}
	panic("unreachable")
}

func (o *WorkspaceFolderOrURI) UnmarshalJSON(data []byte) error {
	*o = WorkspaceFolderOrURI{}

	var vWorkspaceFolder WorkspaceFolder
	if err := json.Unmarshal(data, &vWorkspaceFolder); err == nil {
		o.WorkspaceFolder = &vWorkspaceFolder
		return nil
	}
	var vURI URI
	if err := json.Unmarshal(data, &vURI); err == nil {
		o.URI = &vURI
		return nil
	}
	return fmt.Errorf("invalid WorkspaceFolderOrURI: %s", data)
}

type BooleanOrClientSemanticTokensRequestFullDelta struct {
	Boolean                              *bool
	ClientSemanticTokensRequestFullDelta *ClientSemanticTokensRequestFullDelta
}

func (o BooleanOrClientSemanticTokensRequestFullDelta) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of BooleanOrClientSemanticTokensRequestFullDelta is set", o.Boolean != nil, o.ClientSemanticTokensRequestFullDelta != nil)

	if o.Boolean != nil {
		return json.Marshal(*o.Boolean)
	}
	if o.ClientSemanticTokensRequestFullDelta != nil {
		return json.Marshal(*o.ClientSemanticTokensRequestFullDelta)
	}
	panic("unreachable")
}

func (o *BooleanOrClientSemanticTokensRequestFullDelta) UnmarshalJSON(data []byte) error {
	*o = BooleanOrClientSemanticTokensRequestFullDelta{}

	var vBoolean bool
	if err := json.Unmarshal(data, &vBoolean); err == nil {
		o.Boolean = &vBoolean
		return nil
	}
	var vClientSemanticTokensRequestFullDelta ClientSemanticTokensRequestFullDelta
	if err := json.Unmarshal(data, &vClientSemanticTokensRequestFullDelta); err == nil {
		o.ClientSemanticTokensRequestFullDelta = &vClientSemanticTokensRequestFullDelta
		return nil
	}
	return fmt.Errorf("invalid BooleanOrClientSemanticTokensRequestFullDelta: %s", data)
}

type LocationOrLocationsOrDefinitionLinksOrNull struct {
	Location        *Location
	Locations       *[]Location
	DefinitionLinks *[]*LocationLink
}

func (o LocationOrLocationsOrDefinitionLinksOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of LocationOrLocationsOrDefinitionLinksOrNull is set", o.Location != nil, o.Locations != nil, o.DefinitionLinks != nil)

	if o.Location != nil {
		return json.Marshal(*o.Location)
	}
	if o.Locations != nil {
		return json.Marshal(*o.Locations)
	}
	if o.DefinitionLinks != nil {
		return json.Marshal(*o.DefinitionLinks)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *LocationOrLocationsOrDefinitionLinksOrNull) UnmarshalJSON(data []byte) error {
	*o = LocationOrLocationsOrDefinitionLinksOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vLocation Location
	if err := json.Unmarshal(data, &vLocation); err == nil {
		o.Location = &vLocation
		return nil
	}
	var vLocations []Location
	if err := json.Unmarshal(data, &vLocations); err == nil {
		o.Locations = &vLocations
		return nil
	}
	var vDefinitionLinks []*LocationLink
	if err := json.Unmarshal(data, &vDefinitionLinks); err == nil {
		o.DefinitionLinks = &vDefinitionLinks
		return nil
	}
	return fmt.Errorf("invalid LocationOrLocationsOrDefinitionLinksOrNull: %s", data)
}

type FoldingRangesOrNull struct {
	FoldingRanges *[]*FoldingRange
}

func (o FoldingRangesOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of FoldingRangesOrNull is set", o.FoldingRanges != nil)

	if o.FoldingRanges != nil {
		return json.Marshal(*o.FoldingRanges)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *FoldingRangesOrNull) UnmarshalJSON(data []byte) error {
	*o = FoldingRangesOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vFoldingRanges []*FoldingRange
	if err := json.Unmarshal(data, &vFoldingRanges); err == nil {
		o.FoldingRanges = &vFoldingRanges
		return nil
	}
	return fmt.Errorf("invalid FoldingRangesOrNull: %s", data)
}

type LocationOrLocationsOrDeclarationLinksOrNull struct {
	Location         *Location
	Locations        *[]Location
	DeclarationLinks *[]*LocationLink
}

func (o LocationOrLocationsOrDeclarationLinksOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of LocationOrLocationsOrDeclarationLinksOrNull is set", o.Location != nil, o.Locations != nil, o.DeclarationLinks != nil)

	if o.Location != nil {
		return json.Marshal(*o.Location)
	}
	if o.Locations != nil {
		return json.Marshal(*o.Locations)
	}
	if o.DeclarationLinks != nil {
		return json.Marshal(*o.DeclarationLinks)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *LocationOrLocationsOrDeclarationLinksOrNull) UnmarshalJSON(data []byte) error {
	*o = LocationOrLocationsOrDeclarationLinksOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vLocation Location
	if err := json.Unmarshal(data, &vLocation); err == nil {
		o.Location = &vLocation
		return nil
	}
	var vLocations []Location
	if err := json.Unmarshal(data, &vLocations); err == nil {
		o.Locations = &vLocations
		return nil
	}
	var vDeclarationLinks []*LocationLink
	if err := json.Unmarshal(data, &vDeclarationLinks); err == nil {
		o.DeclarationLinks = &vDeclarationLinks
		return nil
	}
	return fmt.Errorf("invalid LocationOrLocationsOrDeclarationLinksOrNull: %s", data)
}

type SelectionRangesOrNull struct {
	SelectionRanges *[]*SelectionRange
}

func (o SelectionRangesOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of SelectionRangesOrNull is set", o.SelectionRanges != nil)

	if o.SelectionRanges != nil {
		return json.Marshal(*o.SelectionRanges)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *SelectionRangesOrNull) UnmarshalJSON(data []byte) error {
	*o = SelectionRangesOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vSelectionRanges []*SelectionRange
	if err := json.Unmarshal(data, &vSelectionRanges); err == nil {
		o.SelectionRanges = &vSelectionRanges
		return nil
	}
	return fmt.Errorf("invalid SelectionRangesOrNull: %s", data)
}

type CallHierarchyItemsOrNull struct {
	CallHierarchyItems *[]*CallHierarchyItem
}

func (o CallHierarchyItemsOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of CallHierarchyItemsOrNull is set", o.CallHierarchyItems != nil)

	if o.CallHierarchyItems != nil {
		return json.Marshal(*o.CallHierarchyItems)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *CallHierarchyItemsOrNull) UnmarshalJSON(data []byte) error {
	*o = CallHierarchyItemsOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vCallHierarchyItems []*CallHierarchyItem
	if err := json.Unmarshal(data, &vCallHierarchyItems); err == nil {
		o.CallHierarchyItems = &vCallHierarchyItems
		return nil
	}
	return fmt.Errorf("invalid CallHierarchyItemsOrNull: %s", data)
}

type CallHierarchyIncomingCallsOrNull struct {
	CallHierarchyIncomingCalls *[]*CallHierarchyIncomingCall
}

func (o CallHierarchyIncomingCallsOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of CallHierarchyIncomingCallsOrNull is set", o.CallHierarchyIncomingCalls != nil)

	if o.CallHierarchyIncomingCalls != nil {
		return json.Marshal(*o.CallHierarchyIncomingCalls)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *CallHierarchyIncomingCallsOrNull) UnmarshalJSON(data []byte) error {
	*o = CallHierarchyIncomingCallsOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vCallHierarchyIncomingCalls []*CallHierarchyIncomingCall
	if err := json.Unmarshal(data, &vCallHierarchyIncomingCalls); err == nil {
		o.CallHierarchyIncomingCalls = &vCallHierarchyIncomingCalls
		return nil
	}
	return fmt.Errorf("invalid CallHierarchyIncomingCallsOrNull: %s", data)
}

type CallHierarchyOutgoingCallsOrNull struct {
	CallHierarchyOutgoingCalls *[]*CallHierarchyOutgoingCall
}

func (o CallHierarchyOutgoingCallsOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of CallHierarchyOutgoingCallsOrNull is set", o.CallHierarchyOutgoingCalls != nil)

	if o.CallHierarchyOutgoingCalls != nil {
		return json.Marshal(*o.CallHierarchyOutgoingCalls)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *CallHierarchyOutgoingCallsOrNull) UnmarshalJSON(data []byte) error {
	*o = CallHierarchyOutgoingCallsOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vCallHierarchyOutgoingCalls []*CallHierarchyOutgoingCall
	if err := json.Unmarshal(data, &vCallHierarchyOutgoingCalls); err == nil {
		o.CallHierarchyOutgoingCalls = &vCallHierarchyOutgoingCalls
		return nil
	}
	return fmt.Errorf("invalid CallHierarchyOutgoingCallsOrNull: %s", data)
}

type SemanticTokensOrNull struct {
	SemanticTokens *SemanticTokens
}

func (o SemanticTokensOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of SemanticTokensOrNull is set", o.SemanticTokens != nil)

	if o.SemanticTokens != nil {
		return json.Marshal(*o.SemanticTokens)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *SemanticTokensOrNull) UnmarshalJSON(data []byte) error {
	*o = SemanticTokensOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vSemanticTokens SemanticTokens
	if err := json.Unmarshal(data, &vSemanticTokens); err == nil {
		o.SemanticTokens = &vSemanticTokens
		return nil
	}
	return fmt.Errorf("invalid SemanticTokensOrNull: %s", data)
}

type SemanticTokensOrSemanticTokensDeltaOrNull struct {
	SemanticTokens      *SemanticTokens
	SemanticTokensDelta *SemanticTokensDelta
}

func (o SemanticTokensOrSemanticTokensDeltaOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of SemanticTokensOrSemanticTokensDeltaOrNull is set", o.SemanticTokens != nil, o.SemanticTokensDelta != nil)

	if o.SemanticTokens != nil {
		return json.Marshal(*o.SemanticTokens)
	}
	if o.SemanticTokensDelta != nil {
		return json.Marshal(*o.SemanticTokensDelta)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *SemanticTokensOrSemanticTokensDeltaOrNull) UnmarshalJSON(data []byte) error {
	*o = SemanticTokensOrSemanticTokensDeltaOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vSemanticTokens SemanticTokens
	if err := json.Unmarshal(data, &vSemanticTokens); err == nil {
		o.SemanticTokens = &vSemanticTokens
		return nil
	}
	var vSemanticTokensDelta SemanticTokensDelta
	if err := json.Unmarshal(data, &vSemanticTokensDelta); err == nil {
		o.SemanticTokensDelta = &vSemanticTokensDelta
		return nil
	}
	return fmt.Errorf("invalid SemanticTokensOrSemanticTokensDeltaOrNull: %s", data)
}

type LinkedEditingRangesOrNull struct {
	LinkedEditingRanges *LinkedEditingRanges
}

func (o LinkedEditingRangesOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of LinkedEditingRangesOrNull is set", o.LinkedEditingRanges != nil)

	if o.LinkedEditingRanges != nil {
		return json.Marshal(*o.LinkedEditingRanges)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *LinkedEditingRangesOrNull) UnmarshalJSON(data []byte) error {
	*o = LinkedEditingRangesOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vLinkedEditingRanges LinkedEditingRanges
	if err := json.Unmarshal(data, &vLinkedEditingRanges); err == nil {
		o.LinkedEditingRanges = &vLinkedEditingRanges
		return nil
	}
	return fmt.Errorf("invalid LinkedEditingRangesOrNull: %s", data)
}

type WorkspaceEditOrNull struct {
	WorkspaceEdit *WorkspaceEdit
}

func (o WorkspaceEditOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of WorkspaceEditOrNull is set", o.WorkspaceEdit != nil)

	if o.WorkspaceEdit != nil {
		return json.Marshal(*o.WorkspaceEdit)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *WorkspaceEditOrNull) UnmarshalJSON(data []byte) error {
	*o = WorkspaceEditOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vWorkspaceEdit WorkspaceEdit
	if err := json.Unmarshal(data, &vWorkspaceEdit); err == nil {
		o.WorkspaceEdit = &vWorkspaceEdit
		return nil
	}
	return fmt.Errorf("invalid WorkspaceEditOrNull: %s", data)
}

type MonikersOrNull struct {
	Monikers *[]*Moniker
}

func (o MonikersOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of MonikersOrNull is set", o.Monikers != nil)

	if o.Monikers != nil {
		return json.Marshal(*o.Monikers)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *MonikersOrNull) UnmarshalJSON(data []byte) error {
	*o = MonikersOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vMonikers []*Moniker
	if err := json.Unmarshal(data, &vMonikers); err == nil {
		o.Monikers = &vMonikers
		return nil
	}
	return fmt.Errorf("invalid MonikersOrNull: %s", data)
}

type TypeHierarchyItemsOrNull struct {
	TypeHierarchyItems *[]*TypeHierarchyItem
}

func (o TypeHierarchyItemsOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of TypeHierarchyItemsOrNull is set", o.TypeHierarchyItems != nil)

	if o.TypeHierarchyItems != nil {
		return json.Marshal(*o.TypeHierarchyItems)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *TypeHierarchyItemsOrNull) UnmarshalJSON(data []byte) error {
	*o = TypeHierarchyItemsOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vTypeHierarchyItems []*TypeHierarchyItem
	if err := json.Unmarshal(data, &vTypeHierarchyItems); err == nil {
		o.TypeHierarchyItems = &vTypeHierarchyItems
		return nil
	}
	return fmt.Errorf("invalid TypeHierarchyItemsOrNull: %s", data)
}

type InlineValuesOrNull struct {
	InlineValues *[]InlineValueTextOrVariableLookupOrEvaluatableExpression
}

func (o InlineValuesOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of InlineValuesOrNull is set", o.InlineValues != nil)

	if o.InlineValues != nil {
		return json.Marshal(*o.InlineValues)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *InlineValuesOrNull) UnmarshalJSON(data []byte) error {
	*o = InlineValuesOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vInlineValues []InlineValueTextOrVariableLookupOrEvaluatableExpression
	if err := json.Unmarshal(data, &vInlineValues); err == nil {
		o.InlineValues = &vInlineValues
		return nil
	}
	return fmt.Errorf("invalid InlineValuesOrNull: %s", data)
}

type InlayHintsOrNull struct {
	InlayHints *[]*InlayHint
}

func (o InlayHintsOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of InlayHintsOrNull is set", o.InlayHints != nil)

	if o.InlayHints != nil {
		return json.Marshal(*o.InlayHints)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *InlayHintsOrNull) UnmarshalJSON(data []byte) error {
	*o = InlayHintsOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vInlayHints []*InlayHint
	if err := json.Unmarshal(data, &vInlayHints); err == nil {
		o.InlayHints = &vInlayHints
		return nil
	}
	return fmt.Errorf("invalid InlayHintsOrNull: %s", data)
}

type RelatedFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport struct {
	FullDocumentDiagnosticReport      *RelatedFullDocumentDiagnosticReport
	UnchangedDocumentDiagnosticReport *RelatedUnchangedDocumentDiagnosticReport
}

func (o RelatedFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of RelatedFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport is set", o.FullDocumentDiagnosticReport != nil, o.UnchangedDocumentDiagnosticReport != nil)

	if o.FullDocumentDiagnosticReport != nil {
		return json.Marshal(*o.FullDocumentDiagnosticReport)
	}
	if o.UnchangedDocumentDiagnosticReport != nil {
		return json.Marshal(*o.UnchangedDocumentDiagnosticReport)
	}
	panic("unreachable")
}

func (o *RelatedFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport) UnmarshalJSON(data []byte) error {
	*o = RelatedFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport{}

	var vFullDocumentDiagnosticReport RelatedFullDocumentDiagnosticReport
	if err := json.Unmarshal(data, &vFullDocumentDiagnosticReport); err == nil {
		o.FullDocumentDiagnosticReport = &vFullDocumentDiagnosticReport
		return nil
	}
	var vUnchangedDocumentDiagnosticReport RelatedUnchangedDocumentDiagnosticReport
	if err := json.Unmarshal(data, &vUnchangedDocumentDiagnosticReport); err == nil {
		o.UnchangedDocumentDiagnosticReport = &vUnchangedDocumentDiagnosticReport
		return nil
	}
	return fmt.Errorf("invalid RelatedFullDocumentDiagnosticReportOrUnchangedDocumentDiagnosticReport: %s", data)
}

type InlineCompletionListOrItemsOrNull struct {
	List  *InlineCompletionList
	Items *[]*InlineCompletionItem
}

func (o InlineCompletionListOrItemsOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of InlineCompletionListOrItemsOrNull is set", o.List != nil, o.Items != nil)

	if o.List != nil {
		return json.Marshal(*o.List)
	}
	if o.Items != nil {
		return json.Marshal(*o.Items)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *InlineCompletionListOrItemsOrNull) UnmarshalJSON(data []byte) error {
	*o = InlineCompletionListOrItemsOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vList InlineCompletionList
	if err := json.Unmarshal(data, &vList); err == nil {
		o.List = &vList
		return nil
	}
	var vItems []*InlineCompletionItem
	if err := json.Unmarshal(data, &vItems); err == nil {
		o.Items = &vItems
		return nil
	}
	return fmt.Errorf("invalid InlineCompletionListOrItemsOrNull: %s", data)
}

type MessageActionItemOrNull struct {
	MessageActionItem *MessageActionItem
}

func (o MessageActionItemOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of MessageActionItemOrNull is set", o.MessageActionItem != nil)

	if o.MessageActionItem != nil {
		return json.Marshal(*o.MessageActionItem)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *MessageActionItemOrNull) UnmarshalJSON(data []byte) error {
	*o = MessageActionItemOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vMessageActionItem MessageActionItem
	if err := json.Unmarshal(data, &vMessageActionItem); err == nil {
		o.MessageActionItem = &vMessageActionItem
		return nil
	}
	return fmt.Errorf("invalid MessageActionItemOrNull: %s", data)
}

type TextEditsOrNull struct {
	TextEdits *[]*TextEdit
}

func (o TextEditsOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of TextEditsOrNull is set", o.TextEdits != nil)

	if o.TextEdits != nil {
		return json.Marshal(*o.TextEdits)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *TextEditsOrNull) UnmarshalJSON(data []byte) error {
	*o = TextEditsOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vTextEdits []*TextEdit
	if err := json.Unmarshal(data, &vTextEdits); err == nil {
		o.TextEdits = &vTextEdits
		return nil
	}
	return fmt.Errorf("invalid TextEditsOrNull: %s", data)
}

type CompletionItemsOrListOrNull struct {
	Items *[]*CompletionItem
	List  *CompletionList
}

func (o CompletionItemsOrListOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of CompletionItemsOrListOrNull is set", o.Items != nil, o.List != nil)

	if o.Items != nil {
		return json.Marshal(*o.Items)
	}
	if o.List != nil {
		return json.Marshal(*o.List)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *CompletionItemsOrListOrNull) UnmarshalJSON(data []byte) error {
	*o = CompletionItemsOrListOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vItems []*CompletionItem
	if err := json.Unmarshal(data, &vItems); err == nil {
		o.Items = &vItems
		return nil
	}
	var vList CompletionList
	if err := json.Unmarshal(data, &vList); err == nil {
		o.List = &vList
		return nil
	}
	return fmt.Errorf("invalid CompletionItemsOrListOrNull: %s", data)
}

type HoverOrNull struct {
	Hover *Hover
}

func (o HoverOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of HoverOrNull is set", o.Hover != nil)

	if o.Hover != nil {
		return json.Marshal(*o.Hover)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *HoverOrNull) UnmarshalJSON(data []byte) error {
	*o = HoverOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vHover Hover
	if err := json.Unmarshal(data, &vHover); err == nil {
		o.Hover = &vHover
		return nil
	}
	return fmt.Errorf("invalid HoverOrNull: %s", data)
}

type SignatureHelpOrNull struct {
	SignatureHelp *SignatureHelp
}

func (o SignatureHelpOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of SignatureHelpOrNull is set", o.SignatureHelp != nil)

	if o.SignatureHelp != nil {
		return json.Marshal(*o.SignatureHelp)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *SignatureHelpOrNull) UnmarshalJSON(data []byte) error {
	*o = SignatureHelpOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vSignatureHelp SignatureHelp
	if err := json.Unmarshal(data, &vSignatureHelp); err == nil {
		o.SignatureHelp = &vSignatureHelp
		return nil
	}
	return fmt.Errorf("invalid SignatureHelpOrNull: %s", data)
}

type LocationsOrNull struct {
	Locations *[]Location
}

func (o LocationsOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of LocationsOrNull is set", o.Locations != nil)

	if o.Locations != nil {
		return json.Marshal(*o.Locations)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *LocationsOrNull) UnmarshalJSON(data []byte) error {
	*o = LocationsOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vLocations []Location
	if err := json.Unmarshal(data, &vLocations); err == nil {
		o.Locations = &vLocations
		return nil
	}
	return fmt.Errorf("invalid LocationsOrNull: %s", data)
}

type DocumentHighlightsOrNull struct {
	DocumentHighlights *[]*DocumentHighlight
}

func (o DocumentHighlightsOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of DocumentHighlightsOrNull is set", o.DocumentHighlights != nil)

	if o.DocumentHighlights != nil {
		return json.Marshal(*o.DocumentHighlights)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *DocumentHighlightsOrNull) UnmarshalJSON(data []byte) error {
	*o = DocumentHighlightsOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vDocumentHighlights []*DocumentHighlight
	if err := json.Unmarshal(data, &vDocumentHighlights); err == nil {
		o.DocumentHighlights = &vDocumentHighlights
		return nil
	}
	return fmt.Errorf("invalid DocumentHighlightsOrNull: %s", data)
}

type SymbolInformationsOrDocumentSymbolsOrNull struct {
	SymbolInformations *[]*SymbolInformation
	DocumentSymbols    *[]*DocumentSymbol
}

func (o SymbolInformationsOrDocumentSymbolsOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of SymbolInformationsOrDocumentSymbolsOrNull is set", o.SymbolInformations != nil, o.DocumentSymbols != nil)

	if o.SymbolInformations != nil {
		return json.Marshal(*o.SymbolInformations)
	}
	if o.DocumentSymbols != nil {
		return json.Marshal(*o.DocumentSymbols)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *SymbolInformationsOrDocumentSymbolsOrNull) UnmarshalJSON(data []byte) error {
	*o = SymbolInformationsOrDocumentSymbolsOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vSymbolInformations []*SymbolInformation
	if err := json.Unmarshal(data, &vSymbolInformations); err == nil {
		o.SymbolInformations = &vSymbolInformations
		return nil
	}
	var vDocumentSymbols []*DocumentSymbol
	if err := json.Unmarshal(data, &vDocumentSymbols); err == nil {
		o.DocumentSymbols = &vDocumentSymbols
		return nil
	}
	return fmt.Errorf("invalid SymbolInformationsOrDocumentSymbolsOrNull: %s", data)
}

type CommandOrCodeAction struct {
	Command    *Command
	CodeAction *CodeAction
}

func (o CommandOrCodeAction) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of CommandOrCodeAction is set", o.Command != nil, o.CodeAction != nil)

	if o.Command != nil {
		return json.Marshal(*o.Command)
	}
	if o.CodeAction != nil {
		return json.Marshal(*o.CodeAction)
	}
	panic("unreachable")
}

func (o *CommandOrCodeAction) UnmarshalJSON(data []byte) error {
	*o = CommandOrCodeAction{}

	var vCommand Command
	if err := json.Unmarshal(data, &vCommand); err == nil {
		o.Command = &vCommand
		return nil
	}
	var vCodeAction CodeAction
	if err := json.Unmarshal(data, &vCodeAction); err == nil {
		o.CodeAction = &vCodeAction
		return nil
	}
	return fmt.Errorf("invalid CommandOrCodeAction: %s", data)
}

type CommandOrCodeActionArrayOrNull struct {
	CommandOrCodeActionArray *[]CommandOrCodeAction
}

func (o CommandOrCodeActionArrayOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of CommandOrCodeActionArrayOrNull is set", o.CommandOrCodeActionArray != nil)

	if o.CommandOrCodeActionArray != nil {
		return json.Marshal(*o.CommandOrCodeActionArray)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *CommandOrCodeActionArrayOrNull) UnmarshalJSON(data []byte) error {
	*o = CommandOrCodeActionArrayOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vCommandOrCodeActionArray []CommandOrCodeAction
	if err := json.Unmarshal(data, &vCommandOrCodeActionArray); err == nil {
		o.CommandOrCodeActionArray = &vCommandOrCodeActionArray
		return nil
	}
	return fmt.Errorf("invalid CommandOrCodeActionArrayOrNull: %s", data)
}

type SymbolInformationsOrWorkspaceSymbolsOrNull struct {
	SymbolInformations *[]*SymbolInformation
	WorkspaceSymbols   *[]*WorkspaceSymbol
}

func (o SymbolInformationsOrWorkspaceSymbolsOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of SymbolInformationsOrWorkspaceSymbolsOrNull is set", o.SymbolInformations != nil, o.WorkspaceSymbols != nil)

	if o.SymbolInformations != nil {
		return json.Marshal(*o.SymbolInformations)
	}
	if o.WorkspaceSymbols != nil {
		return json.Marshal(*o.WorkspaceSymbols)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *SymbolInformationsOrWorkspaceSymbolsOrNull) UnmarshalJSON(data []byte) error {
	*o = SymbolInformationsOrWorkspaceSymbolsOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vSymbolInformations []*SymbolInformation
	if err := json.Unmarshal(data, &vSymbolInformations); err == nil {
		o.SymbolInformations = &vSymbolInformations
		return nil
	}
	var vWorkspaceSymbols []*WorkspaceSymbol
	if err := json.Unmarshal(data, &vWorkspaceSymbols); err == nil {
		o.WorkspaceSymbols = &vWorkspaceSymbols
		return nil
	}
	return fmt.Errorf("invalid SymbolInformationsOrWorkspaceSymbolsOrNull: %s", data)
}

type CodeLenssOrNull struct {
	CodeLenss *[]*CodeLens
}

func (o CodeLenssOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of CodeLenssOrNull is set", o.CodeLenss != nil)

	if o.CodeLenss != nil {
		return json.Marshal(*o.CodeLenss)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *CodeLenssOrNull) UnmarshalJSON(data []byte) error {
	*o = CodeLenssOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vCodeLenss []*CodeLens
	if err := json.Unmarshal(data, &vCodeLenss); err == nil {
		o.CodeLenss = &vCodeLenss
		return nil
	}
	return fmt.Errorf("invalid CodeLenssOrNull: %s", data)
}

type DocumentLinksOrNull struct {
	DocumentLinks *[]*DocumentLink
}

func (o DocumentLinksOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of DocumentLinksOrNull is set", o.DocumentLinks != nil)

	if o.DocumentLinks != nil {
		return json.Marshal(*o.DocumentLinks)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *DocumentLinksOrNull) UnmarshalJSON(data []byte) error {
	*o = DocumentLinksOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vDocumentLinks []*DocumentLink
	if err := json.Unmarshal(data, &vDocumentLinks); err == nil {
		o.DocumentLinks = &vDocumentLinks
		return nil
	}
	return fmt.Errorf("invalid DocumentLinksOrNull: %s", data)
}

type RangeOrPrepareRenamePlaceholderOrPrepareRenameDefaultBehaviorOrNull struct {
	Range                        *Range
	PrepareRenamePlaceholder     *PrepareRenamePlaceholder
	PrepareRenameDefaultBehavior *PrepareRenameDefaultBehavior
}

func (o RangeOrPrepareRenamePlaceholderOrPrepareRenameDefaultBehaviorOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of RangeOrPrepareRenamePlaceholderOrPrepareRenameDefaultBehaviorOrNull is set", o.Range != nil, o.PrepareRenamePlaceholder != nil, o.PrepareRenameDefaultBehavior != nil)

	if o.Range != nil {
		return json.Marshal(*o.Range)
	}
	if o.PrepareRenamePlaceholder != nil {
		return json.Marshal(*o.PrepareRenamePlaceholder)
	}
	if o.PrepareRenameDefaultBehavior != nil {
		return json.Marshal(*o.PrepareRenameDefaultBehavior)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *RangeOrPrepareRenamePlaceholderOrPrepareRenameDefaultBehaviorOrNull) UnmarshalJSON(data []byte) error {
	*o = RangeOrPrepareRenamePlaceholderOrPrepareRenameDefaultBehaviorOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vRange Range
	if err := json.Unmarshal(data, &vRange); err == nil {
		o.Range = &vRange
		return nil
	}
	var vPrepareRenamePlaceholder PrepareRenamePlaceholder
	if err := json.Unmarshal(data, &vPrepareRenamePlaceholder); err == nil {
		o.PrepareRenamePlaceholder = &vPrepareRenamePlaceholder
		return nil
	}
	var vPrepareRenameDefaultBehavior PrepareRenameDefaultBehavior
	if err := json.Unmarshal(data, &vPrepareRenameDefaultBehavior); err == nil {
		o.PrepareRenameDefaultBehavior = &vPrepareRenameDefaultBehavior
		return nil
	}
	return fmt.Errorf("invalid RangeOrPrepareRenamePlaceholderOrPrepareRenameDefaultBehaviorOrNull: %s", data)
}

type LSPAnyOrNull struct {
	LSPAny *any
}

func (o LSPAnyOrNull) MarshalJSON() ([]byte, error) {
	assertAtMostOne("more than one element of LSPAnyOrNull is set", o.LSPAny != nil)

	if o.LSPAny != nil {
		return json.Marshal(*o.LSPAny)
	}
	// All fields are nil, represent as null
	return []byte("null"), nil
}

func (o *LSPAnyOrNull) UnmarshalJSON(data []byte) error {
	*o = LSPAnyOrNull{}

	// Handle null case
	if string(data) == "null" {
		return nil
	}

	var vLSPAny any
	if err := json.Unmarshal(data, &vLSPAny); err == nil {
		o.LSPAny = &vLSPAny
		return nil
	}
	return fmt.Errorf("invalid LSPAnyOrNull: %s", data)
}

type TextDocumentFilterLanguageOrTextDocumentFilterSchemeOrTextDocumentFilterPatternOrNotebookCellTextDocumentFilter struct {
	TextDocumentFilterLanguage     *TextDocumentFilterLanguage
	TextDocumentFilterScheme       *TextDocumentFilterScheme
	TextDocumentFilterPattern      *TextDocumentFilterPattern
	NotebookCellTextDocumentFilter *NotebookCellTextDocumentFilter
}

func (o TextDocumentFilterLanguageOrTextDocumentFilterSchemeOrTextDocumentFilterPatternOrNotebookCellTextDocumentFilter) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of TextDocumentFilterLanguageOrTextDocumentFilterSchemeOrTextDocumentFilterPatternOrNotebookCellTextDocumentFilter is set", o.TextDocumentFilterLanguage != nil, o.TextDocumentFilterScheme != nil, o.TextDocumentFilterPattern != nil, o.NotebookCellTextDocumentFilter != nil)

	if o.TextDocumentFilterLanguage != nil {
		return json.Marshal(*o.TextDocumentFilterLanguage)
	}
	if o.TextDocumentFilterScheme != nil {
		return json.Marshal(*o.TextDocumentFilterScheme)
	}
	if o.TextDocumentFilterPattern != nil {
		return json.Marshal(*o.TextDocumentFilterPattern)
	}
	if o.NotebookCellTextDocumentFilter != nil {
		return json.Marshal(*o.NotebookCellTextDocumentFilter)
	}
	panic("unreachable")
}

func (o *TextDocumentFilterLanguageOrTextDocumentFilterSchemeOrTextDocumentFilterPatternOrNotebookCellTextDocumentFilter) UnmarshalJSON(data []byte) error {
	*o = TextDocumentFilterLanguageOrTextDocumentFilterSchemeOrTextDocumentFilterPatternOrNotebookCellTextDocumentFilter{}

	var vTextDocumentFilterLanguage TextDocumentFilterLanguage
	if err := json.Unmarshal(data, &vTextDocumentFilterLanguage); err == nil {
		o.TextDocumentFilterLanguage = &vTextDocumentFilterLanguage
		return nil
	}
	var vTextDocumentFilterScheme TextDocumentFilterScheme
	if err := json.Unmarshal(data, &vTextDocumentFilterScheme); err == nil {
		o.TextDocumentFilterScheme = &vTextDocumentFilterScheme
		return nil
	}
	var vTextDocumentFilterPattern TextDocumentFilterPattern
	if err := json.Unmarshal(data, &vTextDocumentFilterPattern); err == nil {
		o.TextDocumentFilterPattern = &vTextDocumentFilterPattern
		return nil
	}
	var vNotebookCellTextDocumentFilter NotebookCellTextDocumentFilter
	if err := json.Unmarshal(data, &vNotebookCellTextDocumentFilter); err == nil {
		o.NotebookCellTextDocumentFilter = &vNotebookCellTextDocumentFilter
		return nil
	}
	return fmt.Errorf("invalid TextDocumentFilterLanguageOrTextDocumentFilterSchemeOrTextDocumentFilterPatternOrNotebookCellTextDocumentFilter: %s", data)
}

type StringOrMarkedStringWithLanguage struct {
	String                   *string
	MarkedStringWithLanguage *MarkedStringWithLanguage
}

func (o StringOrMarkedStringWithLanguage) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of StringOrMarkedStringWithLanguage is set", o.String != nil, o.MarkedStringWithLanguage != nil)

	if o.String != nil {
		return json.Marshal(*o.String)
	}
	if o.MarkedStringWithLanguage != nil {
		return json.Marshal(*o.MarkedStringWithLanguage)
	}
	panic("unreachable")
}

func (o *StringOrMarkedStringWithLanguage) UnmarshalJSON(data []byte) error {
	*o = StringOrMarkedStringWithLanguage{}

	var vString string
	if err := json.Unmarshal(data, &vString); err == nil {
		o.String = &vString
		return nil
	}
	var vMarkedStringWithLanguage MarkedStringWithLanguage
	if err := json.Unmarshal(data, &vMarkedStringWithLanguage); err == nil {
		o.MarkedStringWithLanguage = &vMarkedStringWithLanguage
		return nil
	}
	return fmt.Errorf("invalid StringOrMarkedStringWithLanguage: %s", data)
}

type InlineValueTextOrVariableLookupOrEvaluatableExpression struct {
	Text                  *InlineValueText
	VariableLookup        *InlineValueVariableLookup
	EvaluatableExpression *InlineValueEvaluatableExpression
}

func (o InlineValueTextOrVariableLookupOrEvaluatableExpression) MarshalJSON() ([]byte, error) {
	assertOnlyOne("more than one element of InlineValueTextOrVariableLookupOrEvaluatableExpression is set", o.Text != nil, o.VariableLookup != nil, o.EvaluatableExpression != nil)

	if o.Text != nil {
		return json.Marshal(*o.Text)
	}
	if o.VariableLookup != nil {
		return json.Marshal(*o.VariableLookup)
	}
	if o.EvaluatableExpression != nil {
		return json.Marshal(*o.EvaluatableExpression)
	}
	panic("unreachable")
}

func (o *InlineValueTextOrVariableLookupOrEvaluatableExpression) UnmarshalJSON(data []byte) error {
	*o = InlineValueTextOrVariableLookupOrEvaluatableExpression{}

	var vText InlineValueText
	if err := json.Unmarshal(data, &vText); err == nil {
		o.Text = &vText
		return nil
	}
	var vVariableLookup InlineValueVariableLookup
	if err := json.Unmarshal(data, &vVariableLookup); err == nil {
		o.VariableLookup = &vVariableLookup
		return nil
	}
	var vEvaluatableExpression InlineValueEvaluatableExpression
	if err := json.Unmarshal(data, &vEvaluatableExpression); err == nil {
		o.EvaluatableExpression = &vEvaluatableExpression
		return nil
	}
	return fmt.Errorf("invalid InlineValueTextOrVariableLookupOrEvaluatableExpression: %s", data)
}

// Literal types

// StringLiteralBegin is a literal type for "begin"
type StringLiteralBegin struct{}

func (o StringLiteralBegin) MarshalJSON() ([]byte, error) {
	return []byte(`"begin"`), nil
}

func (o *StringLiteralBegin) UnmarshalJSON(data []byte) error {
	if string(data) != `"begin"` {
		return fmt.Errorf("invalid StringLiteralBegin: %s", data)
	}
	return nil
}

// StringLiteralReport is a literal type for "report"
type StringLiteralReport struct{}

func (o StringLiteralReport) MarshalJSON() ([]byte, error) {
	return []byte(`"report"`), nil
}

func (o *StringLiteralReport) UnmarshalJSON(data []byte) error {
	if string(data) != `"report"` {
		return fmt.Errorf("invalid StringLiteralReport: %s", data)
	}
	return nil
}

// StringLiteralEnd is a literal type for "end"
type StringLiteralEnd struct{}

func (o StringLiteralEnd) MarshalJSON() ([]byte, error) {
	return []byte(`"end"`), nil
}

func (o *StringLiteralEnd) UnmarshalJSON(data []byte) error {
	if string(data) != `"end"` {
		return fmt.Errorf("invalid StringLiteralEnd: %s", data)
	}
	return nil
}

// StringLiteralCreate is a literal type for "create"
type StringLiteralCreate struct{}

func (o StringLiteralCreate) MarshalJSON() ([]byte, error) {
	return []byte(`"create"`), nil
}

func (o *StringLiteralCreate) UnmarshalJSON(data []byte) error {
	if string(data) != `"create"` {
		return fmt.Errorf("invalid StringLiteralCreate: %s", data)
	}
	return nil
}

// StringLiteralRename is a literal type for "rename"
type StringLiteralRename struct{}

func (o StringLiteralRename) MarshalJSON() ([]byte, error) {
	return []byte(`"rename"`), nil
}

func (o *StringLiteralRename) UnmarshalJSON(data []byte) error {
	if string(data) != `"rename"` {
		return fmt.Errorf("invalid StringLiteralRename: %s", data)
	}
	return nil
}

// StringLiteralDelete is a literal type for "delete"
type StringLiteralDelete struct{}

func (o StringLiteralDelete) MarshalJSON() ([]byte, error) {
	return []byte(`"delete"`), nil
}

func (o *StringLiteralDelete) UnmarshalJSON(data []byte) error {
	if string(data) != `"delete"` {
		return fmt.Errorf("invalid StringLiteralDelete: %s", data)
	}
	return nil
}

// StringLiteralFull is a literal type for "full"
type StringLiteralFull struct{}

func (o StringLiteralFull) MarshalJSON() ([]byte, error) {
	return []byte(`"full"`), nil
}

func (o *StringLiteralFull) UnmarshalJSON(data []byte) error {
	if string(data) != `"full"` {
		return fmt.Errorf("invalid StringLiteralFull: %s", data)
	}
	return nil
}

// StringLiteralUnchanged is a literal type for "unchanged"
type StringLiteralUnchanged struct{}

func (o StringLiteralUnchanged) MarshalJSON() ([]byte, error) {
	return []byte(`"unchanged"`), nil
}

func (o *StringLiteralUnchanged) UnmarshalJSON(data []byte) error {
	if string(data) != `"unchanged"` {
		return fmt.Errorf("invalid StringLiteralUnchanged: %s", data)
	}
	return nil
}

// StringLiteralSnippet is a literal type for "snippet"
type StringLiteralSnippet struct{}

func (o StringLiteralSnippet) MarshalJSON() ([]byte, error) {
	return []byte(`"snippet"`), nil
}

func (o *StringLiteralSnippet) UnmarshalJSON(data []byte) error {
	if string(data) != `"snippet"` {
		return fmt.Errorf("invalid StringLiteralSnippet: %s", data)
	}
	return nil
}
