//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"github.com/microsoft/typescript-go/internal/parser"
	"github.com/microsoft/typescript-go/internal/repo"
	"github.com/microsoft/typescript-go/internal/tspath"
)

var (
	libInputDir     = filepath.Join(repo.TypeScriptSubmodulePath, "src", "lib")
	copyrightNotice = filepath.Join(repo.TypeScriptSubmodulePath, "scripts", "CopyrightNotice.txt")
)

func main() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)

	generateLibs()
}

func generateLibs() {
	const outputDir = "libs"

	libNames, paths := readLibsMeta()
	copyright := readCopyright()

	type lib struct {
		target  string   // target relative to libs dir
		sources []string // sources relative to src/lib dir
	}

	var libs []lib
	for _, libName := range libNames {
		sources := []string{"header.d.ts", libName + ".d.ts"}
		var target string
		if path, ok := paths[libName]; ok {
			target = path
		} else {
			target = "lib." + libName + ".d.ts"
		}
		libs = append(libs, lib{target: target, sources: sources})
	}

	slices.SortFunc(libs, func(a lib, b lib) int {
		return strings.Compare(a.target, b.target)
	})

	if err := os.RemoveAll(outputDir); err != nil {
		log.Fatalf("failed to remove libs directory: %v", err)
		return
	}

	if err := os.MkdirAll(outputDir, 0o755); err != nil {
		log.Fatalf("failed to create libs directory: %v", err)
		return
	}

	for _, lib := range libs {
		var output bytes.Buffer
		output.Write(copyright)

		for _, source := range lib.sources {
			sourcePath := filepath.Join(libInputDir, source)
			b, err := os.ReadFile(sourcePath)
			if err != nil {
				log.Fatalf("failed to read %s: %v", sourcePath, err)
				return
			}

			output.WriteByte('\n')
			output.Write(removeCRLF(b))
		}

		outputPath := filepath.Join(outputDir, lib.target)
		if err := os.WriteFile(outputPath, output.Bytes(), 0o644); err != nil {
			log.Fatalf("failed to write %s: %v", outputPath, err)
			return
		}
	}

	libVarNames := make([]string, len(libs))
	for i, lib := range libs {
		libVarNames[i] = "libs_" + strings.ReplaceAll(lib.target, ".", "_")
	}

	var libsList bytes.Buffer
	libsList.WriteString("// Code generated by generate.go; DO NOT EDIT.\n\n")
	libsList.WriteString("package bundled\n\n")

	libsList.WriteString("// LibNames is the list of all bundled lib files, sorted by name.\n")
	libsList.WriteString("// For the list of libs sorted by load order, use [tsoptions.Libs].\n")
	libsList.WriteString("var LibNames = []string{\n")
	for _, lib := range libs {
		libsList.WriteString("\t\"" + lib.target + "\",\n")
	}
	libsList.WriteString("}\n")

	const libsListPath = "libs_generated.go"

	formatted, err := format.Source(libsList.Bytes())
	if err != nil {
		log.Fatalf("failed to format source: %v", err)
		return
	}

	if err := os.WriteFile(libsListPath, formatted, 0o644); err != nil {
		log.Fatalf("failed to write %s: %v", libsListPath, err)
		return
	}

	var embedGenerated bytes.Buffer
	embedGenerated.WriteString("//go:build !noembed\n\n")
	embedGenerated.WriteString("// Code generated by generate.go; DO NOT EDIT.\n\n")
	embedGenerated.WriteString("package bundled\n\n")
	embedGenerated.WriteString("import (\n")
	embedGenerated.WriteString("\"io/fs\"\n\n")
	embedGenerated.WriteString("_ \"embed\"\n")
	embedGenerated.WriteString(")\n\n")

	embedGenerated.WriteString("var (\n")
	for i, lib := range libs {
		varName := libVarNames[i]
		embedGenerated.WriteString("//go:embed libs/" + lib.target + "\n")
		embedGenerated.WriteString("" + varName + " string\n")
	}
	embedGenerated.WriteString(")\n\n")

	embedGenerated.WriteString("var embeddedContents = map[string]string{\n")
	for i, lib := range libs {
		varName := libVarNames[i]
		embedGenerated.WriteString("\t\"libs/" + lib.target + "\": " + varName + ",\n")
	}
	embedGenerated.WriteString("}\n\n")

	embedGenerated.WriteString("var libsEntries = []fs.DirEntry{\n")
	for i, lib := range libs {
		varName := libVarNames[i]
		fmt.Fprintf(&embedGenerated, "\tfs.FileInfoToDirEntry(&embeddedFileInfo{name: %q, size: int64(len(%s))}),\n", lib.target, varName)
	}
	embedGenerated.WriteString("}\n")

	const embedGeneratedPath = "embed_generated.go"

	formatted, err = format.Source(embedGenerated.Bytes())
	if err != nil {
		log.Fatalf("failed to format source: %v", err)
		return
	}

	if err := os.WriteFile(embedGeneratedPath, formatted, 0o644); err != nil {
		log.Fatalf("failed to write %s: %v", embedGeneratedPath, err)
		return
	}
}

type libsMeta struct {
	libs  []string
	paths map[string]string
}

func readLibsMeta() (libNames []string, paths map[string]string) {
	libsFile := filepath.Join(libInputDir, "libs.json")

	b, err := os.ReadFile(libsFile)
	if err != nil {
		log.Fatalf("failed to open libs.json: %v", err)
		return nil, nil
	}

	sourceFile := parser.ParseJSONText(libsFile, tspath.Path(libsFile), string(b))
	diags := sourceFile.Diagnostics()

	if len(diags) > 0 {
		for _, diag := range diags {
			log.Printf("%s", diag.Message())
		}
		log.Fatalf("failed to parse libs.json")
		return nil, nil
	}

	paths = make(map[string]string)

	props := sourceFile.Statements.Nodes[0].
		AsExpressionStatement().
		Expression.
		AsObjectLiteralExpression().
		Properties.
		Nodes

	for _, prop := range props {
		assign := prop.AsPropertyAssignment()
		name := assign.Name().Text()
		switch name {
		case "libs":
			for _, lib := range assign.Initializer.AsArrayLiteralExpression().Elements.Nodes {
				libNames = append(libNames, lib.AsStringLiteral().Text)
			}
		case "paths":
			for _, path := range assign.Initializer.AsObjectLiteralExpression().Properties.Nodes {
				prop := path.AsPropertyAssignment()
				key := prop.Name().Text()
				value := prop.Initializer.AsStringLiteral().Text
				paths[key] = value
			}
		default:
			log.Fatalf("unexpected property: %s", name)
		}
	}

	return libNames, paths
}

func readCopyright() []byte {
	b, err := os.ReadFile(copyrightNotice)
	if err != nil {
		log.Fatalf("failed to read copyright notice: %v", err)
		return nil
	}
	return removeCRLF(b)
}

func removeCRLF(b []byte) []byte {
	return bytes.ReplaceAll(b, []byte("\r\n"), []byte("\n"))
}
