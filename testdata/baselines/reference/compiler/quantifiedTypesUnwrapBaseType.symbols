//// [tests/cases/compiler/quantifiedTypesUnwrapBaseType.ts] ////

=== quantifiedTypesUnwrapBaseType.ts ===
const f = (x: <T> [T, NoInfer<T>]) => {
>f : Symbol(f, Decl(quantifiedTypesUnwrapBaseType.ts, 0, 5))
>x : Symbol(x, Decl(quantifiedTypesUnwrapBaseType.ts, 0, 11))
>T : Symbol(T, Decl(quantifiedTypesUnwrapBaseType.ts, 0, 15))
>T : Symbol(T, Decl(quantifiedTypesUnwrapBaseType.ts, 0, 15))
>NoInfer : Symbol(NoInfer, Decl(lib.es5.d.ts, --, --))
>T : Symbol(T, Decl(quantifiedTypesUnwrapBaseType.ts, 0, 15))

  let [t0, t1] = x
>t0 : Symbol(t0, Decl(quantifiedTypesUnwrapBaseType.ts, 1, 7))
>t1 : Symbol(t1, Decl(quantifiedTypesUnwrapBaseType.ts, 1, 10))
>x : Symbol(x, Decl(quantifiedTypesUnwrapBaseType.ts, 0, 11))
}

const g = (f: <T> ((t: T) => T)) => {
>g : Symbol(g, Decl(quantifiedTypesUnwrapBaseType.ts, 4, 5))
>f : Symbol(f, Decl(quantifiedTypesUnwrapBaseType.ts, 4, 11))
>T : Symbol(T, Decl(quantifiedTypesUnwrapBaseType.ts, 4, 15))
>t : Symbol(t, Decl(quantifiedTypesUnwrapBaseType.ts, 4, 20))
>T : Symbol(T, Decl(quantifiedTypesUnwrapBaseType.ts, 4, 15))
>T : Symbol(T, Decl(quantifiedTypesUnwrapBaseType.ts, 4, 15))

  f(0)
>f : Symbol(f, Decl(quantifiedTypesUnwrapBaseType.ts, 4, 11))
}














/*
declare const str: string;
declare const num: number;
function acceptString(str: string) { }
function acceptNumber(num: number) { }

const arr: (<T> [T, (t: T) => void])[] = [
    [str, acceptString],
    [num, acceptNumber],
    [str, acceptNumber], // should be error
];

for (const pair of arr) {
    const [arg, func] = pair;
    func(arg); // should be no error
}
*/
/*
declare const f: (a: <T> {
  produce: (arg: string) => T,
  consume: (arg: T) => unknown,
  prop: <U> {
    produce: (arg: T) => U,
    consume: (arg: U) => unknown,
  }
}) => void

f({
  produce: a => Number(a),
  consume: x => {
    x satisfies number
  },
  prop: {
    produce: x => {
      x satisfies number
      return Boolean(x)
    },
    consume: y => {
      y satisfies boolean
    }
  }
})
*/

/*
declare const smallest:
  <T extends OneOf<number | string>>(xs: T[]) => T

smallest([1, 2, 3])
smallest(["a", "b", "c"])

smallest([1, "b", 3])
smallest([1, 2, undefined])

type OneOf<Spec> =
  <Actual> (
    Actual extends Spec
      ? IsUnit<Actual> extends true ? Actual : never
      : Spec
  )

type IsUnit<U> =
  [U] extends (U extends unknown ? [U] : never) ? true : false
*/
