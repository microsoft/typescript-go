//// [tests/cases/compiler/importValueOnlyUsedAsType.ts] ////

=== provider.ts ===
export class Value {
>Value : Value

    data: string = "";
>data : string
>"" : ""
}
export type ValueData = { data: string };
>ValueData : ValueData
>data : string

=== consumer.ts ===
// Import Value as a value (no `type` keyword), but only use it in type positions
import { Value, type ValueData } from "./provider";
>Value : typeof Value
>ValueData : any

// Value is ONLY used in type positions:
export interface Record {
    getValue(): Value; // return type
>getValue : () => Value

    setValue(value: Value): void; // parameter type
>setValue : (value: Value) => void
>value : Value

    readonly currentValue: Value; // type annotation
>currentValue : Value
}

export function processRecord(
>processRecord : (value: Value, callback: (result: Value) => void) => Value

    value: Value, // parameter type
>value : Value

    callback: (result: Value) => void, // parameter type in callback
>callback : (result: Value) => void
>result : Value

): Value {
    // return type
    callback(value);
>callback(value) : void
>callback : (result: Value) => void
>value : Value

    return value;
>value : Value
}

export class BaseProcessor {
>BaseProcessor : BaseProcessor

    current: Value | null = null;
>current : Value
}

