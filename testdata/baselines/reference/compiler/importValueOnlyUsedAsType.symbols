//// [tests/cases/compiler/importValueOnlyUsedAsType.ts] ////

=== provider.ts ===
export class Value {
>Value : Symbol(Value, Decl(provider.ts, 0, 0))

    data: string = "";
>data : Symbol(Value.data, Decl(provider.ts, 0, 20))
}
export type ValueData = { data: string };
>ValueData : Symbol(ValueData, Decl(provider.ts, 2, 1))
>data : Symbol(data, Decl(provider.ts, 3, 25))

=== consumer.ts ===
// Import Value as a value (no `type` keyword), but only use it in type positions
import { Value, type ValueData } from "./provider";
>Value : Symbol(Value, Decl(consumer.ts, 1, 8))
>ValueData : Symbol(ValueData, Decl(consumer.ts, 1, 15))

// Value is ONLY used in type positions:
export interface Record {
>Record : Symbol(Record, Decl(consumer.ts, 1, 51))

    getValue(): Value; // return type
>getValue : Symbol(Record.getValue, Decl(consumer.ts, 4, 25))
>Value : Symbol(Value, Decl(consumer.ts, 1, 8))

    setValue(value: Value): void; // parameter type
>setValue : Symbol(Record.setValue, Decl(consumer.ts, 5, 22))
>value : Symbol(value, Decl(consumer.ts, 6, 13))
>Value : Symbol(Value, Decl(consumer.ts, 1, 8))

    readonly currentValue: Value; // type annotation
>currentValue : Symbol(Record.currentValue, Decl(consumer.ts, 6, 33))
>Value : Symbol(Value, Decl(consumer.ts, 1, 8))
}

export function processRecord(
>processRecord : Symbol(processRecord, Decl(consumer.ts, 8, 1))

    value: Value, // parameter type
>value : Symbol(value, Decl(consumer.ts, 10, 30))
>Value : Symbol(Value, Decl(consumer.ts, 1, 8))

    callback: (result: Value) => void, // parameter type in callback
>callback : Symbol(callback, Decl(consumer.ts, 11, 17))
>result : Symbol(result, Decl(consumer.ts, 12, 15))
>Value : Symbol(Value, Decl(consumer.ts, 1, 8))

): Value {
>Value : Symbol(Value, Decl(consumer.ts, 1, 8))

    // return type
    callback(value);
>callback : Symbol(callback, Decl(consumer.ts, 11, 17))
>value : Symbol(value, Decl(consumer.ts, 10, 30))

    return value;
>value : Symbol(value, Decl(consumer.ts, 10, 30))
}

export class BaseProcessor {
>BaseProcessor : Symbol(BaseProcessor, Decl(consumer.ts, 17, 1))

    current: Value | null = null;
>current : Symbol(BaseProcessor.current, Decl(consumer.ts, 19, 28))
>Value : Symbol(Value, Decl(consumer.ts, 1, 8))
}

