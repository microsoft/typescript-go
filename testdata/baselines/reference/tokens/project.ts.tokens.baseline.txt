Line 168:
【TS: ExportKeyword [4035, 4063)】
《Go: JSDoc [4039, 4055)》
    AutoImportProvider,
    Auxiliary,
}【

《/** @internal */》
export】 type Mutable<T> = { -readonly [K in keyof T]: T[K]; };



Line 171:
【TS: ExportKeyword [4118, 4146)】
《Go: JSDoc [4122, 4138)》

/** @internal */
export type Mutable<T> = { -readonly [K in keyof T]: T[K]; };【

《/** @internal */》
export】 function countEachFileTypes(infos: ScriptInfo[], includeSizes = false): FileStats {
    const result: Mutable<FileStats> = {


Line 236:
【TS: ExportKeyword [6200, 6228)】
《Go: JSDoc [6204, 6220)》
    const counts = countEachFileTypes(project.getScriptInfos());
    return counts.ts === 0 && counts.tsx === 0;
}【

《/** @internal */》
export】 function hasNoTypeScriptSource(fileNames: string[]): boolean {
    return !fileNames.some(fileName => (fileExtensionIs(fileName, Extension.Ts) && !isDeclarationFileName(fileName)) || fileExtensionIs(fileName, Extension.Tsx));


Line 241:
【TS: ExportKeyword [6458, 6486)】
《Go: JSDoc [6462, 6478)》
export function hasNoTypeScriptSource(fileNames: string[]): boolean {
    return !fileNames.some(fileName => (fileExtensionIs(fileName, Extension.Ts) && !isDeclarationFileName(fileName)) || fileExtensionIs(fileName, Extension.Tsx));
}【

《/** @internal */》
export】 interface ProjectFilesWithTSDiagnostics extends protocol.ProjectFiles {
    projectErrors: readonly Diagnostic[];


Line 268:
【TS: ExportKeyword [7244, 7272)】
《Go: JSDoc [7248, 7264)》
}

export type PluginModuleFactory = (mod: { typescript: typeof ts; }) => PluginModule;【

《/** @internal */》
export】 interface PluginImportResult<T> {
    pluginConfigEntry: PluginImport;


Line 275:
【TS: ExportKeyword [7421, 7449)】
《Go: JSDoc [7425, 7441)》
    resolvedModule: T | undefined;
    errorLogs: string[] | undefined;
}【

《/** @internal */》
export】 type BeginEnablePluginResult = PluginImportResult<PluginModuleFactory>;



Line 278:
【TS: ExportKeyword [7521, 7727)】
《Go: JSDoc [7525, 7719)》

/** @internal */
export type BeginEnablePluginResult = PluginImportResult<PluginModuleFactory>;【

《/**
 * The project root can be script info - if root is present,
 * or it could be just normalized path if root wasn't present on the host(only for non inferred project)
 *
 * @internal
 */》
export】 interface ProjectRootFile {
    fileName: NormalizedPath;


Line 280:
【TS: JSDoc [7525, 7719)】
《Go: JSDocText [7525, 7705)》
export type BeginEnablePluginResult = PluginImportResult<PluginModuleFactory>;

【《/**
 * The project root can be script info - if root is present,
 * or it could be just normalized path if root wasn't present on the host(only for non inferred project)
 *
 * 》@internal
 */】
export interface ProjectRootFile {


Line 298:
【TS: ExportKeyword [8175, 8203)】
《Go: JSDoc [8179, 8195)》
function isGeneratedFileWatcher(watch: GeneratedFileWatcherMap): watch is GeneratedFileWatcher {
    return (watch as GeneratedFileWatcher).generatedFilePath !== undefined;
}【

《/** @internal */》
export】 interface EmitResult {
    emitSkipped: boolean;


Line 371:
【TS: ProtectedKeyword [10555, 10594)】
《Go: JSDoc [10563, 10579)》
    private externalFiles: SortedReadonlyArray<string> | undefined;
    private missingFilesMap: Map<Path, FileWatcher> | undefined;
    private generatedFilesMap: GeneratedFileWatcherMap | undefined;【

    《/** @internal */》
    protected】 readonly plugins: PluginModuleWithName[] = [];



Line 374:
【TS: Identifier [10641, 10930)】
《Go: JSDoc [10649, 10894)》

    /** @internal */
    protected readonly plugins: PluginModuleWithName[] = [];【

    《/**
     * This is map from files to unresolved imports in it
     * Maop does not contain entries for files that do not have unresolved imports
     * This helps in containing the set of files to invalidate
     *
     * @internal
     */》
    cachedUnresolvedImportsPerFile】: Map<Path, readonly string[]> = new Map();



Line 376:
【TS: JSDoc [10649, 10894)】
《Go: JSDocText [10649, 10876)》
    protected readonly plugins: PluginModuleWithName[] = [];

    【《/**
     * This is map from files to unresolved imports in it
     * Maop does not contain entries for files that do not have unresolved imports
     * This helps in containing the set of files to invalidate
     *
     * 》@internal
     */】
    cachedUnresolvedImportsPerFile: Map<Path, readonly string[]> = new Map();


Line 383:
【TS: PropertyDeclaration [10973, 11076)】
《Go: JSDoc [10981, 10997)》
     * @internal
     */
    cachedUnresolvedImportsPerFile: Map<Path, readonly string[]> = new Map();【

    《/** @internal */》
    lastCachedUnresolvedImportsList: SortedReadonlyArray<string> | undefined;】
    private hasAddedorRemovedFiles = false;


Line 388:
【TS: PropertyDeclaration [11169, 11247)】
《Go: JSDoc [11177, 11193)》
    lastCachedUnresolvedImportsList: SortedReadonlyArray<string> | undefined;
    private hasAddedorRemovedFiles = false;
    private hasAddedOrRemovedSymlinks = false;【

    《/** @internal */》
    lastFileExceededProgramSize: string | undefined;】



Line 399:
【TS: PropertyDeclaration [11531, 11627)】
《Go: JSDoc [11539, 11555)》

    readonly trace?: (s: string) => void;
    readonly realpath?: (path: string) => string;【

    《/** @internal */》
    hasInvalidatedResolutions?: HasInvalidatedResolutions | undefined;】



Line 402:
【TS: PropertyDeclaration [11627, 11728)】
《Go: JSDoc [11635, 11651)》

    /** @internal */
    hasInvalidatedResolutions?: HasInvalidatedResolutions | undefined;【

    《/** @internal */》
    hasInvalidatedLibResolutions: HasInvalidatedLibResolutions | undefined;】



Line 405:
【TS: PropertyDeclaration [11728, 11791)】
《Go: JSDoc [11736, 11752)》

    /** @internal */
    hasInvalidatedLibResolutions: HasInvalidatedLibResolutions | undefined;【

    《/** @internal */》
    resolutionCache: ResolutionCache;】



Line 410:
【TS: PropertyDeclaration [11846, 12012)】
《Go: JSDoc [11852, 11956)》
    resolutionCache: ResolutionCache;

    private builderState: BuilderState | undefined;【
    《/**
     * Set of files names that were updated since the last call to getChangesSinceVersion.
     */》
    private updatedFileNames: Set<string> | undefined;】
    /**


Line 411:
【TS: JSDoc [11852, 11956)】
《Go: JSDocText [11852, 11954)》

    private builderState: BuilderState | undefined;
    【《/**
     * Set of files names that were updated since the last call to getChangesSinceVersion.
     》*/】
    private updatedFileNames: Set<string> | undefined;


Line 414:
【TS: PropertyDeclaration [12012, 12185)】
《Go: JSDoc [12018, 12115)》
     * Set of files names that were updated since the last call to getChangesSinceVersion.
     */
    private updatedFileNames: Set<string> | undefined;【
    《/**
     * Set of files that was returned from the last call to getChangesSinceVersion.
     */》
    private lastReportedFileNames: Map<string, boolean> | undefined;】
    /**


Line 415:
【TS: JSDoc [12018, 12115)】
《Go: JSDocText [12018, 12113)》
     */
    private updatedFileNames: Set<string> | undefined;
    【《/**
     * Set of files that was returned from the last call to getChangesSinceVersion.
     》*/】
    private lastReportedFileNames: Map<string, boolean> | undefined;


Line 418:
【TS: PropertyDeclaration [12185, 12281)】
《Go: JSDoc [12191, 12243)》
     * Set of files that was returned from the last call to getChangesSinceVersion.
     */
    private lastReportedFileNames: Map<string, boolean> | undefined;【
    《/**
     * Last version that was reported.
     */》
    private lastReportedVersion = 0;】
    /**


Line 419:
【TS: JSDoc [12191, 12243)】
《Go: JSDocText [12191, 12241)》
     */
    private lastReportedFileNames: Map<string, boolean> | undefined;
    【《/**
     * Last version that was reported.
     》*/】
    private lastReportedVersion = 0;


Line 422:
【TS: PropertyDeclaration [12281, 12570)】
《Go: JSDoc [12287, 12538)》
     * Last version that was reported.
     */
    private lastReportedVersion = 0;【
    《/**
     * Current project's program version. (incremented everytime new program is created that is not complete reuse from the old one)
     * This property is changed in 'updateGraph' based on the set of files in program
     * @internal
     */》
    projectProgramVersion = 0;】
    /**


Line 423:
【TS: JSDoc [12287, 12538)】
《Go: JSDocText [12287, 12520)》
     */
    private lastReportedVersion = 0;
    【《/**
     * Current project's program version. (incremented everytime new program is created that is not complete reuse from the old one)
     * This property is changed in 'updateGraph' based on the set of files in program
     * 》@internal
     */】
    projectProgramVersion = 0;


Line 428:
【TS: PropertyDeclaration [12570, 12953)】
《Go: JSDoc [12576, 12923)》
     * @internal
     */
    projectProgramVersion = 0;【
    《/**
     * Current version of the project state. It is changed when:
     * - new root file was added/removed
     * - edit happen in some file that is currently included in the project.
     * This property is different from projectStructureVersion since in most cases edits don't affect set of files in the project
     * @internal
     */》
    projectStateVersion = 0;】



Line 429:
【TS: JSDoc [12576, 12923)】
《Go: JSDocText [12576, 12905)》
     */
    projectProgramVersion = 0;
    【《/**
     * Current version of the project state. It is changed when:
     * - new root file was added/removed
     * - edit happen in some file that is currently included in the project.
     * This property is different from projectStructureVersion since in most cases edits don't affect set of files in the project
     * 》@internal
     */】
    projectStateVersion = 0;


Line 438:
【TS: PropertyDeclaration [13011, 13068)】
《Go: JSDoc [13019, 13035)》
    projectStateVersion = 0;

    protected projectErrors: Diagnostic[] | undefined;【

    《/** @internal */》
    initialLoadPending = false;】



Line 441:
【TS: PropertyDeclaration [13068, 13112)】
《Go: JSDoc [13076, 13092)》

    /** @internal */
    initialLoadPending = false;【

    《/** @internal */》
    dirty = false;】



Line 444:
【TS: Identifier [13112, 13153)】
《Go: JSDoc [13120, 13136)》

    /** @internal */
    dirty = false;【

    《/** @internal */》
    typingFiles】: SortedReadonlyArray<string> = emptyArray;



Line 451:
【TS: PropertyDeclaration [13315, 13405)】
《Go: JSDoc [13323, 13339)》
    private typingsCache: TypingsCacheEntry | undefined;

    private typingWatchers: TypingWatchers | undefined;【

    《/** @internal */》
    originalConfiguredProjects: Set<NormalizedPath> | undefined;】



Line 454:
【TS: PropertyDeclaration [13405, 13491)】
《Go: JSDoc [13413, 13429)》

    /** @internal */
    originalConfiguredProjects: Set<NormalizedPath> | undefined;【

    《/** @internal */》
    packageJsonWatches: Set<PackageJsonWatcher> | undefined;】



Line 457:
【TS: PropertyDeclaration [13491, 13575)】
《Go: JSDoc [13499, 13515)》

    /** @internal */
    packageJsonWatches: Set<PackageJsonWatcher> | undefined;【

    《/** @internal */》
    noDtsResolutionProject?: AuxiliaryProject | undefined;】



Line 460:
【TS: Identifier [13575, 13642)】
《Go: JSDoc [13583, 13599)》

    /** @internal */
    noDtsResolutionProject?: AuxiliaryProject | undefined;【

    《/** @internal */》
    getResolvedProjectReferenceToRedirect】(_fileName: string): ResolvedProjectReference | undefined {
        return undefined;


Line 465:
【TS: Identifier [13735, 13795)】
《Go: JSDoc [13743, 13759)》
    getResolvedProjectReferenceToRedirect(_fileName: string): ResolvedProjectReference | undefined {
        return undefined;
    }【

    《/** @internal */》 useSourceOfProjectReferenceRedirect】?(): boolean;
    /** @internal */ getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;


Line 467:
【TS: Identifier [13808, 13851)】
《Go: JSDoc [13814, 13830)》
    }

    /** @internal */ useSourceOfProjectReferenceRedirect?(): boolean;【
    《/** @internal */》 getParsedCommandLine】?(fileName: string): ParsedCommandLine | undefined;



Line 484:
【TS: MethodDeclaration [14499, 15680)】
《Go: JSDoc [14507, 14523)》
    public static resolveModule(moduleName: string, initialDir: string, host: ServerHost, log: (message: string) => void): {} | undefined {
        return Project.importServicePluginSync({ name: moduleName }, [initialDir], host, log).resolvedModule;
    }【

    《/** @internal */》
    public static importServicePluginSync<T = {}>(
        pluginConfigEntry: PluginImport,
        searchPaths: string[],
        host: ServerHost,
        log: (message: string) => void,
    ): PluginImportResult<T> {
        Debug.assertIsDefined(host.require);
        let errorLogs: string[] | undefined;
        let resolvedModule: T | undefined;
        for (const initialDir of searchPaths) {
            const resolvedPath = normalizeSlashes(host.resolvePath(combinePaths(initialDir, "node_modules")));
            log(`Loading ${pluginConfigEntry.name} from ${initialDir} (resolved to ${resolvedPath})`);
            const result = host.require(resolvedPath, pluginConfigEntry.name); // TODO: GH#18217
            if (!result.error) {
                resolvedModule = result.module as T;
                break;
            }
            const err = result.error.stack || result.error.message || JSON.stringify(result.error);
            (errorLogs ??= []).push(`Failed to load module '${pluginConfigEntry.name}' from ${resolvedPath}: ${err}`);
        }
        return { pluginConfigEntry, resolvedModule, errorLogs };
    }】



Line 508:
【TS: MethodDeclaration [15680, 17043)】
《Go: JSDoc [15688, 15704)》
        }
        return { pluginConfigEntry, resolvedModule, errorLogs };
    }【

    《/** @internal */》
    public static async importServicePluginAsync<T = {}>(
        pluginConfigEntry: PluginImport,
        searchPaths: string[],
        host: ServerHost,
        log: (message: string) => void,
    ): Promise<PluginImportResult<T>> {
        Debug.assertIsDefined(host.importPlugin);
        let errorLogs: string[] | undefined;
        let resolvedModule: T | undefined;
        for (const initialDir of searchPaths) {
            const resolvedPath = combinePaths(initialDir, "node_modules");
            log(`Dynamically importing ${pluginConfigEntry.name} from ${initialDir} (resolved to ${resolvedPath})`);
            let result: ModuleImportResult;
            try {
                result = await host.importPlugin(resolvedPath, pluginConfigEntry.name);
            }
            catch (e) {
                result = { module: undefined, error: e };
            }
            if (!result.error) {
                resolvedModule = result.module as T;
                break;
            }
            const err = result.error.stack || result.error.message || JSON.stringify(result.error);
            (errorLogs ??= []).push(`Failed to dynamically import module '${pluginConfigEntry.name}' from ${resolvedPath}: ${err}`);
        }
        return { pluginConfigEntry, resolvedModule, errorLogs };
    }】



Line 538:
【TS: PropertyDeclaration [17043, 17107)】
《Go: JSDoc [17051, 17067)》
        }
        return { pluginConfigEntry, resolvedModule, errorLogs };
    }【

    《/** @internal */》
    readonly currentDirectory: string;】



Line 541:
【TS: PropertyDeclaration [17107, 17166)】
《Go: JSDoc [17115, 17131)》

    /** @internal */
    readonly currentDirectory: string;【

    《/** @internal */》
    readonly projectName: string;】



Line 544:
【TS: PropertyDeclaration [17166, 17250)】
《Go: JSDoc [17174, 17190)》

    /** @internal */
    readonly projectName: string;【

    《/** @internal */》
    public directoryStructureHost: DirectoryStructureHost;】



Line 547:
【TS: PropertyDeclaration [17250, 17339)】
《Go: JSDoc [17258, 17274)》

    /** @internal */
    public directoryStructureHost: DirectoryStructureHost;【

    《/** @internal */》
    public readonly getCanonicalFileName: GetCanonicalFileName;】



Line 555:
【TS: PropertyDeclaration [17583, 17681)】
《Go: JSDoc [17589, 17605)》
    private changedFilesForExportMapCache: Set<Path> | undefined;
    private moduleSpecifierCache = createModuleSpecifierCache(this);
    private symlinks: SymlinkCache | undefined;【
    《/** @internal */》
    autoImportProviderHost: AutoImportProviderProject | false | undefined;】
    /** @internal */


Line 557:
【TS: PropertyDeclaration [17681, 17764)】
《Go: JSDoc [17687, 17703)》
    private symlinks: SymlinkCache | undefined;
    /** @internal */
    autoImportProviderHost: AutoImportProviderProject | false | undefined;【
    《/** @internal */》
    protected typeAcquisition: TypeAcquisition | undefined;】
    /** @internal */


Line 559:
【TS: Identifier [17764, 17802)】
《Go: JSDoc [17770, 17786)》
    autoImportProviderHost: AutoImportProviderProject | false | undefined;
    /** @internal */
    protected typeAcquisition: TypeAcquisition | undefined;【
    《/** @internal */》
    createHash】: ((data: string) => string) | undefined = maybeBind(this.projectService.host, this.projectService.host.createHash);
    /** @internal*/ preferNonRecursiveWatch: boolean | undefined;


Line 561:
【TS: PropertyDeclaration [17918, 17985)】
《Go: JSDoc [17924, 17939)》
    protected typeAcquisition: TypeAcquisition | undefined;
    /** @internal */
    createHash: ((data: string) => string) | undefined = maybeBind(this.projectService.host, this.projectService.host.createHash);【
    《/** @internal*/》 preferNonRecursiveWatch: boolean | undefined;】



Line 564:
【TS: Constructor [18049, 21797)】
《Go: JSDoc [18057, 18073)》
    /** @internal*/ preferNonRecursiveWatch: boolean | undefined;

    readonly jsDocParsingMode: JSDocParsingMode | undefined;【

    《/** @internal */》
    constructor(
        projectName: string,
        readonly projectKind: ProjectKind,
        readonly projectService: ProjectService,
        hasExplicitListOfFiles: boolean,
        lastFileExceededProgramSize: string | undefined,
        private compilerOptions: CompilerOptions,
        public compileOnSaveEnabled: boolean,
        protected watchOptions: WatchOptions | undefined,
        directoryStructureHost: DirectoryStructureHost,
        currentDirectory: string,
    ) {
        projectService.logger.info(`Creating ${ProjectKind[projectKind]}Project: ${projectName}, currentDirectory: ${currentDirectory}`);
        this.projectName = projectName;
        this.directoryStructureHost = directoryStructureHost;
        this.currentDirectory = this.projectService.getNormalizedAbsolutePath(currentDirectory);
        this.getCanonicalFileName = this.projectService.toCanonicalFileName;
        this.jsDocParsingMode = this.projectService.jsDocParsingMode;

        this.cancellationToken = new ThrottledCancellationToken(this.projectService.cancellationToken, this.projectService.throttleWaitMilliseconds);
        if (!this.compilerOptions) {
            this.compilerOptions = getDefaultCompilerOptions();
            this.compilerOptions.allowNonTsExtensions = true;
            this.compilerOptions.allowJs = true;
        }
        else if (hasExplicitListOfFiles || getAllowJSCompilerOption(this.compilerOptions) || this.projectService.hasDeferredExtension()) {
            // If files are listed explicitly or allowJs is specified, allow all extensions
            this.compilerOptions.allowNonTsExtensions = true;
        }
        switch (projectService.serverMode) {
            case LanguageServiceMode.Semantic:
                this.languageServiceEnabled = true;
                break;
            case LanguageServiceMode.PartialSemantic:
                this.languageServiceEnabled = true;
                this.compilerOptions.noResolve = true;
                this.compilerOptions.types = [];
                break;
            case LanguageServiceMode.Syntactic:
                this.languageServiceEnabled = false;
                this.compilerOptions.noResolve = true;
                this.compilerOptions.types = [];
                break;
            default:
                Debug.assertNever(projectService.serverMode);
        }

        this.setInternalCompilerOptionsForEmittingJsFiles();
        const host = this.projectService.host;
        if (this.projectService.logger.loggingEnabled()) {
            this.trace = s => this.writeLog(s);
        }
        else if (host.trace) {
            this.trace = s => host.trace!(s);
        }
        this.realpath = maybeBind(host, host.realpath);
        this.preferNonRecursiveWatch = this.projectService.canUseWatchEvents || host.preferNonRecursiveWatch;

        // Use the current directory as resolution root only if the project created using current directory string
        this.resolutionCache = createResolutionCache(
            this,
            this.currentDirectory,
            /*logChangesWhenResolvingModule*/ true,
        );
        this.languageService = createLanguageService(
            this,
            this.projectService.documentRegistry,
            this.projectService.serverMode,
        );
        if (lastFileExceededProgramSize) {
            this.disableLanguageService(lastFileExceededProgramSize);
        }
        this.markAsDirty();
        if (!isBackgroundProject(this)) {
            this.projectService.pendingEnsureProjectForOpenFiles = true;
        }
        this.projectService.onProjectCreation(this);
    }】



Line 651:
【TS: Identifier [22213, 22272)】
《Go: JSDoc [22221, 22237)》
    installPackage(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult> {
        return this.projectService.typingsInstaller.installPackage({ ...options, projectName: this.projectName, projectRootPath: this.toPath(this.currentDirectory) });
    }【

    《/** @internal */》
    getGlobalTypingsCacheLocation】(): string | undefined {
        return this.getTypeAcquisition().enable ? this.projectService.typingsInstaller.globalTypingsCacheLocation : undefined;


Line 656:
【TS: Identifier [22431, 22476)】
《Go: JSDoc [22439, 22455)》
    getGlobalTypingsCacheLocation(): string | undefined {
        return this.getTypeAcquisition().enable ? this.projectService.typingsInstaller.globalTypingsCacheLocation : undefined;
    }【

    《/** @internal */》
    getSymlinkCache】(): SymlinkCache {
        if (!this.symlinks) {


Line 788:
【TS: Identifier [27268, 27323)】
《Go: JSDoc [27276, 27292)》
        return !!this.projectService.getScriptInfoForPath(path) ||
            (!this.isWatchedMissingFile(path) && this.directoryStructureHost.fileExists(file));
    }【

    《/** @internal */》
    resolveModuleNameLiterals】(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[] {
        return this.resolutionCache.resolveModuleNameLiterals(moduleLiterals, containingFile, redirectedReference, options, containingSourceFile, reusedNames);


Line 793:
【TS: Identifier [27789, 27843)】
《Go: JSDoc [27797, 27813)》
    resolveModuleNameLiterals(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[] {
        return this.resolutionCache.resolveModuleNameLiterals(moduleLiterals, containingFile, redirectedReference, options, containingSourceFile, reusedNames);
    }【

    《/** @internal */》
    getModuleResolutionCache】(): ModuleResolutionCache | undefined {
        return this.resolutionCache.getModuleResolutionCache();


Line 798:
【TS: MethodDeclaration [27954, 28641)】
《Go: JSDoc [27962, 27978)》
    getModuleResolutionCache(): ModuleResolutionCache | undefined {
        return this.resolutionCache.getModuleResolutionCache();
    }【

    《/** @internal */》
    resolveTypeReferenceDirectiveReferences<T extends string | FileReference>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[] {
        return this.resolutionCache.resolveTypeReferenceDirectiveReferences(
            typeDirectiveReferences,
            containingFile,
            redirectedReference,
            options,
            containingSourceFile,
            reusedNames,
        );
    }】



Line 810:
【TS: Identifier [28641, 28685)】
《Go: JSDoc [28649, 28665)》
            reusedNames,
        );
    }【

    《/** @internal */》
    resolveLibrary】(libraryName: string, resolveFrom: string, options: CompilerOptions, libFileName: string): ResolvedModuleWithFailedLookupLocations {
        return this.resolutionCache.resolveLibrary(libraryName, resolveFrom, options, libFileName);


Line 823:
【TS: Identifier [29206, 29267)】
《Go: JSDoc [29214, 29230)》
    getDirectories(path: string): string[] {
        return this.directoryStructureHost.getDirectories!(path); // TODO: GH#18217
    }【

    《/** @internal */》
    getCachedDirectoryStructureHost】(): CachedDirectoryStructureHost {
        return undefined!; // TODO: GH#18217


Line 828:
【TS: Identifier [29354, 29390)】
《Go: JSDoc [29362, 29378)》
    getCachedDirectoryStructureHost(): CachedDirectoryStructureHost {
        return undefined!; // TODO: GH#18217
    }【

    《/** @internal */》
    toPath】(fileName: string): Path {
        return toPath(fileName, this.currentDirectory, this.projectService.toCanonicalFileName);


Line 833:
【TS: Identifier [29521, 29587)】
《Go: JSDoc [29529, 29545)》
    toPath(fileName: string): Path {
        return toPath(fileName, this.currentDirectory, this.projectService.toCanonicalFileName);
    }【

    《/** @internal */》
    watchDirectoryOfFailedLookupLocation】(directory: string, cb: DirectoryWatcherCallback, flags: WatchDirectoryFlags): FileWatcher {
        return this.projectService.watchFactory.watchDirectory(


Line 845:
【TS: Identifier [29945, 30001)】
《Go: JSDoc [29953, 29969)》
            this,
        );
    }【

    《/** @internal */》
    watchAffectingFileLocation】(file: string, cb: FileWatcherCallback): FileWatcher {
        return this.projectService.watchFactory.watchFile(


Line 857:
【TS: Identifier [30326, 30400)】
《Go: JSDoc [30334, 30350)》
            this,
        );
    }【

    《/** @internal */》
    clearInvalidateResolutionOfFailedLookupTimer】(): boolean {
        return this.projectService.throttledOperations.cancel(`${this.getProjectName()}FailedLookupInvalidation`);


Line 862:
【TS: Identifier [30536, 30618)】
《Go: JSDoc [30544, 30560)》
    clearInvalidateResolutionOfFailedLookupTimer(): boolean {
        return this.projectService.throttledOperations.cancel(`${this.getProjectName()}FailedLookupInvalidation`);
    }【

    《/** @internal */》
    scheduleInvalidateResolutionsOfFailedLookupLocations】(): void {
        this.projectService.throttledOperations.schedule(`${this.getProjectName()}FailedLookupInvalidation`, /*delay*/ 1000, () => {


Line 871:
【TS: Identifier [30990, 31064)】
《Go: JSDoc [30998, 31014)》
            }
        });
    }【

    《/** @internal */》
    invalidateResolutionsOfFailedLookupLocations】(): void {
        if (


Line 882:
【TS: Identifier [31368, 31421)】
《Go: JSDoc [31376, 31392)》
            this.projectService.delayEnsureProjectForOpenFiles();
        }
    }【

    《/** @internal */》
    onInvalidatedResolution】(): void {
        this.projectService.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(this);


Line 887:
【TS: Identifier [31535, 31588)】
《Go: JSDoc [31543, 31559)》
    onInvalidatedResolution(): void {
        this.projectService.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(this);
    }【

    《/** @internal */》
    watchTypeRootsDirectory】(directory: string, cb: DirectoryWatcherCallback, flags: WatchDirectoryFlags): FileWatcher {
        return this.projectService.watchFactory.watchDirectory(


Line 899:
【TS: Identifier [31934, 32001)】
《Go: JSDoc [31942, 31958)》
            this,
        );
    }【

    《/** @internal */》
    hasChangedAutomaticTypeDirectiveNames】(): boolean {
        return this.resolutionCache.hasChangedAutomaticTypeDirectiveNames();


Line 904:
【TS: Identifier [32099, 32165)】
《Go: JSDoc [32107, 32123)》
    hasChangedAutomaticTypeDirectiveNames(): boolean {
        return this.resolutionCache.hasChangedAutomaticTypeDirectiveNames();
    }【

    《/** @internal */》
    onChangedAutomaticTypeDirectiveNames】(): void {
        this.projectService.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(this);


Line 909:
【TS: Identifier [32279, 32340)】
《Go: JSDoc [32287, 32303)》
    onChangedAutomaticTypeDirectiveNames(): void {
        this.projectService.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(this);
    }【

    《/** @internal */》
    globalCacheResolutionModuleName】: typeof JsTyping.nonRelativeModuleNameForTypingCache = JsTyping.nonRelativeModuleNameForTypingCache;



Line 912:
【TS: Identifier [32441, 32481)】
《Go: JSDoc [32449, 32465)》

    /** @internal */
    globalCacheResolutionModuleName: typeof JsTyping.nonRelativeModuleNameForTypingCache = JsTyping.nonRelativeModuleNameForTypingCache;【

    《/** @internal */》
    fileIsOpen】(filePath: Path): boolean {
        return this.projectService.openFiles.has(filePath);


Line 917:
【TS: Identifier [32576, 32614)】
《Go: JSDoc [32584, 32600)》
    fileIsOpen(filePath: Path): boolean {
        return this.projectService.openFiles.has(filePath);
    }【

    《/** @internal */》
    writeLog】(s: string): void {
        this.projectService.logger.info(s);


Line 936:
【TS: Identifier [33085, 33196)】
《Go: JSDoc [33093, 33168)》
            this.compilerOptions.noEmitForJsFiles = true;
        }
    }【

    《/**
     * Get the errors that dont have any file name associated
     */》
    getGlobalProjectErrors】(): readonly Diagnostic[] {
        return filter(this.projectErrors, diagnostic => !diagnostic.file) || emptyArray;


Line 938:
【TS: JSDoc [33093, 33168)】
《Go: JSDocText [33093, 33166)》
    }

    【《/**
     * Get the errors that dont have any file name associated
     》*/】
    getGlobalProjectErrors(): readonly Diagnostic[] {


Line 943:
【TS: Identifier [33320, 33400)】
《Go: JSDoc [33328, 33375)》
    getGlobalProjectErrors(): readonly Diagnostic[] {
        return filter(this.projectErrors, diagnostic => !diagnostic.file) || emptyArray;
    }【

    《/**
     * Get all the project errors
     */》
    getAllProjectErrors】(): readonly Diagnostic[] {
        return this.projectErrors || emptyArray;


Line 945:
【TS: JSDoc [33328, 33375)】
《Go: JSDocText [33328, 33373)》
    }

    【《/**
     * Get all the project errors
     》*/】
    getAllProjectErrors(): readonly Diagnostic[] {


Line 961:
【TS: Identifier [33813, 33858)】
《Go: JSDoc [33821, 33837)》
        }
        return this.languageService;
    }【

    《/** @internal */》
    getSourceMapper】(): SourceMapper {
        return this.getLanguageService().getSourceMapper();


Line 966:
【TS: Identifier [33944, 33996)】
《Go: JSDoc [33952, 33968)》
    getSourceMapper(): SourceMapper {
        return this.getLanguageService().getSourceMapper();
    }【

    《/** @internal */》
    clearSourceMapperCache】(): void {
        this.languageService.clearSourceMapperCache();


Line 971:
【TS: Identifier [34069, 34124)】
《Go: JSDoc [34077, 34093)》
    clearSourceMapperCache(): void {
        this.languageService.clearSourceMapperCache();
    }【

    《/** @internal */》
    getDocumentPositionMapper】(generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined {
        return this.projectService.getDocumentPositionMapper(this, generatedFileName, sourceFileName);


Line 976:
【TS: Identifier [34325, 34372)】
《Go: JSDoc [34333, 34349)》
    getDocumentPositionMapper(generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined {
        return this.projectService.getDocumentPositionMapper(this, generatedFileName, sourceFileName);
    }【

    《/** @internal */》
    getSourceFileLike】(fileName: string): SourceFileLike | undefined {
        return this.projectService.getSourceFileLike(fileName, this);


Line 981:
【TS: Identifier [34498, 34542)】
《Go: JSDoc [34506, 34522)》
    getSourceFileLike(fileName: string): SourceFileLike | undefined {
        return this.projectService.getSourceFileLike(fileName, this);
    }【

    《/** @internal */》
    shouldEmitFile】(scriptInfo: ScriptInfo | undefined): boolean | undefined {
        return scriptInfo &&


Line 1006:
【TS: Identifier [35532, 35609)】
《Go: JSDoc [35540, 35595)》
            sourceFile => this.shouldEmitFile(this.projectService.getScriptInfoForPath(sourceFile.path)) ? sourceFile.fileName : undefined,
        );
    }【

    《/**
     * Returns true if emit was conducted
     */》
    emitFile】(scriptInfo: ScriptInfo, writeFile: (path: string, data: string, writeByteOrderMark?: boolean) => void): EmitResult {
        if (!this.languageServiceEnabled || !this.shouldEmitFile(scriptInfo)) {


Line 1008:
【TS: JSDoc [35540, 35595)】
《Go: JSDocText [35540, 35593)》
    }

    【《/**
     * Returns true if emit was conducted
     》*/】
    emitFile(scriptInfo: ScriptInfo, writeFile: (path: string, data: string, writeByteOrderMark?: boolean) => void): EmitResult {


Line 1045:
【TS: Identifier [37505, 37549)】
《Go: JSDoc [37513, 37529)》
        this.lastFileExceededProgramSize = undefined;
        this.projectService.onUpdateLanguageServiceStateForProject(this, /*languageServiceEnabled*/ true);
    }【

    《/** @internal */》
    cleanupProgram】(): void {
        if (this.program) {


Line 1111:
【TS: Identifier [40228, 40283)】
《Go: JSDoc [40236, 40252)》
        }
        return this.program.getSourceFileByPath(path);
    }【

    《/** @internal */》
    getSourceFileOrConfigFile】(path: Path): SourceFile | undefined {
        const options = this.program!.getCompilerOptions();


Line 1188:
【TS: MethodDeclaration [43534, 43606)】
《Go: JSDoc [43542, 43558)》
    hasRoots(): boolean {
        return !!this.rootFilesMap?.size;
    }【

    《/** @internal */》
    isOrphan() {
        return false;
    }】



Line 1197:
【TS: Identifier [43785, 43830)】
《Go: JSDoc [43793, 43809)》
    getRootFiles(): NormalizedPath[] {
        return this.rootFilesMap && arrayFrom(ts.mapDefinedIterator(this.rootFilesMap.values(), value => value.info?.fileName));
    }【

    《/** @internal */》
    getRootFilesMap】(): Map<Path, ProjectRootFile> {
        return this.rootFilesMap;


Line 1259:
【TS: Identifier [46307, 46365)】
《Go: JSDoc [46315, 46331)》
        }
        return result;
    }【

    《/** @internal */》
    getFileNamesWithRedirectInfo】(includeProjectReferenceRedirectInfo: boolean): protocol.FileWithProjectReferenceRedirectInfo[] {
        return this.getFileNames().map((fileName): protocol.FileWithProjectReferenceRedirectInfo => ({


Line 1345:
【TS: Identifier [49563, 49608)】
《Go: JSDoc [49571, 49587)》
    registerFileUpdate(fileName: string): void {
        (this.updatedFileNames || (this.updatedFileNames = new Set<string>())).add(fileName);
    }【

    《/** @internal */》
    markFileAsDirty】(changedFile: Path): void {
        this.markAsDirty();


Line 1353:
【TS: Identifier [49834, 49875)】
《Go: JSDoc [49842, 49858)》
            (this.changedFilesForExportMapCache ||= new Set()).add(changedFile);
        }
    }【

    《/** @internal */》
    markAsDirty】(): void {
        if (!this.dirty) {


Line 1361:
【TS: Identifier [50004, 50063)】
《Go: JSDoc [50012, 50028)》
            this.dirty = true;
        }
    }【

    《/** @internal */》
    markAutoImportProviderAsDirty】(): void {
        if (!this.autoImportProviderHost) this.autoImportProviderHost = undefined;


Line 1367:
【TS: Identifier [50217, 50282)】
《Go: JSDoc [50225, 50241)》
        if (!this.autoImportProviderHost) this.autoImportProviderHost = undefined;
        this.autoImportProviderHost?.markAsDirty();
    }【

    《/** @internal */》
    onAutoImportProviderSettingsChanged】(): void {
        this.markAutoImportProviderAsDirty();


Line 1372:
【TS: Identifier [50346, 50395)】
《Go: JSDoc [50354, 50370)》
    onAutoImportProviderSettingsChanged(): void {
        this.markAutoImportProviderAsDirty();
    }【

    《/** @internal */》
    onPackageJsonChange】(): void {
        this.moduleSpecifierCache.clear();


Line 1378:
【TS: Identifier [50503, 50553)】
《Go: JSDoc [50511, 50527)》
        this.moduleSpecifierCache.clear();
        this.markAutoImportProviderAsDirty();
    }【

    《/** @internal */》
    onFileAddedOrRemoved】(isSymlink: boolean | undefined): void {
        this.hasAddedorRemovedFiles = true;


Line 1386:
【TS: Identifier [50734, 50783)】
《Go: JSDoc [50742, 50758)》
            this.hasAddedOrRemovedSymlinks = true;
        }
    }【

    《/** @internal */》
    onDiscoveredSymlink】(): void {
        this.hasAddedOrRemovedSymlinks = true;


Line 1391:
【TS: Identifier [50848, 50900)】
《Go: JSDoc [50856, 50872)》
    onDiscoveredSymlink(): void {
        this.hasAddedOrRemovedSymlinks = true;
    }【

    《/** @internal */》
    onReleaseOldSourceFile】(
        oldSourceFile: SourceFile,


Line 1409:
【TS: PropertyDeclaration [51661, 51727)】
《Go: JSDoc [51669, 51685)》
            this.detachScriptInfoFromProject(oldSourceFile.fileName, hasSourceFileByPath);
        }
    }【

    《/** @internal */》
    updateFromProjectInProgress = false;】



Line 1412:
【TS: Identifier [51727, 51774)】
《Go: JSDoc [51735, 51751)》

    /** @internal */
    updateFromProjectInProgress = false;【

    《/** @internal */》
    updateFromProject】(): void {
        updateProjectIfDirty(this);


Line 1417:
【TS: Identifier [51828, 52018)】
《Go: JSDoc [51836, 52001)》
    updateFromProject(): void {
        updateProjectIfDirty(this);
    }【

    《/**
     * Updates set of files that contribute to this project
     * @returns: true if set of files in the project stays the same and false - otherwise.
     */》
    updateGraph】(): boolean {
        tracing?.push(tracing.Phase.Session, "updateGraph", { name: this.projectName, kind: ProjectKind[this.projectKind] });


Line 1419:
【TS: JSDoc [51836, 52001)】
《Go: JSDocText [51836, 51909)》
    }

    【《/**
     * Updates set of files that contribute to this project
     * 》@returns: true if set of files in the project stays the same and false - otherwise.
     */】
    updateGraph(): boolean {


Line 1421:
【TS: JSDocReturnTag [51909, 51999)】
《Go: JSDocText [51917, 51999)》
    /**
     * Updates set of files that contribute to this project
     * 【@returns《: true if set of files in the project stays the same and false - otherwise.
     】》*/
    updateGraph(): boolean {


Line 1471:
【TS: Identifier [54589, 54650)】
《Go: JSDoc [54597, 54613)》
        tracing?.pop();
        return !hasNewProgram;
    }【

    《/** @internal */》
    enqueueInstallTypingsForProject】(forceRefresh: boolean): void {
        const typeAcquisition = this.getTypeAcquisition();


Line 1499:
【TS: Identifier [55989, 56036)】
《Go: JSDoc [55997, 56013)》
            this.projectService.typingsInstaller.enqueueInstallTypingsRequest(this, typeAcquisition, this.lastCachedUnresolvedImportsList);
        }
    }【

    《/** @internal */》
    updateTypingFiles】(compilerOptions: CompilerOptions, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string>, newTypings: string[]): void {
        this.typingsCache = {


Line 1526:
【TS: Identifier [57465, 57515)】
《Go: JSDoc [57473, 57489)》
        this.typingWatchers!.isInvoked = true;
        this.projectService.updateTypingsForProject({ projectName: this.getProjectName(), kind: ActionInvalidate });
    }【

    《/** @internal */》
    watchTypingLocations】(files: readonly string[] | undefined): void {
        if (!files) {


Line 1624:
【TS: Identifier [62594, 62641)】
《Go: JSDoc [62602, 62618)》
            this.typingWatchers!.delete(path);
        });
    }【

    《/** @internal */》
    getCurrentProgram】(): Program | undefined {
        return this.program;


Line 1792:
【TS: Identifier [71415, 71465)】
《Go: JSDoc [71423, 71439)》
        this.projectService.verifyDocumentRegistry();
        return hasNewProgram;
    }【

    《/** @internal */》
    sendPerformanceEvent】(kind: PerformanceEvent["kind"], durationMs: number): void {
        this.projectService.sendPerformanceEvent(kind, durationMs);


Line 1840:
【TS: Identifier [73727, 73778)】
《Go: JSDoc [73735, 73751)》
    private isWatchedMissingFile(path: Path) {
        return !!this.missingFilesMap && this.missingFilesMap.has(path);
    }【

    《/** @internal */》
    addGeneratedFileWatch】(generatedFile: string, sourceFile: string): void {
        if (this.compilerOptions.outFile) {


Line 1931:
【TS: Identifier [77585, 77620)】
《Go: JSDoc [77593, 77609)》
        }
        return strBuilder;
    }【

    《/** @internal */》
    print】(writeProjectFileNames: boolean, writeFileExplaination: boolean, writeFileVersionAndText: boolean): void {
        this.writeLog(`Project '${this.projectName}' (${ProjectKind[this.projectKind]})`);


Line 1964:
【TS: Identifier [79547, 79592)】
《Go: JSDoc [79555, 79571)》
            this.markAsDirty();
        }
    }【

    《/** @internal */》
    setWatchOptions】(watchOptions: WatchOptions | undefined): void {
        this.watchOptions = watchOptions;


Line 1969:
【TS: Identifier [79690, 79735)】
《Go: JSDoc [79698, 79714)》
    setWatchOptions(watchOptions: WatchOptions | undefined): void {
        this.watchOptions = watchOptions;
    }【

    《/** @internal */》
    getWatchOptions】(): WatchOptions | undefined {
        return this.watchOptions;


Line 1984:
【TS: Identifier [80141, 80193)】
《Go: JSDoc [80149, 80165)》
    getTypeAcquisition(): TypeAcquisition {
        return this.typeAcquisition || {};
    }【

    《/** @internal */》
    getChangesSinceVersion】(lastKnownVersion?: number, includeProjectReferenceRedirectInfo?: boolean): ProjectFilesWithTSDiagnostics {
        const includeProjectReferenceRedirectInfoIfRequested = includeProjectReferenceRedirectInfo


Line 2094:
【TS: Identifier [85910, 85974)】
《Go: JSDoc [85918, 85934)》
    protected removeRoot(info: ScriptInfo): void {
        this.rootFilesMap.delete(info.path);
    }【

    《/** @internal */》
    isSourceOfProjectReferenceRedirect】(fileName: string): boolean {
        return !!this.program && this.program.isSourceOfProjectReferenceRedirect(fileName);


Line 2099:
【TS: ProtectedKeyword [86103, 86142)】
《Go: JSDoc [86111, 86127)》
    isSourceOfProjectReferenceRedirect(fileName: string): boolean {
        return !!this.program && this.program.isSourceOfProjectReferenceRedirect(fileName);
    }【

    《/** @internal */》
    protected】 getGlobalPluginSearchPaths(): string[] {
        // Search any globally-specified probe paths, then our peer node_modules


Line 2138:
【TS: Identifier [87936, 87977)】
《Go: JSDoc [87944, 87960)》
    protected enablePlugin(pluginConfigEntry: PluginImport, searchPaths: string[]): void {
        this.projectService.requestEnablePlugin(this, pluginConfigEntry, searchPaths);
    }【

    《/** @internal */》
    enableProxy】(pluginModuleFactory: PluginModuleFactory, configEntry: PluginImport): void {
        try {


Line 2173:
【TS: Identifier [89542, 89600)】
《Go: JSDoc [89550, 89566)》
            this.projectService.logger.info(`Plugin activation failed: ${e}`);
        }
    }【

    《/** @internal */》
    onPluginConfigurationChanged】(pluginName: string, configuration: any): void {
        this.plugins.filter(plugin => plugin.name === pluginName).forEach(plugin => {


Line 2182:
【TS: Identifier [89897, 90050)】
《Go: JSDoc [89905, 90026)》
            }
        });
    }【

    《/** Starts a new check for diagnostics. Call this if some file has updated that would cause diagnostics to be changed. */》
    refreshDiagnostics】(): void {
        this.projectService.sendProjectsUpdatedInBackgroundEvent();


Line 2184:
【TS: JSDoc [89905, 90026)】
《Go: JSDocText [89905, 90024)》
    }

    【《/** Starts a new check for diagnostics. Call this if some file has updated that would cause diagnostics to be changed. 》*/】
    refreshDiagnostics(): void {


Line 2187:
【TS: Identifier [90136, 90194)】
《Go: JSDoc [90144, 90160)》
    refreshDiagnostics(): void {
        this.projectService.sendProjectsUpdatedInBackgroundEvent();
    }【

    《/** @internal */》
    getPackageJsonsVisibleToFile】(fileName: string, rootDir?: string): readonly ProjectPackageJsonInfo[] {
        if (this.projectService.serverMode !== LanguageServiceMode.Semantic) return emptyArray;


Line 2193:
【TS: Identifier [90462, 90534)】
《Go: JSDoc [90470, 90486)》
        if (this.projectService.serverMode !== LanguageServiceMode.Semantic) return emptyArray;
        return this.projectService.getPackageJsonsVisibleToFile(fileName, this, rootDir);
    }【

    《/** @internal */》
    getNearestAncestorDirectoryWithPackageJson】(fileName: string): string | undefined {
        return this.projectService.getNearestAncestorDirectoryWithPackageJson(fileName, this);


Line 2198:
【TS: Identifier [90677, 90735)】
《Go: JSDoc [90685, 90701)》
    getNearestAncestorDirectoryWithPackageJson(fileName: string): string | undefined {
        return this.projectService.getNearestAncestorDirectoryWithPackageJson(fileName, this);
    }【

    《/** @internal */》
    getPackageJsonsForAutoImport】(rootDir?: string): readonly ProjectPackageJsonInfo[] {
        return this.getPackageJsonsVisibleToFile(combinePaths(this.currentDirectory, inferredTypesContainingFile), rootDir);


Line 2203:
【TS: Identifier [90923, 90972)】
《Go: JSDoc [90931, 90947)》
    getPackageJsonsForAutoImport(rootDir?: string): readonly ProjectPackageJsonInfo[] {
        return this.getPackageJsonsVisibleToFile(combinePaths(this.currentDirectory, inferredTypesContainingFile), rootDir);
    }【

    《/** @internal */》
    getPackageJsonCache】(): PackageJsonCache {
        return this.projectService.packageJsonCache;


Line 2208:
【TS: Identifier [91055, 91107)】
《Go: JSDoc [91063, 91079)》
    getPackageJsonCache(): PackageJsonCache {
        return this.projectService.packageJsonCache;
    }【

    《/** @internal */》
    getCachedExportInfoMap】(): ExportInfoMap {
        return this.exportMapCache ||= createCacheableExportInfoMap(this);


Line 2213:
【TS: Identifier [91209, 91263)】
《Go: JSDoc [91217, 91233)》
    getCachedExportInfoMap(): ExportInfoMap {
        return this.exportMapCache ||= createCacheableExportInfoMap(this);
    }【

    《/** @internal */》
    clearCachedExportInfoMap】(): void {
        this.exportMapCache?.clear();


Line 2218:
【TS: Identifier [91319, 91372)】
《Go: JSDoc [91327, 91343)》
    clearCachedExportInfoMap(): void {
        this.exportMapCache?.clear();
    }【

    《/** @internal */》
    getModuleSpecifierCache】(): ModuleSpecifierCache {
        return this.moduleSpecifierCache;


Line 2223:
【TS: Identifier [91448, 91507)】
《Go: JSDoc [91456, 91472)》
    getModuleSpecifierCache(): ModuleSpecifierCache {
        return this.moduleSpecifierCache;
    }【

    《/** @internal */》
    includePackageJsonAutoImports】(): PackageJsonAutoImportPreference {
        if (


Line 2236:
【TS: Identifier [91977, 92035)】
《Go: JSDoc [91985, 92001)》
        }
        return this.projectService.includePackageJsonAutoImports();
    }【

    《/** @internal */》
    getHostForAutoImportProvider】(): GetPackageJsonEntrypointsHost {
        if (this.program) {


Line 2254:
【TS: Identifier [92984, 93046)】
《Go: JSDoc [92992, 93008)》
        }
        return this.projectService.host;
    }【

    《/** @internal */》
    getPackageJsonAutoImportProvider】(): Program | undefined {
        if (this.autoImportProviderHost === false) {


Line 2299:
【TS: Identifier [94892, 94959)】
《Go: JSDoc [94900, 94916)》
            (_projectRootPath, path) => this.projectService.tryGetDefaultProjectForFile(this.projectService.getScriptInfoForPath(path)!) === this,
        );
    }【

    《/** @internal */》
    watchNodeModulesForPackageJsonChanges】(directoryPath: string): FileWatcher {
        return this.projectService.watchPackageJsonsInNodeModules(directoryPath, this);


Line 2304:
【TS: Identifier [95093, 95152)】
《Go: JSDoc [95101, 95117)》
    watchNodeModulesForPackageJsonChanges(directoryPath: string): FileWatcher {
        return this.projectService.watchPackageJsonsInNodeModules(directoryPath, this);
    }【

    《/** @internal */》
    getIncompleteCompletionsCache】(): IncompleteCompletionsCache {
        return this.projectService.getIncompleteCompletionsCache();


Line 2309:
【TS: Identifier [95260, 95315)】
《Go: JSDoc [95268, 95284)》
    getIncompleteCompletionsCache(): IncompleteCompletionsCache {
        return this.projectService.getIncompleteCompletionsCache();
    }【

    《/** @internal */》
    getNoDtsResolutionProject】(rootFile: NormalizedPath): AuxiliaryProject {
        Debug.assert(this.projectService.serverMode === LanguageServiceMode.Semantic);


Line 2323:
【TS: Identifier [95885, 95941)】
《Go: JSDoc [95893, 95909)》
        }
        return this.noDtsResolutionProject;
    }【

    《/** @internal */》
    runWithTemporaryFileUpdate】(rootFile: string, updatedText: string, cb: (updatedProgram: Program, originalProgram: Program | undefined, updatedFile: SourceFile) => void): void {
        const originalProgram = this.program;


Line 2339:
【TS: Identifier [96714, 96787)】
《Go: JSDoc [96722, 96738)》
            this.getScriptInfo(rootFile)?.editContent(0, updatedText.length, originalText);
        }
    }【

    《/** @internal */》
    getCompilerOptionsForNoDtsResolutionProject】(): CompilerOptions {
        return {


Line 2392:
【TS: ExportKeyword [98809, 98966)】
《Go: JSDoc [98813, 98958)》
        return unresolvedImports || emptyArray;
    });
}【

《/**
 * If a file is opened and no tsconfig (or jsconfig) is found,
 * the file and its imports/references are put into an InferredProject.
 */》
export】 class InferredProject extends Project {
    private _isJsInferredProject = false;


Line 2394:
【TS: JSDoc [98813, 98958)】
《Go: JSDocText [98813, 98956)》
}

【《/**
 * If a file is opened and no tsconfig (or jsconfig) is found,
 * the file and its imports/references are put into an InferredProject.
 》*/】
export class InferredProject extends Project {


Line 2422:
【TS: PropertyDeclaration [99980, 100081)】
《Go: JSDoc [99988, 100030)》
        newOptions.allowJs = true;
        super.setCompilerOptions(newOptions);
    }【

    《/** this is canonical project root path */》
    readonly projectRootPath: string | undefined;】



Line 2424:
【TS: JSDoc [99988, 100030)】
《Go: JSDocText [99988, 100028)》
    }

    【《/** this is canonical project root path 》*/】
    readonly projectRootPath: string | undefined;


Line 2425:
【TS: PropertyDeclaration [100081, 100277)】
《Go: JSDoc [100089, 100216)》

    /** this is canonical project root path */
    readonly projectRootPath: string | undefined;【

    《/**
     * stored only if their is no projectRootPath and this isnt single inferred project
     *
     * @internal
     */》
    readonly canonicalCurrentDirectory: string | undefined;】



Line 2427:
【TS: JSDoc [100089, 100216)】
《Go: JSDocText [100089, 100198)》
    readonly projectRootPath: string | undefined;

    【《/**
     * stored only if their is no projectRootPath and this isnt single inferred project
     *
     * 》@internal
     */】
    readonly canonicalCurrentDirectory: string | undefined;


Line 2432:
【TS: Constructor [100277, 101436)】
《Go: JSDoc [100285, 100301)》
     * @internal
     */
    readonly canonicalCurrentDirectory: string | undefined;【

    《/** @internal */》
    constructor(
        projectService: ProjectService,
        compilerOptions: CompilerOptions,
        watchOptions: WatchOptions | undefined,
        projectRootPath: NormalizedPath | undefined,
        currentDirectory: string,
        typeAcquisition: TypeAcquisition | undefined,
    ) {
        super(
            projectService.newInferredProjectName(),
            ProjectKind.Inferred,
            projectService,
            /*hasExplicitListOfFiles*/ false,
            /*lastFileExceededProgramSize*/ undefined,
            compilerOptions,
            /*compileOnSaveEnabled*/ false,
            watchOptions,
            projectService.host,
            currentDirectory,
        );
        this.typeAcquisition = typeAcquisition;
        this.projectRootPath = projectRootPath && projectService.toCanonicalFileName(projectRootPath);
        if (!projectRootPath && !projectService.useSingleInferredProject) {
            this.canonicalCurrentDirectory = projectService.toCanonicalFileName(this.currentDirectory);
        }
        this.enableGlobalPlugins(this.getCompilerOptions());
    }】



Line 2484:
【TS: OverrideKeyword [102510, 102548)】
《Go: JSDoc [102518, 102534)》
            }
        }
    }【

    《/** @internal */》
    override】 isOrphan(): boolean {
        return !this.hasRoots();


Line 2511:
【TS: ExportKeyword [103460, 103488)】
《Go: JSDoc [103464, 103480)》
        };
    }
}【

《/** @internal */》
export】 class AuxiliaryProject extends Project {
    /** @internal */ rootFile: NormalizedPath | undefined;


Line 2514:
【TS: PropertyDeclaration [103529, 103589)】
《Go: JSDoc [103535, 103551)》

/** @internal */
export class AuxiliaryProject extends Project {【
    《/** @internal */》 rootFile: NormalizedPath | undefined;】
    constructor(hostProject: Project) {


Line 2542:
【TS: StaticKeyword [104513, 104549)】
《Go: JSDoc [104521, 104537)》

export class AutoImportProviderProject extends Project {
    private static readonly maxDependencies = 10;【

    《/** @internal */》
    static】 getRootFileNames(dependencySelection: PackageJsonAutoImportPreference, hostProject: Project, host: GetPackageJsonEntrypointsHost, compilerOptions: CompilerOptions): string[] {
        if (!dependencySelection) {


Line 2708:
【TS: StaticKeyword [113114, 113150)】
《Go: JSDoc [113122, 113138)》
            });
        }
    }【

    《/** @internal */》
    static】 readonly compilerOptionsOverrides: CompilerOptions = {
        diagnostics: false,


Line 2718:
【TS: StaticKeyword [113380, 113416)】
《Go: JSDoc [113388, 113404)》
        lib: ts.emptyArray,
        noLib: true,
    };【

    《/** @internal */》
    static】 create(
        dependencySelection: PackageJsonAutoImportPreference,


Line 2743:
【TS: Constructor [114210, 115178)】
《Go: JSDoc [114218, 114234)》
    }

    private rootFileNames: string[] | undefined;【

    《/** @internal */》
    constructor(
        private hostProject: Project,
        initialRootNames: string[],
        compilerOptions: CompilerOptions,
    ) {
        super(
            hostProject.projectService.newAutoImportProviderProjectName(),
            ProjectKind.AutoImportProvider,
            hostProject.projectService,
            /*hasExplicitListOfFiles*/ false,
            /*lastFileExceededProgramSize*/ undefined,
            compilerOptions,
            /*compileOnSaveEnabled*/ false,
            hostProject.getWatchOptions(),
            hostProject.projectService.host,
            hostProject.currentDirectory,
        );

        this.rootFileNames = initialRootNames;
        this.useSourceOfProjectReferenceRedirect = maybeBind(this.hostProject, this.hostProject.useSourceOfProjectReferenceRedirect);
        this.getParsedCommandLine = maybeBind(this.hostProject, this.hostProject.getParsedCommandLine);
    }】



Line 2767:
【TS: Identifier [115178, 115215)】
《Go: JSDoc [115186, 115202)》
        this.useSourceOfProjectReferenceRedirect = maybeBind(this.hostProject, this.hostProject.useSourceOfProjectReferenceRedirect);
        this.getParsedCommandLine = maybeBind(this.hostProject, this.hostProject.getParsedCommandLine);
    }【

    《/** @internal */》
    isEmpty】(): boolean {
        return !some(this.rootFileNames);


Line 2772:
【TS: OverrideKeyword [115278, 115316)】
《Go: JSDoc [115286, 115302)》
    isEmpty(): boolean {
        return !some(this.rootFileNames);
    }【

    《/** @internal */》
    override】 isOrphan() {
        return true;


Line 2798:
【TS: OverrideKeyword [116235, 116273)】
《Go: JSDoc [116243, 116259)》
        }
        return hasSameSetOfFiles;
    }【

    《/** @internal */》
    override】 scheduleInvalidateResolutionsOfFailedLookupLocations(): void {
        // Invalidation will happen on-demand as part of updateGraph


Line 2808:
【TS: OverrideKeyword [116521, 116559)】
《Go: JSDoc [116529, 116545)》
    override hasRoots(): boolean {
        return !!this.rootFileNames?.length;
    }【

    《/** @internal */》
    override】 markAsDirty(): void {
        this.rootFileNames = undefined;


Line 2822:
【TS: OverrideKeyword [116970, 117008)】
《Go: JSDoc [116978, 116994)》
    override getLanguageService(): never {
        throw new Error("AutoImportProviderProject language service should never be used. To get the program, use `project.getCurrentProgram()`.");
    }【

    《/** @internal */》
    override】 onAutoImportProviderSettingsChanged(): never {
        throw new Error("AutoImportProviderProject is an auto import provider; use `markAsDirty()` instead.");


Line 2827:
【TS: OverrideKeyword [117174, 117212)】
《Go: JSDoc [117182, 117198)》
    override onAutoImportProviderSettingsChanged(): never {
        throw new Error("AutoImportProviderProject is an auto import provider; use `markAsDirty()` instead.");
    }【

    《/** @internal */》
    override】 onPackageJsonChange(): never {
        throw new Error("package.json changes should be notified on an AutoImportProvider's host project");


Line 2840:
【TS: OverrideKeyword [117727, 117765)】
《Go: JSDoc [117735, 117751)》
    override getProjectReferences(): readonly ProjectReference[] | undefined {
        return this.hostProject.getProjectReferences();
    }【

    《/** @internal */》
    override】 includePackageJsonAutoImports(): PackageJsonAutoImportPreference {
        return PackageJsonAutoImportPreference.Off;


Line 2845:
【TS: OverrideKeyword [117892, 117930)】
《Go: JSDoc [117900, 117916)》
    override includePackageJsonAutoImports(): PackageJsonAutoImportPreference {
        return PackageJsonAutoImportPreference.Off;
    }【

    《/** @internal */》
    override】 getSymlinkCache(): SymlinkCache {
        return this.hostProject.getSymlinkCache();


Line 2850:
【TS: OverrideKeyword [118023, 118061)】
《Go: JSDoc [118031, 118047)》
    override getSymlinkCache(): SymlinkCache {
        return this.hostProject.getSymlinkCache();
    }【

    《/** @internal */》
    override】 getModuleResolutionCache(): ModuleResolutionCache | undefined {
        return this.hostProject.getCurrentProgram()?.getModuleResolutionCache();


Line 2856:
【TS: ExportKeyword [118217, 118418)】
《Go: JSDoc [118221, 118410)》
        return this.hostProject.getCurrentProgram()?.getModuleResolutionCache();
    }
}【

《/**
 * If a file is opened, the server will look for a tsconfig (or jsconfig)
 * and if successful create a ConfiguredProject for it.
 * Otherwise it will create an InferredProject.
 */》
export】 class ConfiguredProject extends Project {
    /** @internal */


Line 2858:
【TS: JSDoc [118221, 118410)】
《Go: JSDocText [118221, 118408)》
}

【《/**
 * If a file is opened, the server will look for a tsconfig (or jsconfig)
 * and if successful create a ConfiguredProject for it.
 * Otherwise it will create an InferredProject.
 》*/】
export class ConfiguredProject extends Project {


Line 2863:
【TS: PropertyDeclaration [118460, 118527)】
《Go: JSDoc [118466, 118482)》
 * Otherwise it will create an InferredProject.
 */
export class ConfiguredProject extends Project {【
    《/** @internal */》
    pendingUpdateLevel: ProgramUpdateLevel;】
    /** @internal */


Line 2865:
【TS: PropertyDeclaration [118527, 118595)】
《Go: JSDoc [118533, 118549)》
export class ConfiguredProject extends Project {
    /** @internal */
    pendingUpdateLevel: ProgramUpdateLevel;【
    《/** @internal */》
    pendingUpdateReason: string | undefined;】



Line 2867:
【TS: Identifier [118595, 118647)】
《Go: JSDoc [118603, 118619)》
    pendingUpdateLevel: ProgramUpdateLevel;
    /** @internal */
    pendingUpdateReason: string | undefined;【

    《/** @internal */》
    openFileWatchTriggered】: Map<string, ProgramUpdateLevel> = new Map();



Line 2870:
【TS: PropertyDeclaration [118693, 118772)】
《Go: JSDoc [118701, 118717)》

    /** @internal */
    openFileWatchTriggered: Map<string, ProgramUpdateLevel> = new Map();【

    《/** @internal */》
    parsedCommandLine: ParsedCommandLine | undefined;】
    /** @internal */


Line 2873:
【TS: PropertyDeclaration [118772, 118843)】
《Go: JSDoc [118778, 118794)》

    /** @internal */
    parsedCommandLine: ParsedCommandLine | undefined;【
    《/** @internal */》
    resolvedChildConfigs?: Set<NormalizedPath>;】



Line 2877:
【TS: PropertyDeclaration [118918, 119124)】
《Go: JSDoc [118926, 119058)》
    resolvedChildConfigs?: Set<NormalizedPath>;

    private projectReferences: readonly ProjectReference[] | undefined;【

    《/**
     * Potential project references before the project is actually loaded (read config file)
     *
     * @internal
     */》
    potentialProjectReferences: Set<NormalizedPath> | undefined;】



Line 2879:
【TS: JSDoc [118926, 119058)】
《Go: JSDocText [118926, 119040)》
    private projectReferences: readonly ProjectReference[] | undefined;

    【《/**
     * Potential project references before the project is actually loaded (read config file)
     *
     * 》@internal
     */】
    potentialProjectReferences: Set<NormalizedPath> | undefined;


Line 2884:
【TS: PropertyDeclaration [119124, 119193)】
《Go: JSDoc [119132, 119148)》
     * @internal
     */
    potentialProjectReferences: Set<NormalizedPath> | undefined;【

    《/** @internal */》
    projectOptions?: ProjectOptions | true;】



Line 2887:
【TS: PropertyDeclaration [119193, 119258)】
《Go: JSDoc [119201, 119217)》

    /** @internal */
    projectOptions?: ProjectOptions | true;【

    《/** @internal */》
    override initialLoadPending = true;】



Line 2890:
【TS: PropertyDeclaration [119258, 119321)】
《Go: JSDoc [119266, 119282)》

    /** @internal */
    override initialLoadPending = true;【

    《/** @internal */》
    sendLoadingProjectFinish = false;】



Line 2895:
【TS: PropertyDeclaration [119365, 119434)】
《Go: JSDoc [119373, 119389)》
    sendLoadingProjectFinish = false;

    private compilerHost?: CompilerHost;【

    《/** @internal */》
    configDiagDiagnosticsReported?: number;】



Line 2898:
【TS: PropertyDeclaration [119434, 119510)】
《Go: JSDoc [119442, 119458)》

    /** @internal */
    configDiagDiagnosticsReported?: number;【

    《/** @internal */》
    triggerFileForConfigFileDiag?: NormalizedPath;】



Line 2901:
【TS: PropertyDeclaration [119510, 119564)】
《Go: JSDoc [119518, 119534)》

    /** @internal */
    triggerFileForConfigFileDiag?: NormalizedPath;【

    《/** @internal */》
    deferredClose?: boolean;】



Line 2904:
【TS: Constructor [119564, 120426)】
《Go: JSDoc [119572, 119588)》

    /** @internal */
    deferredClose?: boolean;【

    《/** @internal */》
    constructor(
        configFileName: NormalizedPath,
        readonly canonicalConfigFilePath: NormalizedPath,
        projectService: ProjectService,
        cachedDirectoryStructureHost: CachedDirectoryStructureHost,
        pendingUpdateReason: string,
    ) {
        super(
            configFileName,
            ProjectKind.Configured,
            projectService,
            /*hasExplicitListOfFiles*/ false,
            /*lastFileExceededProgramSize*/ undefined,
            /*compilerOptions*/ {},
            /*compileOnSaveEnabled*/ false,
            /*watchOptions*/ undefined,
            cachedDirectoryStructureHost,
            getDirectoryPath(configFileName),
        );
        this.pendingUpdateLevel = ProgramUpdateLevel.Full;
        this.pendingUpdateReason = pendingUpdateReason;
    }】



Line 2928:
【TS: Identifier [120426, 120471)】
《Go: JSDoc [120434, 120450)》
        this.pendingUpdateLevel = ProgramUpdateLevel.Full;
        this.pendingUpdateReason = pendingUpdateReason;
    }【

    《/** @internal */》
    setCompilerHost】(host: CompilerHost): void {
        this.compilerHost = host;


Line 2933:
【TS: Identifier [120541, 120586)】
《Go: JSDoc [120549, 120565)》
    setCompilerHost(host: CompilerHost): void {
        this.compilerHost = host;
    }【

    《/** @internal */》
    getCompilerHost】(): CompilerHost | undefined {
        return this.compilerHost;


Line 2938:
【TS: OverrideKeyword [120658, 120696)】
《Go: JSDoc [120666, 120682)》
    getCompilerHost(): CompilerHost | undefined {
        return this.compilerHost;
    }【

    《/** @internal */》
    override】 useSourceOfProjectReferenceRedirect(): boolean {
        return this.languageServiceEnabled;


Line 2943:
【TS: OverrideKeyword [120797, 120835)】
《Go: JSDoc [120805, 120821)》
    override useSourceOfProjectReferenceRedirect(): boolean {
        return this.languageServiceEnabled;
    }【

    《/** @internal */》
    override】 getParsedCommandLine(fileName: string): ParsedCommandLine | undefined {
        const configFileName = toNormalizedPath(fileName);


Line 2961:
【TS: Identifier [122066, 122122)】
《Go: JSDoc [122074, 122090)》
        }
        return configFileExistenceInfo.exists ? configFileExistenceInfo.config!.parsedCommandLine : undefined;
    }【

    《/** @internal */》
    onReleaseParsedCommandLine】(fileName: string): void {
        this.releaseParsedConfig(asNormalizedPath(this.projectService.toCanonicalFileName(toNormalizedPath(fileName))));


Line 2971:
【TS: OverrideKeyword [122526, 122792)】
《Go: JSDoc [122534, 122778)》
        this.projectService.stopWatchingWildCards(canonicalConfigFilePath, this);
        this.projectService.releaseParsedConfig(canonicalConfigFilePath, this);
    }【

    《/**
     * If the project has reload from disk pending, it reloads (and then updates graph as part of that) instead of just updating the graph
     * @returns: true if set of files in the project stays the same and false - otherwise.
     */》
    override】 updateGraph(): boolean {
        if (this.deferredClose) return false;


Line 2973:
【TS: JSDoc [122534, 122778)】
《Go: JSDocText [122534, 122686)》
    }

    【《/**
     * If the project has reload from disk pending, it reloads (and then updates graph as part of that) instead of just updating the graph
     * 》@returns: true if set of files in the project stays the same and false - otherwise.
     */】
    override updateGraph(): boolean {


Line 2975:
【TS: JSDocReturnTag [122686, 122776)】
《Go: JSDocText [122694, 122776)》
    /**
     * If the project has reload from disk pending, it reloads (and then updates graph as part of that) instead of just updating the graph
     * 【@returns《: true if set of files in the project stays the same and false - otherwise.
     】》*/
    override updateGraph(): boolean {


Line 3018:
【TS: OverrideKeyword [124718, 124756)】
《Go: JSDoc [124726, 124742)》
        }
        return result;
    }【

    《/** @internal */》
    override】 getCachedDirectoryStructureHost() {
        return this.directoryStructureHost as CachedDirectoryStructureHost;


Line 3036:
【TS: Identifier [125294, 125352)】
《Go: JSDoc [125302, 125318)》
        this.projectReferences = refs;
        this.potentialProjectReferences = undefined;
    }【

    《/** @internal */》
    setPotentialProjectReference】(canonicalConfigPath: NormalizedPath): void {
        Debug.assert(this.initialLoadPending);


Line 3042:
【TS: OverrideKeyword [125570, 125608)】
《Go: JSDoc [125578, 125594)》
        Debug.assert(this.initialLoadPending);
        (this.potentialProjectReferences || (this.potentialProjectReferences = new Set())).add(canonicalConfigPath);
    }【

    《/** @internal */》
    override】 getResolvedProjectReferenceToRedirect(fileName: string): ResolvedProjectReference | undefined {
        const program = this.getCurrentProgram();


Line 3048:
【TS: MethodDeclaration [125846, 126105)】
《Go: JSDoc [125854, 125870)》
        const program = this.getCurrentProgram();
        return program && program.getResolvedProjectReferenceToRedirect(fileName);
    }【

    《/** @internal */》
    forEachResolvedProjectReference<T>(
        cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined,
    ): T | undefined {
        return this.getCurrentProgram()?.forEachResolvedProjectReference(cb);
    }】



Line 3055:
【TS: Identifier [126105, 126159)】
《Go: JSDoc [126113, 126129)》
    ): T | undefined {
        return this.getCurrentProgram()?.forEachResolvedProjectReference(cb);
    }【

    《/** @internal */》
    enablePluginsWithOptions】(options: CompilerOptions): void {
        this.plugins.length = 0;


Line 3082:
【TS: OverrideKeyword [127262, 127359)】
《Go: JSDoc [127270, 127345)》

        return this.enableGlobalPlugins(options);
    }【

    《/**
     * Get the errors that dont have any file name associated
     */》
    override】 getGlobalProjectErrors(): readonly Diagnostic[] {
        return filter(this.projectErrors, diagnostic => !diagnostic.file) || emptyArray;


Line 3084:
【TS: JSDoc [127270, 127345)】
《Go: JSDocText [127270, 127343)》
    }

    【《/**
     * Get the errors that dont have any file name associated
     》*/】
    override getGlobalProjectErrors(): readonly Diagnostic[] {


Line 3089:
【TS: OverrideKeyword [127506, 127575)】
《Go: JSDoc [127514, 127561)》
    override getGlobalProjectErrors(): readonly Diagnostic[] {
        return filter(this.projectErrors, diagnostic => !diagnostic.file) || emptyArray;
    }【

    《/**
     * Get all the project errors
     */》
    override】 getAllProjectErrors(): readonly Diagnostic[] {
        return this.projectErrors || emptyArray;


Line 3091:
【TS: JSDoc [127514, 127561)】
《Go: JSDocText [127514, 127559)》
    }

    【《/**
     * Get all the project errors
     》*/】
    override getAllProjectErrors(): readonly Diagnostic[] {


Line 3108:
【TS: OverrideKeyword [128164, 128202)】
《Go: JSDoc [128172, 128188)》
        this.compilerHost = undefined;
        super.close();
    }【

    《/** @internal */》
    override】 markAsDirty(): void {
        if (this.deferredClose) return;


Line 3114:
【TS: OverrideKeyword [128302, 128340)】
《Go: JSDoc [128310, 128326)》
        if (this.deferredClose) return;
        super.markAsDirty();
    }【

    《/** @internal */》
    override】 isOrphan(): boolean {
        return !!this.deferredClose;


Line 3123:
【TS: Identifier [128539, 128594)】
《Go: JSDoc [128547, 128563)》
    getEffectiveTypeRoots(): string[] {
        return getEffectiveTypeRoots(this.getCompilationSettings(), this) || [];
    }【

    《/** @internal */》
    updateErrorOnNoInputFiles】(parsedCommandLine: ParsedCommandLine): void {
        this.parsedCommandLine = parsedCommandLine;


Line 3136:
【TS: ExportKeyword [128999, 129175)】
《Go: JSDoc [129003, 129167)》
        );
    }
}【

《/**
 * Project whose configuration is handled externally, such as in a '.csproj'.
 * These are created only if a host explicitly calls `openExternalProject`.
 */》
export】 class ExternalProject extends Project {
    excludedFiles: readonly NormalizedPath[] = [];


Line 3138:
【TS: JSDoc [129003, 129167)】
《Go: JSDocText [129003, 129165)》
}

【《/**
 * Project whose configuration is handled externally, such as in a '.csproj'.
 * These are created only if a host explicitly calls `openExternalProject`.
 》*/】
export class ExternalProject extends Project {


Line 3143:
【TS: Constructor [129267, 130152)】
《Go: JSDoc [129273, 129289)》
 */
export class ExternalProject extends Project {
    excludedFiles: readonly NormalizedPath[] = [];【
    《/** @internal */》
    constructor(
        public externalProjectName: string,
        projectService: ProjectService,
        compilerOptions: CompilerOptions,
        lastFileExceededProgramSize: string | undefined,
        public override compileOnSaveEnabled: boolean,
        projectFilePath: string | undefined,
        watchOptions: WatchOptions | undefined,
    ) {
        super(
            externalProjectName,
            ProjectKind.External,
            projectService,
            /*hasExplicitListOfFiles*/ true,
            lastFileExceededProgramSize,
            compilerOptions,
            compileOnSaveEnabled,
            watchOptions,
            projectService.host,
            getDirectoryPath(projectFilePath || normalizeSlashes(externalProjectName)),
        );
        this.enableGlobalPlugins(this.getCompilerOptions());
    }】



Line 3178:
【TS: ExportKeyword [130436, 130464)】
《Go: JSDoc [130440, 130456)》
        return this.excludedFiles;
    }
}【

《/** @internal */》
export】 function isInferredProject(project: Project): project is InferredProject {
    return project.projectKind === ProjectKind.Inferred;


Line 3183:
【TS: ExportKeyword [130600, 130628)】
《Go: JSDoc [130604, 130620)》
export function isInferredProject(project: Project): project is InferredProject {
    return project.projectKind === ProjectKind.Inferred;
}【

《/** @internal */》
export】 function isConfiguredProject(project: Project): project is ConfiguredProject {
    return project.projectKind === ProjectKind.Configured;


Line 3188:
【TS: ExportKeyword [130770, 130798)】
《Go: JSDoc [130774, 130790)》
export function isConfiguredProject(project: Project): project is ConfiguredProject {
    return project.projectKind === ProjectKind.Configured;
}【

《/** @internal */》
export】 function isExternalProject(project: Project): project is ExternalProject {
    return project.projectKind === ProjectKind.External;


Line 3193:
【TS: ExportKeyword [130934, 130961)】
《Go: JSDoc [130938, 130953)》
export function isExternalProject(project: Project): project is ExternalProject {
    return project.projectKind === ProjectKind.External;
}【

《/**@internal */》
export】 function isBackgroundProject(project: Project): project is AutoImportProviderProject | AuxiliaryProject {
    return project.projectKind === ProjectKind.AutoImportProvider || project.projectKind === ProjectKind.Auxiliary;


Line 3198:
【TS: ExportKeyword [131187, 131215)】
《Go: JSDoc [131191, 131207)》
export function isBackgroundProject(project: Project): project is AutoImportProviderProject | AuxiliaryProject {
    return project.projectKind === ProjectKind.AutoImportProvider || project.projectKind === ProjectKind.Auxiliary;
}【

《/** @internal */》
export】 function isProjectDeferredClose(project: Project): project is ConfiguredProject {
    return isConfiguredProject(project) && !!project.deferredClose;
