--- old.jsdocTemplateTagDefault.types
+++ new.jsdocTemplateTagDefault.types
@@= skipped -3, +3 lines =@@
 /**
  * @template {string | number} [T=string] - ok: defaults are permitted
  * @typedef {[T]} A
+>A : any
+
  */
 
 /** @type {A} */ // ok, default for `T` in `A` is `string`
 const aDefault1 = [""];
->aDefault1 : A<string>
+>aDefault1 : [T]
 >[""] : [string]
 >"" : ""
 
 /** @type {A} */ // error: `number` is not assignable to string`
 const aDefault2 = [0];
->aDefault2 : A<string>
+>aDefault2 : [T]
 >[0] : [number]
 >0 : 0
 
 /** @type {A<string>} */ // ok, `T` is provided for `A`
 const aString = [""];
->aString : A<string>
+>aString : [T]
 >[""] : [string]
 >"" : ""
 
 /** @type {A<number>} */ // ok, `T` is provided for `A`
 const aNumber = [0];
->aNumber : A<number>
+>aNumber : [T]
 >[0] : [number]
 >0 : 0
 
@@= skipped -30, +32 lines =@@
  * @template T
  * @template [U=T] - ok: default can reference earlier type parameter
  * @typedef {[T, U]} B
+>B : B<T, U>
+
  */
 
 /**
  * @template {string | number} [T] - error: default requires an `=type`
  * @typedef {[T]} C
+>C : C<T>
+
  */
 
 /**
  * @template {string | number} [T=] - error: default requires a `type`
  * @typedef {[T]} D
+>D : D<T>
+
  */
 
 /**
  * @template {string | number} [T=string]
  * @template U - error: Required type parameters cannot follow optional type parameters
  * @typedef {[T, U]} E
+>E : E<T, U>
+
  */
 
 /**
  * @template [T=U] - error: Type parameter defaults can only reference previously declared type parameters.
  * @template [U=T]
  * @typedef {[T, U]} G
+>G : G<T, U>
+
  */
 
 /**
@@= skipped -31, +41 lines =@@
  * @param {U} b
  */
 function f1(a, b) {}
->f1 : <T, U = T>(a: T, b: U) => void
+>f1 : <T, U>(a: T, b: U) => void
 >a : T
 >b : U
 
@@= skipped -11, +11 lines =@@
  * @param {U} b
  */
 function f2(a, b) {}
->f2 : <T extends string | number = string, U>(a: T, b: U) => void
+>f2 : <T extends string | number, U>(a: T, b: U) => void
 >a : T
 >b : U
 
@@= skipped -11, +11 lines =@@
  * @param {U} b
  */
 function f3(a, b) {}
->f3 : <T = U, U = T>(a: T, b: U) => void
+>f3 : <T, U>(a: T, b: U) => void
 >a : T
 >b : U
 
