SourceFile
  ImportDeclaration
    ImportClause
      NamedImports
        ImportSpecifier
          Identifier: ' Lexer'
    StringLiteral
  ImportDeclaration
    ImportClause
      NamedImports
        ImportSpecifier
          Identifier: ' Grammar'
    StringLiteral
  ImportDeclaration
    ImportClause
      NamedImports
        ImportSpecifier
          Identifier: ' Precedence'
    StringLiteral
  ImportDeclaration
    ImportClause
      NamedImports
        ImportSpecifier
          Identifier: ' RootResult'
    StringLiteral
  ImportDeclaration
    ImportClause
      NamedImports
        ImportSpecifier
          Identifier: ' IntermediateResult'
    StringLiteral
  ImportDeclaration
    ImportClause
      NamedImports
        ImportSpecifier
          Identifier: ' TokenType'
    StringLiteral
  ClassDeclaration
    ExportKeyword
    DeclareKeyword
    Identifier: ' Parser'
    PropertyDeclaration
      PrivateKeyword
      ReadonlyKeyword
      Identifier: ' grammar'
    PropertyDeclaration
      PrivateKeyword
      Identifier: ' _lexer'
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' baseParser'
      QuestionToken
      TypeReference
        Identifier: ' Parser'
    Constructor
      Parameter
        Identifier: 'grammar'
        TypeReference
          Identifier: ' Grammar'
      Parameter
        Identifier: ' textOrLexer'
        UnionType
          StringKeyword
          TypeReference
            Identifier: ' Lexer'
      Parameter
        Identifier: ' baseParser'
        QuestionToken
        TypeReference
          Identifier: ' Parser'
    GetAccessor
      Identifier: ' lexer'
      TypeReference
        Identifier: ' Lexer'
    MethodDeclaration
      Identifier: '
    /**
     * Parses a given string and throws an error if the parse ended before the end of the string.
     */
    parse'
      TypeReference
        Identifier: ' RootResult'
    MethodDeclaration
      Identifier: '
    /**
     * Parses with the current lexer and asserts that the result is a {@link RootResult}.
     */
    parseType'
      Parameter
        Identifier: 'precedence'
        TypeReference
          Identifier: ' Precedence'
      TypeReference
        Identifier: ' RootResult'
    MethodDeclaration
      Identifier: '
    /**
     * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
     * to parse the state in the infix step.
     */
    parseIntermediateType'
      Parameter
        Identifier: 'precedence'
        TypeReference
          Identifier: ' Precedence'
      TypeReference
        Identifier: ' IntermediateResult'
    MethodDeclaration
      Identifier: '
    /**
     * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
     * a result.
     */
    parseInfixIntermediateType'
      Parameter
        Identifier: 'left'
        TypeReference
          Identifier: ' IntermediateResult'
      Parameter
        Identifier: ' precedence'
        TypeReference
          Identifier: ' Precedence'
      TypeReference
        Identifier: ' IntermediateResult'
    PropertyDeclaration
      PrivateKeyword
      Identifier: ' tryParslets'
    MethodDeclaration
      Identifier: '
    /**
     * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
     * advanced.
     */
    consume'
      Parameter
        Identifier: 'types'
        UnionType
          TypeReference
            Identifier: ' TokenType'
          ArrayType
            TypeReference
              Identifier: ' TokenType'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
    acceptLexerState'
      Parameter
        Identifier: 'parser'
        TypeReference
          Identifier: ' Parser'
      VoidKeyword
