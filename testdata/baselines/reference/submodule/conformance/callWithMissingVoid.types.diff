--- old.callWithMissingVoid.types
+++ new.callWithMissingVoid.types
@@= skipped -20, +20 lines =@@

 x.f() // no error because f expects void
 >x.f() : { a: void; }
->x.f : (t: void) => { a: void; }
+>x.f : (t: void) => { a: T; }
 >x : X<void>
->f : (t: void) => { a: void; }
+>f : (t: void) => { a: T; }

 declare const xUnion: X<void | number>;
 >xUnion : X<void | number>

 xUnion.f(42) // no error because f accepts number
 >xUnion.f(42) : { a: void | number; }
->xUnion.f : (t: void | number) => { a: void | number; }
+>xUnion.f : (t: void | number) => { a: T; }
 >xUnion : X<void | number>
->f : (t: void | number) => { a: void | number; }
+>f : (t: void | number) => { a: T; }
 >42 : 42

 xUnion.f() // no error because f accepts void
 >xUnion.f() : { a: void | number; }
->xUnion.f : (t: void | number) => { a: void | number; }
+>xUnion.f : (t: void | number) => { a: T; }
 >xUnion : X<void | number>
->f : (t: void | number) => { a: void | number; }
+>f : (t: void | number) => { a: T; }

 declare const xAny: X<any>;
 >xAny : X<any>

 xAny.f() // error, any still expects an argument
 >xAny.f() : { a: any; }
->xAny.f : (t: any) => { a: any; }
+>xAny.f : (t: any) => { a: T; }
 >xAny : X<any>
->f : (t: any) => { a: any; }
+>f : (t: any) => { a: T; }

 declare const xUnknown: X<unknown>;
 >xUnknown : X<unknown>

 xUnknown.f() // error, unknown still expects an argument
 >xUnknown.f() : { a: unknown; }
->xUnknown.f : (t: unknown) => { a: unknown; }
+>xUnknown.f : (t: unknown) => { a: T; }
 >xUnknown : X<unknown>
->f : (t: unknown) => { a: unknown; }
+>f : (t: unknown) => { a: T; }

 declare const xNever: X<never>;
 >xNever : X<never>

 xNever.f() // error, never still expects an argument
 >xNever.f() : { a: never; }
->xNever.f : (t: never) => { a: never; }
+>xNever.f : (t: never) => { a: T; }
 >xNever : X<never>
->f : (t: never) => { a: never; }
+>f : (t: never) => { a: T; }


 // Promise has previously been updated to work without arguments, but to show this fixes the issue too.