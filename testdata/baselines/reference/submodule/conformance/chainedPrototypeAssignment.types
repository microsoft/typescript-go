//// [tests/cases/conformance/salsa/chainedPrototypeAssignment.ts] ////

=== use.js ===
/// <reference path='./types.d.ts'/>
var mod = require('./mod');
>mod : typeof mod
>require('./mod') : typeof mod
>require : (name: string) => any
>'./mod' : "./mod"

var a = new mod.A()
>a : any
>new mod.A() : any
<<<<<<< HEAD
>mod.A : { (): void; prototype: { m: (n: number) => number; }; }
>mod : typeof import("mod")
>A : { (): void; prototype: { m: (n: number) => number; }; }
||||||| b0e1b84ac
>mod.A : () => void
>mod : typeof import("mod")
>A : () => void
=======
>mod.A : () => void
>mod : typeof mod
>A : () => void
>>>>>>> main

var b = new mod.B()
>b : any
>new mod.B() : any
<<<<<<< HEAD
>mod.B : { (): void; prototype: { m: (n: number) => number; }; }
>mod : typeof import("mod")
>B : { (): void; prototype: { m: (n: number) => number; }; }
||||||| b0e1b84ac
>mod.B : () => void
>mod : typeof import("mod")
>B : () => void
=======
>mod.B : () => void
>mod : typeof mod
>B : () => void
>>>>>>> main

a.m('nope')
>a.m('nope') : any
>a.m : any
>a : any
>m : any
>'nope' : "nope"

b.m('not really')
>b.m('not really') : any
>b.m : any
>b : any
>m : any
>'not really' : "not really"

=== types.d.ts ===
declare function require(name: string): any;
>require : (name: string) => any
>name : string

declare var exports: any;
>exports : any

=== mod.js ===
/// <reference path='./types.d.ts'/>
var A = function A() {
>A : { (): void; prototype: { m: (n: number) => number; }; }
>function A() {    this.a = 1} : { (): void; prototype: { m: (n: number) => number; }; }
>A : { (): void; prototype: { m: (n: number) => number; }; }

    this.a = 1
>this.a = 1 : 1
>this.a : any
>this : any
>a : any
>1 : 1
}
var B = function B() {
>B : { (): void; prototype: { m: (n: number) => number; }; }
>function B() {    this.b = 2} : { (): void; prototype: { m: (n: number) => number; }; }
>B : { (): void; prototype: { m: (n: number) => number; }; }

    this.b = 2
>this.b = 2 : 2
>this.b : any
>this : any
>b : any
>2 : 2
}
exports.A = A
<<<<<<< HEAD
>exports.A = A : { (): void; prototype: { m: (n: number) => number; }; }
>exports.A : { (): void; prototype: { m: (n: number) => number; }; }
>exports : typeof import("mod")
>A : { (): void; prototype: { m: (n: number) => number; }; }
>A : { (): void; prototype: { m: (n: number) => number; }; }
||||||| b0e1b84ac
>exports.A = A : () => void
>exports.A : () => void
>exports : typeof import("mod")
>A : () => void
>A : () => void
=======
>exports.A = A : () => void
>exports.A : () => void
>exports : typeof import("./mod")
>A : () => void
>A : () => void
>>>>>>> main

exports.B = B
<<<<<<< HEAD
>exports.B = B : { (): void; prototype: { m: (n: number) => number; }; }
>exports.B : { (): void; prototype: { m: (n: number) => number; }; }
>exports : typeof import("mod")
>B : { (): void; prototype: { m: (n: number) => number; }; }
>B : { (): void; prototype: { m: (n: number) => number; }; }
||||||| b0e1b84ac
>exports.B = B : () => void
>exports.B : () => void
>exports : typeof import("mod")
>B : () => void
>B : () => void
=======
>exports.B = B : () => void
>exports.B : () => void
>exports : typeof import("./mod")
>B : () => void
>B : () => void
>>>>>>> main

A.prototype = B.prototype = {
<<<<<<< HEAD
>A.prototype = B.prototype = {    /** @param {number} n */    m(n) {        return n + 1    }} : { m: (n: number) => number; }
>A.prototype : { m: (n: number) => number; }
>A : { (): void; prototype: { m: (n: number) => number; }; }
>prototype : { m: (n: number) => number; }
>B.prototype = {    /** @param {number} n */    m(n) {        return n + 1    }} : { m: (n: number) => number; }
>B.prototype : { m: (n: number) => number; }
>B : { (): void; prototype: { m: (n: number) => number; }; }
>prototype : { m: (n: number) => number; }
>{    /** @param {number} n */    m(n) {        return n + 1    }} : { m: (n: number) => number; }
||||||| b0e1b84ac
>A.prototype = B.prototype = {    /** @param {number} n */    m(n) {        return n + 1    }} : { m: (n: number) => number; }
>A.prototype : any
>A : () => void
>prototype : any
>B.prototype = {    /** @param {number} n */    m(n) {        return n + 1    }} : { m: (n: number) => number; }
>B.prototype : any
>B : () => void
>prototype : any
>{    /** @param {number} n */    m(n) {        return n + 1    }} : { m: (n: number) => number; }
=======
>A.prototype = B.prototype = {    /** @param {number} n */    m(n) {        return n + 1    }} : { m(n: number): number; }
>A.prototype : any
>A : () => void
>prototype : any
>B.prototype = {    /** @param {number} n */    m(n) {        return n + 1    }} : { m(n: number): number; }
>B.prototype : any
>B : () => void
>prototype : any
>{    /** @param {number} n */    m(n) {        return n + 1    }} : { m(n: number): number; }
>>>>>>> main

    /** @param {number} n */
    m(n) {
>m : (n: number) => number
>n : number

        return n + 1
>n + 1 : number
>n : number
>1 : 1
    }
}

