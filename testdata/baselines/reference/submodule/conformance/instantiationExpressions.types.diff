--- old.instantiationExpressions.types
+++ new.instantiationExpressions.types
@@= skipped -1, +1 lines =@@

 === instantiationExpressions.ts ===
 declare function fx<T>(x: T): T;
->fx : { <T>(x: T): T; <T_1>(x: T_1, n: number): T_1; <T_1, U>(t: [T_1, U]): [T_1, U]; }
+>fx : { <T>(x: T): T; <T>(x: T, n: number): T; <T, U>(t: [T, U]): [T, U]; }
 >x : T

 declare function fx<T>(x: T, n: number): T;
->fx : { <T_1>(x: T_1): T_1; <T>(x: T, n: number): T; <T_1, U>(t: [T_1, U]): [T_1, U]; }
+>fx : { <T>(x: T): T; <T>(x: T, n: number): T; <T, U>(t: [T, U]): [T, U]; }
 >x : T
 >n : number

 declare function fx<T, U>(t: [T, U]): [T, U];
->fx : { <T_1>(x: T_1): T_1; <T_1>(x: T_1, n: number): T_1; <T, U>(t: [T, U]): [T, U]; }
+>fx : { <T>(x: T): T; <T>(x: T, n: number): T; <T, U>(t: [T, U]): [T, U]; }
 >t : [T, U]

 function f1() {
 >f1 : () => void

     let f0 = fx<>;  // Error
->f0 : { <T>(x: T): T; <T>(x: T, n: number): T; <T, U>(t: [T, U]): [T, U]; }
->fx<> : { <T>(x: T): T; <T>(x: T, n: number): T; <T, U>(t: [T, U]): [T, U]; }
+>f0 : { (x: unknown): unknown; (x: unknown, n: number): unknown; (t: [unknown, unknown]): [unknown, unknown]; }
+>fx<> : { (x: unknown): unknown; (x: unknown, n: number): unknown; (t: [unknown, unknown]): [unknown, unknown]; }
 >fx : { <T>(x: T): T; <T>(x: T, n: number): T; <T, U>(t: [T, U]): [T, U]; }

     let f1 = fx<string>;  // { (x: string): string; (x: string, n: number): string; }
@@= skipped -37, +37 lines =@@
 }

 type T10 = typeof fx<>;  // Error
->T10 : { <T>(x: T): T; <T>(x: T, n: number): T; <T, U>(t: [T, U]): [T, U]; }
+>T10 : typeof fx
 >fx : { <T>(x: T): T; <T>(x: T, n: number): T; <T, U>(t: [T, U]): [T, U]; }

 type T11 = typeof fx<string>;  // { (x: string): string; (x: string, n: number): string; }
@@= skipped -19, +19 lines =@@
 >f2 : () => void

     const A0 = Array<>;  // Error
->A0 : ArrayConstructor
->Array<> : ArrayConstructor
+>A0 : { (arrayLength: number): unknown[]; (...items: unknown[]): unknown[]; new (arrayLength: number): unknown[]; new (...items: unknown[]): unknown[]; isArray(arg: any): arg is any[]; readonly prototype: any[]; from<T>(arrayLike: ArrayLike<T>): T[]; from<T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[]; from<T>(iterable: Iterable<T> | ArrayLike<T>): T[]; from<T, U>(iterable: Iterable<T> | ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[]; of<T>(...items: T[]): T[]; readonly [Symbol.species]: ArrayConstructor; }
+>Array<> : { (arrayLength: number): unknown[]; (...items: unknown[]): unknown[]; new (arrayLength: number): unknown[]; new (...items: unknown[]): unknown[]; isArray(arg: any): arg is any[]; readonly prototype: any[]; from<T>(arrayLike: ArrayLike<T>): T[]; from<T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[]; from<T>(iterable: Iterable<T> | ArrayLike<T>): T[]; from<T, U>(iterable: Iterable<T> | ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[]; of<T>(...items: T[]): T[]; readonly [Symbol.species]: ArrayConstructor; }
 >Array : ArrayConstructor

     const A1 = Array<string>;  // new (...) => string[]
@@= skipped -16, +16 lines =@@
 }

 type T20 = typeof Array<>;  // Error
->T20 : ArrayConstructor
+>T20 : typeof Array
 >Array : ArrayConstructor

 type T21 = typeof Array<string>;  // new (...) => string[]