--- old.variadicTuples1.types
+++ new.variadicTuples1.types
@@= skipped -132, +132 lines =@@
 }
 
 const tc5 = concat2([1, 2, 3] as const, [4, 5, 6] as const);  // (1 | 2 | 3 | 4 | 5 | 6)[]
->tc5 : (2 | 4 | 1 | 3 | 6 | 5)[]
->concat2([1, 2, 3] as const, [4, 5, 6] as const) : (2 | 4 | 1 | 3 | 6 | 5)[]
+>tc5 : (1 | 2 | 3 | 4 | 5 | 6)[]
+>concat2([1, 2, 3] as const, [4, 5, 6] as const) : (1 | 2 | 3 | 4 | 5 | 6)[]
 >concat2 : <T extends readonly unknown[], U extends readonly unknown[]>(t: T, u: U) => (T[number] | U[number])[]
 >[1, 2, 3] as const : readonly [1, 2, 3]
 >[1, 2, 3] : readonly [1, 2, 3]
@@= skipped -85, +85 lines =@@
 }
 
 declare function foo3<T extends unknown[]>(x: number, ...args: [...T, number]): T;
->foo3 : <T extends unknown[]>(x: number, ...args: [...T, number]) => T
+>foo3 : <T extends unknown[]>(x: number, ...args: T, args_1?: number) => T
 >x : number
 >args : [...T, number]
 
@@= skipped -10, +10 lines =@@
 
     foo3(1, 2);
 >foo3(1, 2) : []
->foo3 : <T extends unknown[]>(x: number, ...args: [...T, number]) => T
+>foo3 : <T extends unknown[]>(x: number, ...args: T, args_1?: number) => T
 >1 : 1
 >2 : 2
 
     foo3(1, 'hello', true, 2);
 >foo3(1, 'hello', true, 2) : [string, boolean]
->foo3 : <T extends unknown[]>(x: number, ...args: [...T, number]) => T
+>foo3 : <T extends unknown[]>(x: number, ...args: T, args_1?: number) => T
 >1 : 1
 >'hello' : "hello"
 >true : true
@@= skipped -14, +14 lines =@@
 
     foo3(1, ...u, 'hi', 2);
 >foo3(1, ...u, 'hi', 2) : [...U, string]
->foo3 : <T extends unknown[]>(x: number, ...args: [...T, number]) => T
+>foo3 : <T extends unknown[]>(x: number, ...args: T, args_1?: number) => T
 >1 : 1
 >...u : unknown
 >u : U
@@= skipped -9, +9 lines =@@
 
     foo3(1);
 >foo3(1) : unknown[]
->foo3 : <T extends unknown[]>(x: number, ...args: [...T, number]) => T
+>foo3 : <T extends unknown[]>(x: number, ...args: T, args_1?: number) => T
 >1 : 1
 }
 
@@= skipped -171, +171 lines =@@
 // Reverse mapping through mapped type applied to variadic tuple type
 
 declare function fm1<T extends unknown[]>(t: Arrayify<[string, number, ...T]>): T;
->fm1 : <T extends unknown[]>(t: Arrayify<[string, number, ...T]>) => T
+>fm1 : <T extends unknown[]>(t: [string[], number[], ...Arrayify<T>]) => T
 >t : [string[], number[], ...Arrayify<T>]
 
 let tm1 = fm1([['abc'], [42], [true], ['def']]);  // [boolean, string]
 >tm1 : [boolean, string]
 >fm1([['abc'], [42], [true], ['def']]) : [boolean, string]
->fm1 : <T extends unknown[]>(t: Arrayify<[string, number, ...T]>) => T
+>fm1 : <T extends unknown[]>(t: [string[], number[], ...Arrayify<T>]) => T
 >[['abc'], [42], [true], ['def']] : [string[], number[], true[], string[]]
 >['abc'] : string[]
 >'abc' : "abc"
@@= skipped -613, +613 lines =@@
 // Inference to [...T, ...U] with implied arity for T
 
 function curry<T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) {
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
->f : (...args: [...T, ...U]) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
+>f : (...args_1: T, ...args_2: U) => R
 >args : [...T, ...U]
 >a : T
 
@@= skipped -9, +9 lines =@@
 >(...b: U) => f(...a, ...b) : (...b: U) => R
 >b : U
 >f(...a, ...b) : R
->f : (...args: [...T, ...U]) => R
+>f : (...args_1: T, ...args_2: U) => R
 >...a : unknown
 >a : T
 >...b : unknown
@@= skipped -19, +19 lines =@@
 const c0 = curry(fn1);  // (a: number, b: string, c: boolean, d: string[]) => number
 >c0 : (a: number, b: string, c: boolean, d: string[]) => number
 >curry(fn1) : (a: number, b: string, c: boolean, d: string[]) => number
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
 >fn1 : (a: number, b: string, c: boolean, d: string[]) => number
 
 const c1 = curry(fn1, 1);  // (b: string, c: boolean, d: string[]) => number
 >c1 : (b: string, c: boolean, d: string[]) => number
 >curry(fn1, 1) : (b: string, c: boolean, d: string[]) => number
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
 >fn1 : (a: number, b: string, c: boolean, d: string[]) => number
 >1 : 1
 
 const c2 = curry(fn1, 1, 'abc');  // (c: boolean, d: string[]) => number
 >c2 : (c: boolean, d: string[]) => number
 >curry(fn1, 1, 'abc') : (c: boolean, d: string[]) => number
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
 >fn1 : (a: number, b: string, c: boolean, d: string[]) => number
 >1 : 1
 >'abc' : "abc"
@@= skipped -21, +21 lines =@@
 const c3 = curry(fn1, 1, 'abc', true);  // (d: string[]) => number
 >c3 : (d: string[]) => number
 >curry(fn1, 1, 'abc', true) : (d: string[]) => number
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
 >fn1 : (a: number, b: string, c: boolean, d: string[]) => number
 >1 : 1
 >'abc' : "abc"
@@= skipped -9, +9 lines =@@
 const c4 = curry(fn1, 1, 'abc', true, ['x', 'y']);  // () => number
 >c4 : () => number
 >curry(fn1, 1, 'abc', true, ['x', 'y']) : () => number
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
 >fn1 : (a: number, b: string, c: boolean, d: string[]) => number
 >1 : 1
 >'abc' : "abc"
@@= skipped -20, +20 lines =@@
 const c10 = curry(fn2);  // (x: number, b: boolean, ...args: string[]) => number
 >c10 : (x: number, b: boolean, ...args: string[]) => number
 >curry(fn2) : (x: number, b: boolean, ...args: string[]) => number
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
 >fn2 : (x: number, b: boolean, ...args: string[]) => number
 
 const c11 = curry(fn2, 1);  // (b: boolean, ...args: string[]) => number
 >c11 : (b: boolean, ...args: string[]) => number
 >curry(fn2, 1) : (b: boolean, ...args: string[]) => number
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
 >fn2 : (x: number, b: boolean, ...args: string[]) => number
 >1 : 1
 
 const c12 = curry(fn2, 1, true);  // (...args: string[]) => number
 >c12 : (...b: string[]) => number
 >curry(fn2, 1, true) : (...b: string[]) => number
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
 >fn2 : (x: number, b: boolean, ...args: string[]) => number
 >1 : 1
 >true : true
@@= skipped -21, +21 lines =@@
 const c13 = curry(fn2, 1, true, 'abc', 'def');  // (...args: string[]) => number
 >c13 : (...b: string[]) => number
 >curry(fn2, 1, true, 'abc', 'def') : (...b: string[]) => number
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
 >fn2 : (x: number, b: boolean, ...args: string[]) => number
 >1 : 1
 >true : true
@@= skipped -16, +16 lines =@@
 const c20 = curry(fn3);  // (...args: string[]) => number
 >c20 : (...b: string[]) => number
 >curry(fn3) : (...b: string[]) => number
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
 >fn3 : (...args: string[]) => number
 
 const c21 = curry(fn3, 'abc', 'def');  // (...args: string[]) => number
 >c21 : (...b: string[]) => number
 >curry(fn3, 'abc', 'def') : (...b: string[]) => number
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
 >fn3 : (...args: string[]) => number
 >'abc' : "abc"
 >'def' : "def"
@@= skipped -14, +14 lines =@@
 const c22 = curry(fn3, ...sa);  // (...args: string[]) => number
 >c22 : (...b: string[]) => number
 >curry(fn3, ...sa) : (...b: string[]) => number
->curry : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, ...a: T) => (...b: U) => R
+>curry : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, ...a: T) => (...b: U) => R
 >fn3 : (...args: string[]) => number
 >...sa : string
 >sa : string[]
@@= skipped -8, +8 lines =@@
 // No inference to [...T, ...U] when there is no implied arity
 
 function curry2<T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, t: [...T], u: [...U]) {
->curry2 : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, t: [...T], u: [...U]) => R
->f : (...args: [...T, ...U]) => R
+>curry2 : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, t: [...T], u: [...U]) => R
+>f : (...args_1: T, ...args_2: U) => R
 >args : [...T, ...U]
 >t : [...T]
 >u : [...U]
 
     return f(...t, ...u);
 >f(...t, ...u) : R
->f : (...args: [...T, ...U]) => R
+>f : (...args_1: T, ...args_2: U) => R
 >...t : T[number]
 >t : [...T]
 >...u : U[number]
@@= skipped -23, +23 lines =@@
 
 curry2(fn10, ['hello', 42], [true]);
 >curry2(fn10, ['hello', 42], [true]) : string[]
->curry2 : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, t: [...T], u: [...U]) => R
+>curry2 : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, t: [...T], u: [...U]) => R
 >fn10 : (a: string, b: number, c: boolean) => string[]
 >['hello', 42] : [string, number]
 >'hello' : "hello"
@@= skipped -10, +10 lines =@@
 
 curry2(fn10, ['hello'], [42, true]);
 >curry2(fn10, ['hello'], [42, true]) : string[]
->curry2 : <T extends unknown[], U extends unknown[], R>(f: (...args: [...T, ...U]) => R, t: [...T], u: [...U]) => R
+>curry2 : <T extends unknown[], U extends unknown[], R>(f: (...args_1: T, ...args_2: U) => R, t: [...T], u: [...U]) => R
 >fn10 : (a: string, b: number, c: boolean) => string[]
 >['hello'] : [string]
 >'hello' : "hello"
@@= skipped -11, +11 lines =@@
 // Inference to [...T] has higher priority than inference to [...T, number?]
 
 declare function ft<T extends unknown[]>(t1: [...T], t2: [...T, number?]): T;
->ft : <T extends unknown[]>(t1: [...T], t2: [...T, number?]) => T
+>ft : <T extends unknown[]>(t1: [...T], t2: [...T, (number | undefined)?]) => T
 >t1 : [...T]
 >t2 : [...T, (number | undefined)?]
 
 ft([1, 2, 3], [1, 2, 3]);
 >ft([1, 2, 3], [1, 2, 3]) : [number, number, number]
->ft : <T extends unknown[]>(t1: [...T], t2: [...T, number?]) => T
+>ft : <T extends unknown[]>(t1: [...T], t2: [...T, (number | undefined)?]) => T
 >[1, 2, 3] : [number, number, number]
 >1 : 1
 >2 : 2
@@= skipped -18, +18 lines =@@
 
 ft([1, 2], [1, 2, 3]);
 >ft([1, 2], [1, 2, 3]) : [number, number]
->ft : <T extends unknown[]>(t1: [...T], t2: [...T, number?]) => T
+>ft : <T extends unknown[]>(t1: [...T], t2: [...T, (number | undefined)?]) => T
 >[1, 2] : [number, number]
 >1 : 1
 >2 : 2
@@= skipped -11, +11 lines =@@
 
 ft(['a', 'b'], ['c', 'd'])
 >ft(['a', 'b'], ['c', 'd']) : [string, string]
->ft : <T extends unknown[]>(t1: [...T], t2: [...T, number?]) => T
+>ft : <T extends unknown[]>(t1: [...T], t2: [...T, (number | undefined)?]) => T
 >['a', 'b'] : [string, string]
 >'a' : "a"
 >'b' : "b"
@@= skipped -10, +10 lines =@@
 
 ft(['a', 'b'], ['c', 'd', 42])
 >ft(['a', 'b'], ['c', 'd', 42]) : [string, string]
->ft : <T extends unknown[]>(t1: [...T], t2: [...T, number?]) => T
+>ft : <T extends unknown[]>(t1: [...T], t2: [...T, (number | undefined)?]) => T
 >['a', 'b'] : [string, string]
 >'a' : "a"
 >'b' : "b"
@@= skipped -12, +12 lines =@@
 // Last argument is contextually typed
 
 declare function call<T extends unknown[], R>(...args: [...T, (...args: T) => R]): [T, R];
->call : <T extends unknown[], R>(...args: [...T, (...args: T) => R]) => [T, R]
+>call : <T extends unknown[], R>(...args: T, args_1?: (...args: T) => R) => [T, R]
 >args : [...T, (...args: T) => R]
 >args : T
 
 call('hello', 32, (a, b) => 42);
 >call('hello', 32, (a, b) => 42) : [[string, number], number]
->call : <T extends unknown[], R>(...args: [...T, (...args: T) => R]) => [T, R]
+>call : <T extends unknown[], R>(...args: T, args_1?: (...args: T) => R) => [T, R]
 >'hello' : "hello"
 >32 : 32
 >(a, b) => 42 : (a: string, b: number) => number
@@= skipped -16, +16 lines =@@
 
 call(...sa, (...x) => 42);
 >call(...sa, (...x) => 42) : [string[], number]
->call : <T extends unknown[], R>(...args: [...T, (...args: T) => R]) => [T, R]
+>call : <T extends unknown[], R>(...args: T, args_1?: (...args: T) => R) => [T, R]
 >...sa : string
 >sa : string[]
 >(...x) => 42 : (...x: string[]) => number
@@= skipped -10, +10 lines =@@
 // No inference to ending optional elements (except with identical structure)
 
 declare function f20<T extends unknown[] = []>(args: [...T, number?]): T;
->f20 : <T extends unknown[] = []>(args: [...T, number?]) => T
+>f20 : <T extends unknown[]>(args: [...T, (number | undefined)?]) => T
 >args : [...T, (number | undefined)?]
 
 function f21<U extends string[]>(args: [...U, number?]) {
->f21 : <U extends string[]>(args: [...U, number?]) => void
+>f21 : <U extends string[]>(args: [...U, (number | undefined)?]) => void
 >args : [...U, (number | undefined)?]
 
     let v1 = f20(args);  // U
 >v1 : U
 >f20(args) : U
->f20 : <T extends unknown[] = []>(args: [...T, number?]) => T
+>f20 : <T extends unknown[]>(args: [...T, (number | undefined)?]) => T
 >args : [...U, (number | undefined)?]
 
     let v2 = f20(["foo", "bar"]);  // [string]
 >v2 : [string]
 >f20(["foo", "bar"]) : [string]
->f20 : <T extends unknown[] = []>(args: [...T, number?]) => T
+>f20 : <T extends unknown[]>(args: [...T, (number | undefined)?]) => T
 >["foo", "bar"] : [string, string]
 >"foo" : "foo"
 >"bar" : "bar"
@@= skipped -24, +24 lines =@@
     let v3 = f20(["foo", 42]);  // [string]
 >v3 : [string]
 >f20(["foo", 42]) : [string]
->f20 : <T extends unknown[] = []>(args: [...T, number?]) => T
+>f20 : <T extends unknown[]>(args: [...T, (number | undefined)?]) => T
 >["foo", 42] : [string, number]
 >"foo" : "foo"
 >42 : 42
 }
 
 declare function f22<T extends unknown[] = []>(args: [...T, number]): T;
->f22 : { <T extends unknown[] = []>(args: [...T, number]): T; <T_1 extends unknown[] = []>(args: [...T_1]): T_1; }
+>f22 : { <T extends unknown[]>(args: [...T, number]): T; <T extends unknown[]>(args: [...T]): T; }
 >args : [...T, number]
 
 declare function f22<T extends unknown[] = []>(args: [...T]): T;
->f22 : { <T_1 extends unknown[] = []>(args: [...T_1, number]): T_1; <T extends unknown[] = []>(args: [...T]): T; }
+>f22 : { <T extends unknown[]>(args: [...T, number]): T; <T extends unknown[]>(args: [...T]): T; }
 >args : [...T]
 
 function f23<U extends string[]>(args: [...U, number]) {
@@= skipped -21, +21 lines =@@
     let v1 = f22(args);  // U
 >v1 : U
 >f22(args) : U
->f22 : { <T extends unknown[] = []>(args: [...T, number]): T; <T extends unknown[] = []>(args: [...T]): T; }
+>f22 : { <T extends unknown[]>(args: [...T, number]): T; <T extends unknown[]>(args: [...T]): T; }
 >args : [...U, number]
 
     let v2 = f22(["foo", "bar"]);  // [string, string]
 >v2 : [string, string]
 >f22(["foo", "bar"]) : [string, string]
->f22 : { <T extends unknown[] = []>(args: [...T, number]): T; <T extends unknown[] = []>(args: [...T]): T; }
+>f22 : { <T extends unknown[]>(args: [...T, number]): T; <T extends unknown[]>(args: [...T]): T; }
 >["foo", "bar"] : [string, string]
 >"foo" : "foo"
 >"bar" : "bar"
@@= skipped -14, +14 lines =@@
     let v3 = f22(["foo", 42]);  // [string]
 >v3 : [string]
 >f22(["foo", 42]) : [string]
->f22 : { <T extends unknown[] = []>(args: [...T, number]): T; <T extends unknown[] = []>(args: [...T]): T; }
+>f22 : { <T extends unknown[]>(args: [...T, number]): T; <T extends unknown[]>(args: [...T]): T; }
 >["foo", 42] : [string, number]
 >"foo" : "foo"
 >42 : 42
@@= skipped -34, +34 lines =@@
 // Repro from #39607
 
 declare function getUser(id: string, options?: { x?: string }): string;
->getUser : (id: string, options?: { x?: string; }) => string
+>getUser : (id: string, options?: { x?: string | undefined; } | undefined) => string
 >id : string
->options : { x?: string; } | undefined
+>options : { x?: string | undefined; } | undefined
 >x : string | undefined
 
 declare function getOrgUser(id: string, orgId: number, options?: { y?: number, z?: boolean }): void;
->getOrgUser : (id: string, orgId: number, options?: { y?: number; z?: boolean; }) => void
+>getOrgUser : (id: string, orgId: number, options?: { y?: number | undefined; z?: boolean | undefined; } | undefined) => void
 >id : string
 >orgId : number
->options : { y?: number; z?: boolean; } | undefined
+>options : { y?: number | undefined; z?: boolean | undefined; } | undefined
 >y : number | undefined
 >z : boolean | undefined
 
 function callApi<T extends unknown[] = [], U = void>(method: (...args: [...T, object]) => U) {
->callApi : <T extends unknown[] = [], U = void>(method: (...args: [...T, object]) => U) => (...args: T) => U
->method : (...args: [...T, object]) => U
+>callApi : <T extends unknown[], U>(method: (...args: T, args_1?: object) => U) => (...args: T) => U
+>method : (...args: T, args_1?: object) => U
 >args : [...T, object]
 
     return (...args: [...T]) => method(...args, {});
 >(...args: [...T]) => method(...args, {}) : (...args: T) => U
 >args : [...T]
 >method(...args, {}) : U
->method : (...args: [...T, object]) => U
+>method : (...args: T, args_1?: object) => U
 >...args : T[number]
 >args : [...T]
 >{} : {}
@@= skipped -30, +30 lines =@@
 
 callApi(getUser);
 >callApi(getUser) : (id: string) => string
->callApi : <T extends unknown[] = [], U = void>(method: (...args: [...T, object]) => U) => (...args: T) => U
->getUser : (id: string, options?: { x?: string; }) => string
+>callApi : <T extends unknown[], U>(method: (...args: T, args_1?: object) => U) => (...args: T) => U
+>getUser : (id: string, options?: { x?: string | undefined; } | undefined) => string
 
 callApi(getOrgUser);
 >callApi(getOrgUser) : (id: string, orgId: number) => void
->callApi : <T extends unknown[] = [], U = void>(method: (...args: [...T, object]) => U) => (...args: T) => U
->getOrgUser : (id: string, orgId: number, options?: { y?: number; z?: boolean; }) => void
+>callApi : <T extends unknown[], U>(method: (...args: T, args_1?: object) => U) => (...args: T) => U
+>getOrgUser : (id: string, orgId: number, options?: { y?: number | undefined; z?: boolean | undefined; } | undefined) => void
 
 // Repro from #40235
 
