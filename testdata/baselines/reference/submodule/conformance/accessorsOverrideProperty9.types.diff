--- old.accessorsOverrideProperty9.types
+++ new.accessorsOverrideProperty9.types
@@= skipped -5, +5 lines =@@
 // Mixin utilities
 export type Constructor<T = {}> = new (...args: any[]) => T;
 >Constructor : Constructor<T>
->            : ^^^^^^^^^^^^^^
+>T : T
 >args : any[]
->     : ^^^^^
 
 export type PropertiesOf<T> = { [K in keyof T]: T[K] };
 >PropertiesOf : PropertiesOf<T>
->             : ^^^^^^^^^^^^^^^
+>T : T
+>K : K
 
 interface IApiItemConstructor extends Constructor<ApiItem>, PropertiesOf<typeof ApiItem> {}
->ApiItem : typeof ApiItem
->        : ^^^^^^^^^^^^^^
+>IApiItemConstructor : IApiItemConstructor
 
 // Base class
 class ApiItem {
 >ApiItem : ApiItem
->        : ^^^^^^^
 
   public get members(): ReadonlyArray<ApiItem> {
 >members : readonly ApiItem[]
->        : ^^^^^^^^^^^^^^^^^^
 
     return [];
 >[] : never[]
->   : ^^^^^^^
   }
 }
 
 // Normal subclass
 class ApiEnumMember extends ApiItem {
 >ApiEnumMember : ApiEnumMember
->              : ^^^^^^^^^^^^^
 >ApiItem : ApiItem
->        : ^^^^^^^
 }
 
 // Mixin base class
 interface ApiItemContainerMixin extends ApiItem {
+>ApiItemContainerMixin : ApiItemContainerMixin
+
   readonly members: ReadonlyArray<ApiItem>;
 >members : readonly ApiItem[]
->        : ^^^^^^^^^^^^^^^^^^
 }
 
 function ApiItemContainerMixin<TBaseClass extends IApiItemConstructor>(
->ApiItemContainerMixin : <TBaseClass extends IApiItemConstructor>(baseClass: TBaseClass) => TBaseClass & (new (...args: any[]) => ApiItemContainerMixin)
->                      : ^          ^^^^^^^^^                   ^^         ^^          ^^^^^                                                            
+>ApiItemContainerMixin : <TBaseClass extends IApiItemConstructor>(baseClass: TBaseClass) => TBaseClass & new (...args: any[]) => ApiItemContainerMixin
+>TBaseClass : TBaseClass
 
   baseClass: TBaseClass
 >baseClass : TBaseClass
->          : ^^^^^^^^^^
 
 ): TBaseClass & (new (...args: any[]) => ApiItemContainerMixin) {
 >args : any[]
->     : ^^^^^
 
   abstract class MixedClass extends baseClass implements ApiItemContainerMixin {
->MixedClass : MixedClass
->           : ^^^^^^^^^^
+>MixedClass : MixedClass<TBaseClass>
 >baseClass : ApiItem
->          : ^^^^^^^
 
     public constructor(...args: any[]) {
 >args : any[]
->     : ^^^^^
 
       super(...args);
 >super(...args) : void
->               : ^^^^
 >super : TBaseClass
->      : ^^^^^^^^^^
 >...args : any
 >args : any[]
->     : ^^^^^
     }
 
     public get members(): ReadonlyArray<ApiItem> {
 >members : readonly ApiItem[]
->        : ^^^^^^^^^^^^^^^^^^
 
       return [];
 >[] : never[]
->   : ^^^^^^^
     }
   }
 
   return MixedClass;
->MixedClass : ((abstract new (...args: any[]) => MixedClass) & { prototype: ApiItemContainerMixin<any>.MixedClass; }) & TBaseClass
->           : ^^^^^^^^^^^^^^^^^^^    ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+>MixedClass : { new (...args: any[]): MixedClass<TBaseClass>; prototype: MixedClass<any>; } & TBaseClass
 }
 
 // Subclass inheriting from mixin
 export class ApiEnum extends ApiItemContainerMixin(ApiItem) {
 >ApiEnum : ApiEnum
->        : ^^^^^^^
 >ApiItemContainerMixin(ApiItem) : ApiItem & ApiItemContainerMixin
->                               : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
->ApiItemContainerMixin : <TBaseClass extends IApiItemConstructor>(baseClass: TBaseClass) => TBaseClass & (new (...args: any[]) => ApiItemContainerMixin)
->                      : ^          ^^^^^^^^^                   ^^         ^^          ^^^^^                                                            
+>ApiItemContainerMixin : <TBaseClass extends IApiItemConstructor>(baseClass: TBaseClass) => TBaseClass & new (...args: any[]) => ApiItemContainerMixin
 >ApiItem : typeof ApiItem
->        : ^^^^^^^^^^^^^^
 
   // This worked prior to TypeScript 4.0:
   public get members(): ReadonlyArray<ApiEnumMember> {
 >members : readonly ApiEnumMember[]
->        : ^^^^^^^^^^^^^^^^^^^^^^^^
 
     return [];
 >[] : never[]
->   : ^^^^^^^
   }
 }
 
