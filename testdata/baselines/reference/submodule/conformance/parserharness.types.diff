--- old.parserharness.types
+++ new.parserharness.types
@@= skipped -115, +115 lines =@@

 if (typeof ActiveXObject === "function") {
 >typeof ActiveXObject === "function" : boolean
->typeof ActiveXObject : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
+>typeof ActiveXObject : "bigint" | "boolean" | "function" | "number" | "object" | "string" | "symbol" | "undefined"
 >ActiveXObject : any
 >"function" : "function"

@@= skipped -11, +11 lines =@@

 } else if (typeof require === "function") {
 >typeof require === "function" : boolean
->typeof require : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
+>typeof require : "bigint" | "boolean" | "function" | "number" | "object" | "string" | "symbol" | "undefined"
 >require : any
 >"function" : "function"

@@= skipped -153, +153 lines =@@
             var bugs = content.match(/\bbug (\d+)/i);
 >bugs : RegExpMatchArray
 >content.match(/\bbug (\d+)/i) : RegExpMatchArray
->content.match : (regexp: string | RegExp) => RegExpMatchArray | null
+>content.match : (regexp: string | RegExp) => RegExpMatchArray
 >content : string
->match : (regexp: string | RegExp) => RegExpMatchArray | null
+>match : (regexp: string | RegExp) => RegExpMatchArray
 >/\bbug (\d+)/i : RegExp

             if (bugs) {
@@= skipped -717, +717 lines =@@

             if (typeof loggers[i][field] === 'function') {
 >typeof loggers[i][field] === 'function' : boolean
->typeof loggers[i][field] : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
+>typeof loggers[i][field] : "bigint" | "boolean" | "function" | "number" | "object" | "string" | "symbol" | "undefined"
 >loggers[i][field] : any
 >loggers[i] : ILogger
 >loggers : ILogger[]
@@= skipped -848, +848 lines =@@
             if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
 >typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined" : boolean
 >typeof WScript !== "undefined" : boolean
->typeof WScript : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
+>typeof WScript : "bigint" | "boolean" | "function" | "number" | "object" | "string" | "symbol" | "undefined"
 >WScript : typeof WScript
 >"undefined" : "undefined"
 >typeof global['WScript'].InitializeProjection !== "undefined" : boolean
->typeof global['WScript'].InitializeProjection : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
+>typeof global['WScript'].InitializeProjection : "bigint" | "boolean" | "function" | "number" | "object" | "string" | "symbol" | "undefined"
 >global['WScript'].InitializeProjection : any
 >global['WScript'] : any
 >global : any
@@= skipped -409, +409 lines =@@
 >[] : undefined[]

         var timeFunction: (
->timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: { (): void; }) => void) => void
+>timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: () => void) => void) => void

             benchmark: Benchmark,
 >benchmark : Benchmark
@@= skipped -12, +12 lines =@@
 >name : string

             f?: (bench?: { (): void; }) => void
->f : (bench?: { (): void; }) => void
+>f : (bench?: () => void) => void
 >bench : () => void

         ) => void;

         timeFunction = function (
->timeFunction = function (            benchmark: Benchmark,            description: string = benchmark.description,            name: string = '',            f = benchmark.bench        ): void {            var t = new Timer();            t.start();            var subBenchmark = function (name, f): void {                timeFunction(benchmark, description, name, f);            }            f.call(benchmark, subBenchmark);            t.end();            benchmark.addTimingFor(name, t.time);        } : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: { (): void; }) => void) => void
->timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: { (): void; }) => void) => void
->function (            benchmark: Benchmark,            description: string = benchmark.description,            name: string = '',            f = benchmark.bench        ): void {            var t = new Timer();            t.start();            var subBenchmark = function (name, f): void {                timeFunction(benchmark, description, name, f);            }            f.call(benchmark, subBenchmark);            t.end();            benchmark.addTimingFor(name, t.time);        } : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: { (): void; }) => void) => void
+>timeFunction = function (            benchmark: Benchmark,            description: string = benchmark.description,            name: string = '',            f = benchmark.bench        ): void {            var t = new Timer();            t.start();            var subBenchmark = function (name, f): void {                timeFunction(benchmark, description, name, f);            }            f.call(benchmark, subBenchmark);            t.end();            benchmark.addTimingFor(name, t.time);        } : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: () => void) => void) => void
+>timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: () => void) => void) => void
+>function (            benchmark: Benchmark,            description: string = benchmark.description,            name: string = '',            f = benchmark.bench        ): void {            var t = new Timer();            t.start();            var subBenchmark = function (name, f): void {                timeFunction(benchmark, description, name, f);            }            f.call(benchmark, subBenchmark);            t.end();            benchmark.addTimingFor(name, t.time);        } : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: () => void) => void) => void

             benchmark: Benchmark,
 >benchmark : Benchmark
@@= skipped -24, +24 lines =@@
 >'' : ""

             f = benchmark.bench
->f : (bench?: { (): void; }) => void
+>f : (bench?: () => void) => void
 >benchmark.bench : (subBench?: () => void) => void
 >benchmark : Benchmark
 >bench : (subBench?: () => void) => void
@@= skipped -26, +26 lines =@@

                 timeFunction(benchmark, description, name, f);
 >timeFunction(benchmark, description, name, f) : void
->timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: { (): void; }) => void) => void
+>timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: () => void) => void) => void
 >benchmark : Benchmark
 >description : string
 >name : any
@@= skipped -10, +10 lines =@@
             f.call(benchmark, subBenchmark);
 >f.call(benchmark, subBenchmark) : any
 >f.call : (this: Function, thisArg: any, ...argArray: any[]) => any
->f : (bench?: { (): void; }) => void
+>f : (bench?: () => void) => void
 >call : (this: Function, thisArg: any, ...argArray: any[]) => any
 >benchmark : Benchmark
 >subBenchmark : (name: any, f: any) => void
@@= skipped -74, +74 lines =@@

                     timeFunction(b);
 >timeFunction(b) : void
->timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: { (): void; }) => void) => void
+>timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: () => void) => void) => void
 >b : Benchmark

                     b.afterEach();
@@= skipped -299, +299 lines =@@
 >fileExists : (s: string) => boolean
 >s : string
 >typeof this.fileCollection[s] !== 'undefined' : boolean
->typeof this.fileCollection[s] : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
+>typeof this.fileCollection[s] : "bigint" | "boolean" | "function" | "number" | "object" | "string" | "symbol" | "undefined"
 >this.fileCollection[s] : any
 >this.fileCollection : {}
 >this : this
@@= skipped -394, +394 lines =@@

                 compileString(testCode, 'test.ts', function (compilerResult) {
 >compileString(testCode, 'test.ts', function (compilerResult) {                    errors = compilerResult.errors;                }) : void
->compileString : (code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
+>compileString : (code: string, unitName: string, callback: (res: CompilerResult) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
 >testCode : any
 >'test.ts' : "test.ts"
 >function (compilerResult) {                    errors = compilerResult.errors;                } : (compilerResult: CompilerResult) => void
@@= skipped -581, +581 lines =@@

                 if (typeof target === "string") {
 >typeof target === "string" : boolean
->typeof target : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
+>typeof target : "bigint" | "boolean" | "function" | "number" | "object" | "string" | "symbol" | "undefined"
 >target : any
 >"string" : "string"

@@= skipped -11, +11 lines =@@
                 }
                 else if (typeof target === "number") {
 >typeof target === "number" : boolean
->typeof target : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
+>typeof target : "bigint" | "boolean" | "function" | "number" | "object" | "string" | "symbol" | "undefined"
 >target : any
 >"number" : "number"

@@= skipped -15, +15 lines =@@
 >Error : ErrorConstructor
 >"Expected string or number not " + (typeof target) : string
 >"Expected string or number not " : "Expected string or number not "
->(typeof target) : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
->typeof target : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
+>(typeof target) : "bigint" | "boolean" | "function" | "number" | "object" | "string" | "symbol" | "undefined"
+>typeof target : "bigint" | "boolean" | "function" | "number" | "object" | "string" | "symbol" | "undefined"
 >target : any
                 }

@@= skipped -10, +10 lines =@@

                 compileString(code, 'test.ts', function (compilerResult) {
 >compileString(code, 'test.ts', function (compilerResult) {                    errors = compilerResult.errors;                }) : void
->compileString : (code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
+>compileString : (code: string, unitName: string, callback: (res: CompilerResult) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
 >code : string
 >'test.ts' : "test.ts"
 >function (compilerResult) {                    errors = compilerResult.errors;                } : (compilerResult: CompilerResult) => void
@@= skipped -755, +755 lines =@@
           * @param references the set of referenced files used by the given code
           */
         export function generateDeclFile(code: string, verifyNoDeclFile: boolean, unitName?: string, compilationContext?: Harness.Compiler.CompilationContext, references?: TypeScript.IFileReference[]): string {
->generateDeclFile : (code: string, verifyNoDeclFile: boolean, unitName?: string, compilationContext?: Harness.Compiler.CompilationContext, references?: TypeScript.IFileReference[]) => string
+>generateDeclFile : (code: string, verifyNoDeclFile: boolean, unitName?: string, compilationContext?: CompilationContext, references?: TypeScript.IFileReference[]) => string
 >code : string
 >verifyNoDeclFile : boolean
 >unitName : string
@@= skipped -375, +375 lines =@@
                         var match = errorLines[i].match(/([^\(]*)\((\d+),(\d+)\):\s+((.*[\s\r\n]*.*)+)\s*$/);
 >match : RegExpMatchArray
 >errorLines[i].match(/([^\(]*)\((\d+),(\d+)\):\s+((.*[\s\r\n]*.*)+)\s*$/) : RegExpMatchArray
->errorLines[i].match : (regexp: string | RegExp) => RegExpMatchArray | null
+>errorLines[i].match : (regexp: string | RegExp) => RegExpMatchArray
 >errorLines[i] : string
 >errorLines : string[]
 >i : number
->match : (regexp: string | RegExp) => RegExpMatchArray | null
+>match : (regexp: string | RegExp) => RegExpMatchArray
 >/([^\(]*)\((\d+),(\d+)\):\s+((.*[\s\r\n]*.*)+)\s*$/ : RegExp

                         if (match) {
@@= skipped -424, +424 lines =@@
 >filename : string
 >path.match(/[^\/]*$/)[0] : string
 >path.match(/[^\/]*$/) : RegExpMatchArray
->path.match : (regexp: string | RegExp) => RegExpMatchArray | null
+>path.match : (regexp: string | RegExp) => RegExpMatchArray
 >path : string
->match : (regexp: string | RegExp) => RegExpMatchArray | null
+>match : (regexp: string | RegExp) => RegExpMatchArray
 >/[^\/]*$/ : RegExp
 >0 : 0

@@= skipped -122, +122 lines =@@
             try {
                 compileString(code, filename, callback, context, references);
 >compileString(code, filename, callback, context, references) : void
->compileString : (code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
+>compileString : (code: string, unitName: string, callback: (res: CompilerResult) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
 >code : string
 >filename : string
 >callback : (res: CompilerResult) => void
@@= skipped -38, +38 lines =@@
         }

         export function compileUnits(units: TestCaseParser.TestUnitData[], callback: (res: Compiler.CompilerResult) => void , settingsCallback?: () => void ) {
->compileUnits : (units: TestCaseParser.TestUnitData[], callback: (res: Compiler.CompilerResult) => void, settingsCallback?: () => void) => void
+>compileUnits : (units: TestCaseParser.TestUnitData[], callback: (res: CompilerResult) => void, settingsCallback?: () => void) => void
 >units : TestCaseParser.TestUnitData[]
 >TestCaseParser : any
->callback : (res: Compiler.CompilerResult) => void
+>callback : (res: CompilerResult) => void
 >res : CompilerResult
 >Compiler : any
 >settingsCallback : () => void
@@= skipped -22, +22 lines =@@
 >unitName : string
 >switchToForwardSlashes(lastUnit.name).match(/[^\/]*$/)[0] : string
 >switchToForwardSlashes(lastUnit.name).match(/[^\/]*$/) : RegExpMatchArray
->switchToForwardSlashes(lastUnit.name).match : (regexp: string | RegExp) => RegExpMatchArray | null
+>switchToForwardSlashes(lastUnit.name).match : (regexp: string | RegExp) => RegExpMatchArray
 >switchToForwardSlashes(lastUnit.name) : string
 >switchToForwardSlashes : (path: string) => string
 >lastUnit.name : string
 >lastUnit : TestCaseParser.TestUnitData
 >name : string
->match : (regexp: string | RegExp) => RegExpMatchArray | null
+>match : (regexp: string | RegExp) => RegExpMatchArray
 >/[^\/]*$/ : RegExp
 >0 : 0

@@= skipped -41, +41 lines =@@
 >lastUnit : TestCaseParser.TestUnitData
 >content : string
 >unitName : string
->callback : (res: Compiler.CompilerResult) => void
+>callback : (res: CompilerResult) => void
 >settingsCallback : () => void
 >compilationContext : CompilationContext
 >lastUnit.references : TypeScript.IFileReference[]
@@= skipped -36, +36 lines =@@
         }

         export function compileString(code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void , context?: CompilationContext, references?: TypeScript.IFileReference[]) {
->compileString : (code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
+>compileString : (code: string, unitName: string, callback: (res: CompilerResult) => void, context?: CompilationContext, references?: TypeScript.IFileReference[]) => void
 >code : string
 >unitName : string
->callback : (res: Compiler.CompilerResult) => void
+>callback : (res: CompilerResult) => void
 >res : CompilerResult
 >Compiler : any
 >context : CompilationContext
@@= skipped -45, +45 lines =@@
 >context ? unitName : ((isDeclareFile) ? '0.d.ts' : '0.ts') : string
 >context : CompilationContext
 >unitName : string
->((isDeclareFile) ? '0.d.ts' : '0.ts') : "0.ts" | "0.d.ts"
->(isDeclareFile) ? '0.d.ts' : '0.ts' : "0.ts" | "0.d.ts"
+>((isDeclareFile) ? '0.d.ts' : '0.ts') : "0.d.ts" | "0.ts"
+>(isDeclareFile) ? '0.d.ts' : '0.ts' : "0.d.ts" | "0.ts"
 >(isDeclareFile) : boolean
 >isDeclareFile : boolean
 >'0.d.ts' : "0.d.ts"
@@= skipped -82, +82 lines =@@

             callback(new CompilerResult(stdout.toArray(), errors, scripts));
 >callback(new CompilerResult(stdout.toArray(), errors, scripts)) : void
->callback : (res: Compiler.CompilerResult) => void
+>callback : (res: CompilerResult) => void
 >new CompilerResult(stdout.toArray(), errors, scripts) : CompilerResult
 >CompilerResult : typeof CompilerResult
 >stdout.toArray() : { filename: string; file: WriterAggregator; }[]
@@= skipped -295, +295 lines =@@
                     var isRef = line.match(/reference\spath='(\w*_?\w*\.?d?\.ts)'/);
 >isRef : RegExpMatchArray
 >line.match(/reference\spath='(\w*_?\w*\.?d?\.ts)'/) : RegExpMatchArray
->line.match : (regexp: string | RegExp) => RegExpMatchArray | null
+>line.match : (regexp: string | RegExp) => RegExpMatchArray
 >line : string
->match : (regexp: string | RegExp) => RegExpMatchArray | null
+>match : (regexp: string | RegExp) => RegExpMatchArray
 >/reference\spath='(\w*_?\w*\.?d?\.ts)'/ : RegExp

                     if (isRef) {
@@= skipped -1586, +1586 lines =@@

             return JSON.stringify({ usePullLanguageService: usePull });
 >JSON.stringify({ usePullLanguageService: usePull }) : string
->JSON.stringify : { (value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (number | string)[] | null, space?: string | number): string; }
+>JSON.stringify : { (value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; }
 >JSON : JSON
->stringify : { (value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (number | string)[] | null, space?: string | number): string; }
+>stringify : { (value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; }
 >{ usePullLanguageService: usePull } : { usePullLanguageService: boolean; }
 >usePullLanguageService : boolean
 >usePull : boolean
@@= skipped -93, +93 lines =@@

         if (typeof process !== "undefined") {
 >typeof process !== "undefined" : boolean
->typeof process : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
+>typeof process : "bigint" | "boolean" | "function" | "number" | "object" | "string" | "symbol" | "undefined"
 >process : typeof process
 >"undefined" : "undefined"

@@= skipped -54, +54 lines =@@
 >path : string
 >path.match(/[^\/]*$/)[0] : string
 >path.match(/[^\/]*$/) : RegExpMatchArray
->path.match : (regexp: string | RegExp) => RegExpMatchArray | null
+>path.match : (regexp: string | RegExp) => RegExpMatchArray
 >path : string
->match : (regexp: string | RegExp) => RegExpMatchArray | null
+>match : (regexp: string | RegExp) => RegExpMatchArray
 >/[^\/]*$/ : RegExp
 >0 : 0
 >callback : (error: Error, result: any) => void