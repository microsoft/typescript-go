--- old.generatorReturnTypeInferenceNonStrict.errors.txt
+++ new.generatorReturnTypeInferenceNonStrict.errors.txt
@@= skipped -0, +0 lines =@@
-generatorReturnTypeInferenceNonStrict.ts(9,11): error TS7055: 'g001', which lacks return-type annotation, implicitly has an 'any' yield type.
-generatorReturnTypeInferenceNonStrict.ts(17,11): error TS7055: 'g003', which lacks return-type annotation, implicitly has an 'any' yield type.
 generatorReturnTypeInferenceNonStrict.ts(74,15): error TS7057: 'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation.
-generatorReturnTypeInferenceNonStrict.ts(79,11): error TS7055: 'g301', which lacks return-type annotation, implicitly has an 'any' yield type.
-generatorReturnTypeInferenceNonStrict.ts(89,11): error TS7055: 'g303', which lacks return-type annotation, implicitly has an 'any' yield type.
-generatorReturnTypeInferenceNonStrict.ts(126,11): error TS7055: 'g310', which lacks return-type annotation, implicitly has an 'any' yield type.
-generatorReturnTypeInferenceNonStrict.ts(131,10): error TS7025: Generator implicitly has yield type 'any'. Consider supplying a return type annotation.
 
 
-==== generatorReturnTypeInferenceNonStrict.ts (7 errors) ====
+==== generatorReturnTypeInferenceNonStrict.ts (1 errors) ====
     declare const iterableIterator: IterableIterator<number>;
     declare const generator: Generator<number, string, boolean>;
     declare const never: never;
@@= skipped -16, +10 lines =@@
     
     // 'yield' iteration type inference
     function* g001() { // Generator<any (implicit), void, unknown>
-              ~~~~
-!!! error TS7055: 'g001', which lacks return-type annotation, implicitly has an 'any' yield type.
         yield;
     }
     
@@= skipped -10, +8 lines =@@
     }
     
     function* g003() { // Generator<any (implicit), void, unknown>
-              ~~~~
-!!! error TS7055: 'g003', which lacks return-type annotation, implicitly has an 'any' yield type.
         // NOTE: In strict mode, `[]` produces the type `never[]`.
         //       In non-strict mode, `[]` produces the type `undefined[]` which is implicitly any.
         yield* [];
@@= skipped -66, +64 lines =@@
     // mixed iteration types inference
     
     function* g301() { // Generator<any (implicit), void, unknown>
-              ~~~~
-!!! error TS7055: 'g301', which lacks return-type annotation, implicitly has an 'any' yield type.
         yield;
         return;
     }
@@= skipped -12, +10 lines =@@
     }
     
     function* g303() { // Generator<any (implicit), string, unknown>
-              ~~~~
-!!! error TS7055: 'g303', which lacks return-type annotation, implicitly has an 'any' yield type.
         yield;
         return "a";
     }
@@= skipped -39, +37 lines =@@
     }
     
     function* g310() { // Generator<any (implicit), void, [(1 | undefined)?, (2 | undefined)?]>
-              ~~~~
-!!! error TS7055: 'g310', which lacks return-type annotation, implicitly has an 'any' yield type.
     	const [a = 1, b = 2] = yield;
     }
     
     function* g311() { // Generator<any (implicit), void, string>
     	yield* (function*() {
-    	        ~~~~~~~~
-!!! error TS7025: Generator implicitly has yield type 'any'. Consider supplying a return type annotation.
     		const y: string = yield;
     	})();
     }
