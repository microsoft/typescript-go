--- old.variadicTuples1.js
+++ new.variadicTuples1.js
@@= skipped -425, +425 lines =@@


 //// [variadicTuples1.js]
-"use strict";
-// Variadics in tuple types
-var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
-    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
-        if (ar || !(i in from)) {
-            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
-            ar[i] = from[i];
-        }
-    }
-    return to.concat(ar || Array.prototype.slice.call(from));
-};
 // Variadics in array literals
 function tup2(t, u) {
-    return __spreadArray(__spreadArray(__spreadArray(__spreadArray([1], t, true), [2], false), u, true), [3], false);
+    return [1, ...t, 2, ...u, 3];
 }
-var t2 = tup2(['hello'], [10, true]);
+const t2 = tup2(['hello'], [10, true]);
 function concat(t, u) {
-    return __spreadArray(__spreadArray([], t, true), u, true);
+    return [...t, ...u];
 }
-var tc1 = concat([], []);
-var tc2 = concat(['hello'], [42]);
-var tc3 = concat([1, 2, 3], sa);
-var tc4 = concat(sa, [1, 2, 3]); // Ideally would be [...string[], number, number, number]
+const tc1 = concat([], []);
+const tc2 = concat(['hello'], [42]);
+const tc3 = concat([1, 2, 3], sa);
+const tc4 = concat(sa, [1, 2, 3]); // Ideally would be [...string[], number, number, number]
 function concat2(t, u) {
-    return __spreadArray(__spreadArray([], t, true), u, true); // (T[number] | U[number])[]
+    return [...t, ...u]; // (T[number] | U[number])[]
 }
-var tc5 = concat2([1, 2, 3], [4, 5, 6]); // (1 | 2 | 3 | 4 | 5 | 6)[]
+const tc5 = concat2([1, 2, 3], [4, 5, 6]); // (1 | 2 | 3 | 4 | 5 | 6)[]
 function foo2(t1, t2, a1) {
     foo1(1, 'abc', true, 42, 43, 44);
-    foo1.apply(void 0, __spreadArray(__spreadArray([], t1, false), [true, 42, 43, 44], false));
-    foo1.apply(void 0, __spreadArray(__spreadArray(__spreadArray([], t1, false), t2, false), [42, 43, 44], false));
-    foo1.apply(void 0, __spreadArray(__spreadArray(__spreadArray([], t1, false), t2, false), a1, false));
-    foo1.apply(void 0, t1); // Error
-    foo1.apply(void 0, __spreadArray(__spreadArray([], t1, false), [45], false)); // Error
+    foo1(...t1, true, 42, 43, 44);
+    foo1(...t1, ...t2, 42, 43, 44);
+    foo1(...t1, ...t2, ...a1);
+    foo1(...t1); // Error
+    foo1(...t1, 45); // Error
 }
 function foo4(u) {
     foo3(1, 2);
     foo3(1, 'hello', true, 2);
-    foo3.apply(void 0, __spreadArray(__spreadArray([1], u, false), ['hi', 2], false));
+    foo3(1, ...u, 'hi', 2);
     foo3(1);
 }
 ft1(['hello', 42]); // (string | number)[]
@@= skipped -47, +36 lines =@@
 ft4(['hello', 42]); // readonly [string, number]
 // Indexing variadic tuple types
 function f0(t, n) {
-    var a = t[0]; // string
-    var b = t[1]; // [string, ...T][1]
-    var c = t[2]; // [string, ...T][2]
-    var d = t[n]; // [string, ...T][number]
+    const a = t[0]; // string
+    const b = t[1]; // [string, ...T][1]
+    const c = t[2]; // [string, ...T][2]
+    const d = t[n]; // [string, ...T][number]
 }
 function f1(t, n) {
-    var a = t[0]; // string
-    var b = t[1]; // number | T[number]
-    var c = t[2]; // [string, ...T, number][2]
-    var d = t[n]; // [string, ...T, number][number]
+    const a = t[0]; // string
+    const b = t[1]; // number | T[number]
+    const c = t[2]; // [string, ...T, number][2]
+    const d = t[n]; // [string, ...T, number][number]
 }
 // Destructuring variadic tuple types
 function f2(t) {
-    var ax = t.slice(0); // [string, ...T]
-    var b1 = t[0], bx = t.slice(1); // string, [...T]
-    var c1 = t[0], c2 = t[1], cx = t.slice(2); // string, [string, ...T][1], T[number][]
+    let [...ax] = t; // [string, ...T]
+    let [b1, ...bx] = t; // string, [...T]
+    let [c1, c2, ...cx] = t; // string, [string, ...T][1], T[number][]
 }
 function f3(t) {
-    var ax = t.slice(0); // [string, ...T, number]
-    var b1 = t[0], bx = t.slice(1); // string, [...T, number]
-    var c1 = t[0], c2 = t[1], cx = t.slice(2); // string, number | T[number], (number | T[number])[]
+    let [...ax] = t; // [string, ...T, number]
+    let [b1, ...bx] = t; // string, [...T, number]
+    let [c1, c2, ...cx] = t; // string, number | T[number], (number | T[number])[]
 }
-var tm1 = fm1([['abc'], [42], [true], ['def']]); // [boolean, string]
+let tm1 = fm1([['abc'], [42], [true], ['def']]); // [boolean, string]
 function gx1(u, v) {
     fx1('abc'); // []
-    fx1.apply(void 0, __spreadArray(['abc'], u, false)); // U
-    fx1.apply(void 0, __spreadArray(['abc'], v, false)); // [...V]
-    fx1.apply(void 0, __spreadArray(['abc'], u, false)); // U
-    fx1.apply(void 0, __spreadArray(['abc'], v, false)); // Error
+    fx1('abc', ...u); // U
+    fx1('abc', ...v); // [...V]
+    fx1('abc', ...u); // U
+    fx1('abc', ...v); // Error
 }
 function gx2(u, v) {
     fx2('abc'); // []
-    fx2.apply(void 0, __spreadArray(['abc'], u, false)); // U
-    fx2.apply(void 0, __spreadArray(['abc'], v, false)); // [...V]
-    fx2.apply(void 0, __spreadArray(['abc'], u, false)); // U
-    fx2.apply(void 0, __spreadArray(['abc'], v, false)); // V
+    fx2('abc', ...u); // U
+    fx2('abc', ...v); // [...V]
+    fx2('abc', ...u); // U
+    fx2('abc', ...v); // V
 }
 // Relations involving variadic tuple types
 function f10(x, y, z) {
@@= skipped -102, +102 lines =@@
     x = y;
 }
 // Inference to [...T, ...U] with implied arity for T
-function curry(f) {
-    var a = [];
-    for (var _i = 1; _i < arguments.length; _i++) {
-        a[_i - 1] = arguments[_i];
-    }
-    return function () {
-        var b = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            b[_i] = arguments[_i];
-        }
-        return f.apply(void 0, __spreadArray(__spreadArray([], a, false), b, false));
-    };
+function curry(f, ...a) {
+    return (...b) => f(...a, ...b);
 }
-var fn1 = function (a, b, c, d) { return 0; };
-var c0 = curry(fn1); // (a: number, b: string, c: boolean, d: string[]) => number
-var c1 = curry(fn1, 1); // (b: string, c: boolean, d: string[]) => number
-var c2 = curry(fn1, 1, 'abc'); // (c: boolean, d: string[]) => number
-var c3 = curry(fn1, 1, 'abc', true); // (d: string[]) => number
-var c4 = curry(fn1, 1, 'abc', true, ['x', 'y']); // () => number
-var fn2 = function (x, b) {
-    var args = [];
-    for (var _i = 2; _i < arguments.length; _i++) {
-        args[_i - 2] = arguments[_i];
-    }
-    return 0;
-};
-var c10 = curry(fn2); // (x: number, b: boolean, ...args: string[]) => number
-var c11 = curry(fn2, 1); // (b: boolean, ...args: string[]) => number
-var c12 = curry(fn2, 1, true); // (...args: string[]) => number
-var c13 = curry(fn2, 1, true, 'abc', 'def'); // (...args: string[]) => number
-var fn3 = function () {
-    var args = [];
-    for (var _i = 0; _i < arguments.length; _i++) {
-        args[_i] = arguments[_i];
-    }
-    return 0;
-};
-var c20 = curry(fn3); // (...args: string[]) => number
-var c21 = curry(fn3, 'abc', 'def'); // (...args: string[]) => number
-var c22 = curry.apply(void 0, __spreadArray([fn3], sa, false)); // (...args: string[]) => number
+const fn1 = (a, b, c, d) => 0;
+const c0 = curry(fn1); // (a: number, b: string, c: boolean, d: string[]) => number
+const c1 = curry(fn1, 1); // (b: string, c: boolean, d: string[]) => number
+const c2 = curry(fn1, 1, 'abc'); // (c: boolean, d: string[]) => number
+const c3 = curry(fn1, 1, 'abc', true); // (d: string[]) => number
+const c4 = curry(fn1, 1, 'abc', true, ['x', 'y']); // () => number
+const fn2 = (x, b, ...args) => 0;
+const c10 = curry(fn2); // (x: number, b: boolean, ...args: string[]) => number
+const c11 = curry(fn2, 1); // (b: boolean, ...args: string[]) => number
+const c12 = curry(fn2, 1, true); // (...args: string[]) => number
+const c13 = curry(fn2, 1, true, 'abc', 'def'); // (...args: string[]) => number
+const fn3 = (...args) => 0;
+const c20 = curry(fn3); // (...args: string[]) => number
+const c21 = curry(fn3, 'abc', 'def'); // (...args: string[]) => number
+const c22 = curry(fn3, ...sa); // (...args: string[]) => number
 // No inference to [...T, ...U] when there is no implied arity
 function curry2(f, t, u) {
-    return f.apply(void 0, __spreadArray(__spreadArray([], t, false), u, false));
+    return f(...t, ...u);
 }
 curry2(fn10, ['hello', 42], [true]);
 curry2(fn10, ['hello'], [42, true]);
@@= skipped -50, +28 lines =@@
 ft([1, 2], [1, 2, 3]);
 ft(['a', 'b'], ['c', 'd']);
 ft(['a', 'b'], ['c', 'd', 42]);
-call('hello', 32, function (a, b) { return 42; });
-call.apply(void 0, __spreadArray(__spreadArray([], sa, false), [function () {
-        var x = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            x[_i] = arguments[_i];
-        }
-        return 42;
-    }], false));
+call('hello', 32, (a, b) => 42);
+call(...sa, (...x) => 42);
 function f21(args) {
-    var v1 = f20(args); // U
-    var v2 = f20(["foo", "bar"]); // [string]
-    var v3 = f20(["foo", 42]); // [string]
+    let v1 = f20(args); // U
+    let v2 = f20(["foo", "bar"]); // [string]
+    let v3 = f20(["foo", 42]); // [string]
 }
 function f23(args) {
-    var v1 = f22(args); // U
-    var v2 = f22(["foo", "bar"]); // [string, string]
-    var v3 = f22(["foo", 42]); // [string]
+    let v1 = f22(args); // U
+    let v2 = f22(["foo", "bar"]); // [string, string]
+    let v3 = f22(["foo", 42]); // [string]
 }
-var b = a.bind("", 1); // Desc<[boolean], object>
+const b = a.bind("", 1); // Desc<[boolean], object>
 function callApi(method) {
-    return function () {
-        var args = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            args[_i] = arguments[_i];
-        }
-        return method.apply(void 0, __spreadArray(__spreadArray([], args, false), [{}], false));
-    };
+    return (...args) => method(...args, {});
 }
 callApi(getUser);
 callApi(getOrgUser);
-var data = [false, false]; // Error
+const data = [false, false]; // Error


 //// [variadicTuples1.d.ts]
@@= skipped -54, +42 lines =@@
 declare const tc3: [number, number, number, ...string[]];
 declare const tc4: [...string[], number, number, number];
 declare function concat2<T extends readonly unknown[], U extends readonly unknown[]>(t: T, u: U): (T[number] | U[number])[];
-declare const tc5: (2 | 4 | 1 | 3 | 6 | 5)[];
+declare const tc5: (1 | 2 | 3 | 4 | 5 | 6)[];
 declare function foo1(a: number, b: string, c: boolean, ...d: number[]): void;
 declare function foo2(t1: [number, string], t2: [boolean], a1: number[]): void;
 declare function foo3<T extends unknown[]>(x: number, ...args: [...T, number]): T;
@@= skipped -144, +144 lines =@@
     y?: number;
     z?: boolean;
 }): void;
-declare function callApi<T extends unknown[] = [], U = void>(method: (...args: [...T, object]) => U): (...args: [...T]) => U;
+declare function callApi<T extends unknown[] = [], U = void>(method: (...args: [...T, object]) => U): (...args: T) => U;
 type Numbers = number[];
 type Unbounded = [...Numbers, boolean];
 declare const data: Unbounded;
@@= skipped -10, +10 lines =@@
 type ToStringLength1<T extends any[]> = `${T['length']}`;
 type ToStringLength2<T extends any[]> = `${[...T]['length']}`;
 type AnyArr = [...any];
-
-
-!!!! File variadicTuples1.d.ts differs from original emit in noCheck emit
-//// [variadicTuples1.d.ts]
-===================================================================
---- Expected	The full check baseline
-+++ Actual	with noCheck set
-@@= skipped --816, +-771 lines =@@
- declare const tc2: [string, number];
- declare const tc3: [number, number, number, ...string[]];
- declare const tc4: [...string[], number, number, number];
- declare function concat2<T extends readonly unknown[], U extends readonly unknown[]>(t: T, u: U): (T[number] | U[number])[];
--declare const tc5: (2 | 4 | 1 | 3 | 6 | 5)[];
-+declare const tc5: (3 | 2 | 1 | 6 | 4 | 5)[];
- declare function foo1(a: number, b: string, c: boolean, ...d: number[]): void;
- declare function foo2(t1: [number, string], t2: [boolean], a1: number[]): void;
- declare function foo3<T extends unknown[]>(x: number, ...args: [...T, number]): T;
- declare function foo4<U extends unknown[]>(u: U): void;