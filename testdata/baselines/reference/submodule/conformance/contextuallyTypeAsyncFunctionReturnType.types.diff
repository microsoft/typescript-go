--- old.contextuallyTypeAsyncFunctionReturnType.types
+++ new.contextuallyTypeAsyncFunctionReturnType.types
@@= skipped -137, +137 lines =@@
   return new Promise((resolve, reject) => {
 >new Promise((resolve, reject) => {    getProcessTree(123, (tree) => {      if (tree) {        resolve();      } else {        reject(new Error("windows-process-tree"));      }    });  }) : Promise<void>
 >Promise : PromiseConstructor
->(resolve, reject) => {    getProcessTree(123, (tree) => {      if (tree) {        resolve();      } else {        reject(new Error("windows-process-tree"));      }    });  } : (resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void) => void
->resolve : (value: void | PromiseLike<void>) => void
+>(resolve, reject) => {    getProcessTree(123, (tree) => {      if (tree) {        resolve();      } else {        reject(new Error("windows-process-tree"));      }    });  } : (resolve: (value?: void | PromiseLike<void>) => void, reject: (reason?: any) => void) => void
+>resolve : (value?: void | PromiseLike<void>) => void
 >reject : (reason?: any) => void
 
     getProcessTree(123, (tree) => {
@@= skipped -16, +16 lines =@@
 
         resolve();
 >resolve() : void
->resolve : (value: void | PromiseLike<void>) => void
+>resolve : (value?: void | PromiseLike<void>) => void
 
       } else {
         reject(new Error("windows-process-tree"));
@@= skipped -29, +29 lines =@@
 
 };
 declare function scanMetadata(
->scanMetadata : (local: ILocalExtension) => Promise<Metadata | undefined>
+>scanMetadata : (local: ILocalExtension) => Promise<Metadata>
 
   local: ILocalExtension
 >local : ILocalExtension
@@= skipped -20, +20 lines =@@
     await Promise.all(
 >await Promise.all(      fromExtensions        .filter((e) => !e.isApplicationScoped)        .map(async (e) => [e, await scanMetadata(e)])    ) : [ILocalExtension, Metadata][]
 >Promise.all(      fromExtensions        .filter((e) => !e.isApplicationScoped)        .map(async (e) => [e, await scanMetadata(e)])    ) : Promise<[ILocalExtension, Metadata][]>
->Promise.all : { <T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>[]>; <T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]>; }>; }
+>Promise.all : { <T>(values: Iterable<T | PromiseLike<T>, any, any>): Promise<Awaited<T>[]>; <T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]>; }>; }
 >Promise : PromiseConstructor
->all : { <T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>[]>; <T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]>; }>; }
+>all : { <T>(values: Iterable<T | PromiseLike<T>, any, any>): Promise<Awaited<T>[]>; <T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]>; }>; }
 
       fromExtensions
 >fromExtensions        .filter((e) => !e.isApplicationScoped)        .map(async (e) => [e, await scanMetadata(e)]) : Promise<[ILocalExtension, Metadata]>[]
@@= skipped -28, +28 lines =@@
 >e : ILocalExtension
 >await scanMetadata(e) : Metadata
 >scanMetadata(e) : Promise<Metadata>
->scanMetadata : (local: ILocalExtension) => Promise<Metadata | undefined>
+>scanMetadata : (local: ILocalExtension) => Promise<Metadata>
 >e : ILocalExtension
 
     );
