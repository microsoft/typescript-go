--- old.inferenceShouldFailOnEvolvingArrays.types
+++ new.inferenceShouldFailOnEvolvingArrays.types
@@= skipped -3, +3 lines =@@
 // repro from https://github.com/Microsoft/TypeScript/issues/25675
 // The type of `arg` blocks inference but simplifies to T.
 function logLength<T extends string, U extends string>(arg: { [K in U]: T }[U]): T {
->logLength : <T extends string, U extends string>(arg: { [K in U]: T; }[U]) => T
+>logLength : <T extends string, U extends string>(arg: {    [K in U]: T;}[U]) => T
 >arg : { [K in U]: T; }[U]

     console.log(arg.length);
@@= skipped -17, +17 lines =@@
 }
 logLength(42);  // error
 >logLength(42) : string
->logLength : <T extends string, U extends string>(arg: { [K in U]: T; }[U]) => T
+>logLength : <T extends string, U extends string>(arg: {    [K in U]: T;}[U]) => T
 >42 : 42

 let z;
@@= skipped -10, +10 lines =@@
 >z = logLength(42) : string
 >z : any
 >logLength(42) : string
->logLength : <T extends string, U extends string>(arg: { [K in U]: T; }[U]) => T
+>logLength : <T extends string, U extends string>(arg: {    [K in U]: T;}[U]) => T
 >42 : 42

 function logFirstLength<T extends string[], U extends string>(arg: { [K in U]: T }[U]): T {
->logFirstLength : <T extends string[], U extends string>(arg: { [K in U]: T; }[U]) => T
+>logFirstLength : <T extends string[], U extends string>(arg: {    [K in U]: T;}[U]) => T
 >arg : { [K in U]: T; }[U]

     console.log(arg[0].length);
@@= skipped -23, +23 lines =@@
 }
 logFirstLength([42]);  // error
 >logFirstLength([42]) : string[]
->logFirstLength : <T extends string[], U extends string>(arg: { [K in U]: T; }[U]) => T
+>logFirstLength : <T extends string[], U extends string>(arg: {    [K in U]: T;}[U]) => T
 >[42] : number[]
 >42 : 42

@@= skipped -14, +14 lines =@@
 >zz : any[]
 >push : (...items: any[]) => number
 >logLength(42) : string
->logLength : <T extends string, U extends string>(arg: { [K in U]: T; }[U]) => T
+>logLength : <T extends string, U extends string>(arg: {    [K in U]: T;}[U]) => T
 >42 : 42

 zz = logFirstLength([42]);  // no error; T is inferred as `any[]`
 >zz = logFirstLength([42]) : string[]
 >zz : any[]
 >logFirstLength([42]) : string[]
->logFirstLength : <T extends string[], U extends string>(arg: { [K in U]: T; }[U]) => T
+>logFirstLength : <T extends string[], U extends string>(arg: {    [K in U]: T;}[U]) => T
 >[42] : number[]
 >42 : 42
