--- old.noUnusedLocals_selfReference.types
+++ new.noUnusedLocals_selfReference.types
@@= skipped -4, +4 lines =@@
 
 function f() {
 >f : () => void
->  : ^^^^^^^^^^
 
     f;
 >f : () => void
->  : ^^^^^^^^^^
 
     function g() {
 >g : () => void
->  : ^^^^^^^^^^
 
         g;
 >g : () => void
->  : ^^^^^^^^^^
     }
 }
 class C {
 >C : C
->  : ^
 
     m() { C; }
 >m : () => void
->  : ^^^^^^^^^^
 >C : typeof C
->  : ^^^^^^^^
 }
 enum E { A = 0, B = E.A }
->E : E
->  : ^
+>E : E.A
 >A : E.A
->  : ^^^
 >0 : 0
->  : ^
 >B : E.A
->  : ^^^
->E.A : E
->    : ^
+>E.A : E.A
 >E : typeof E
->  : ^^^^^^^^
->A : E
->  : ^
+>A : E.A
 
 interface I { x: I };
+>I : I
 >x : I
->  : ^
 
 type T = { x: T };
 >T : T
->  : ^
 >x : T
->  : ^
 
 namespace N { N; }
 >N : typeof N
->  : ^^^^^^^^
 >N : typeof N
->  : ^^^^^^^^
 
 // Avoid a false positive.
 // Previously `T` was considered unused due to merging with the property,
 // back when all non-blocks were checked for recursion.
 export interface A<T> { T: T }
+>A : A<T>
 >T : T
->  : ^
+>T : T
 
 class P { private m() { this.m; } }
 >P : P
->  : ^
 >m : () => void
->  : ^^^^^^^^^^
 >this.m : () => void
->       : ^^^^^^^^^^
 >this : this
->     : ^^^^
 >m : () => void
->  : ^^^^^^^^^^
 
 P;
 >P : typeof P
->  : ^^^^^^^^
 
 // Does not detect mutual recursion.
 function g() { D; }
 >g : () => void
->  : ^^^^^^^^^^
 >D : typeof D
->  : ^^^^^^^^
 
 class D { m() { g; } }
 >D : D
->  : ^
 >m : () => void
->  : ^^^^^^^^^^
 >g : () => void
->  : ^^^^^^^^^^
 
