//// [tests/cases/compiler/uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts] ////

=== uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts ===
const FOO_SYMBOL = Symbol('Foo');
>FOO_SYMBOL : Symbol(FOO_SYMBOL, Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 0, 5))

declare global {
>global : Symbol((Missing), Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 0, 33))

    interface Promise<T> {
>Promise : Symbol(Promise, Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 2, 16))
>T : Symbol(T, Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 3, 22))

        [FOO_SYMBOL]?: number;
>[FOO_SYMBOL] : Symbol([FOO_SYMBOL], Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 3, 26))
>FOO_SYMBOL : Symbol(FOO_SYMBOL, Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 0, 5))
    }
}

export function foo<T>(p: Promise<T>) {
>foo : Symbol(foo, Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 6, 1))
>T : Symbol(T, Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 8, 20))
>p : Symbol(p, Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 8, 23))
>Promise : Symbol(Promise, Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 2, 16))
>T : Symbol(T, Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 8, 20))

    p[FOO_SYMBOL] = 3;
>p : Symbol(p, Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 8, 23))
>FOO_SYMBOL : Symbol(FOO_SYMBOL, Decl(uniqueSymbolAssignmentOnGlobalAugmentationSuceeds.ts, 0, 5))
}
