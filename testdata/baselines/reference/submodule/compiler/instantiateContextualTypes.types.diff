--- old.instantiateContextualTypes.types
+++ new.instantiateContextualTypes.types
@@= skipped -66, +66 lines =@@
 // #22149

 declare function useStringOrNumber<T extends string | number>(t: T, useIt: T extends string ? ((s: string) => void) : ((n: number) => void)): void;
->useStringOrNumber : <T extends string | number>(t: T, useIt: T extends string ? ((s: string) => void) : ((n: number) => void)) => void
+>useStringOrNumber : <T extends string | number>(t: T, useIt: T extends string ? (s: string) => void : (n: number) => void) => void
 >t : T
 >useIt : T extends string ? (s: string) => void : (n: number) => void
 >s : string
@@= skipped -8, +8 lines =@@

 useStringOrNumber("", foo => {});
 >useStringOrNumber("", foo => {}) : void
->useStringOrNumber : <T extends string | number>(t: T, useIt: T extends string ? ((s: string) => void) : ((n: number) => void)) => void
+>useStringOrNumber : <T extends string | number>(t: T, useIt: T extends string ? (s: string) => void : (n: number) => void) => void
 >"" : ""
 >foo => {} : (foo: string) => void
 >foo : string
@@= skipped -148, +148 lines =@@
 }

 type CreateElementChildren<P> =
->CreateElementChildren : P extends { children?: infer C; } ? C extends any[] ? C : C[] : unknown
+>CreateElementChildren : P extends { children?: infer C | undefined; } ? C extends any[] ? C : C[] : unknown

   P extends { children?: infer C }
 >children : C | undefined
@@= skipped -11, +11 lines =@@
   : unknown;

 declare function createElement<P extends {}>(
->createElement : <P extends {}>(type: ComponentClass<P>, ...children: P extends { children?: infer C; } ? C extends any[] ? C : C[] : unknown) => any
+>createElement : <P extends {}>(type: ComponentClass<P>, ...children: P extends { children?: infer C | undefined; } ? C extends any[] ? C : C[] : unknown) => any

   type: ComponentClass<P>,
 >type : ComponentClass<P>

   ...children: CreateElementChildren<P>
->children : P extends { children?: infer C; } ? C extends any[] ? C : C[] : unknown
+>children : P extends { children?: infer C | undefined; } ? C extends any[] ? C : C[] : unknown

 ): any;

 declare function createElement2<P extends {}>(
->createElement2 : <P extends {}>(type: ComponentClass<P>, child: P extends { children?: infer C; } ? C extends any[] ? C : C[] : unknown) => any
+>createElement2 : <P extends {}>(type: ComponentClass<P>, child: P extends { children?: infer C | undefined; } ? C extends any[] ? C : C[] : unknown) => any

   type: ComponentClass<P>,
 >type : ComponentClass<P>

   child: CreateElementChildren<P>
->child : P extends { children?: infer C; } ? C extends any[] ? C : C[] : unknown
+>child : P extends { children?: infer C | undefined; } ? C extends any[] ? C : C[] : unknown

 ): any;

@@= skipped -29, +29 lines =@@

 createElement(InferFunctionTypes, (foo) => "" + foo);
 >createElement(InferFunctionTypes, (foo) => "" + foo) : any
->createElement : <P extends {}>(type: ComponentClass<P>, ...children: P extends { children?: infer C; } ? C extends any[] ? C : C[] : unknown) => any
+>createElement : <P extends {}>(type: ComponentClass<P>, ...children: P extends { children?: infer C | undefined; } ? C extends any[] ? C : C[] : unknown) => any
 >InferFunctionTypes : typeof InferFunctionTypes
 >(foo) => "" + foo : (foo: number) => string
 >foo : number
@@= skipped -10, +10 lines =@@

 createElement2(InferFunctionTypes, [(foo) => "" + foo]);
 >createElement2(InferFunctionTypes, [(foo) => "" + foo]) : any
->createElement2 : <P extends {}>(type: ComponentClass<P>, child: P extends { children?: infer C; } ? C extends any[] ? C : C[] : unknown) => any
+>createElement2 : <P extends {}>(type: ComponentClass<P>, child: P extends { children?: infer C | undefined; } ? C extends any[] ? C : C[] : unknown) => any
 >InferFunctionTypes : typeof InferFunctionTypes
 >[(foo) => "" + foo] : ((foo: number) => string)[]
 >(foo) => "" + foo : (foo: number) => string
@@= skipped -68, +68 lines =@@
 >() : Promise<DooDad> => {		return Promise.resolve().then(() => {			if (1 < 2) {				return 'SOMETHING';			}			return 'ELSE';		});	} : () => Promise<DooDad>

 		return Promise.resolve().then(() => {
->Promise.resolve().then(() => {			if (1 < 2) {				return 'SOMETHING';			}			return 'ELSE';		}) : Promise<"SOMETHING" | "ELSE">
+>Promise.resolve().then(() => {			if (1 < 2) {				return 'SOMETHING';			}			return 'ELSE';		}) : Promise<"ELSE" | "SOMETHING">
 >Promise.resolve().then : <TResult1 = void, TResult2 = never>(onfulfilled?: ((value: void) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>
 >Promise.resolve() : Promise<void>
 >Promise.resolve : { (): Promise<void>; <T>(value: T): Promise<Awaited<T>>; <T>(value: T | PromiseLike<T>): Promise<Awaited<T>>; }
 >Promise : PromiseConstructor
 >resolve : { (): Promise<void>; <T>(value: T): Promise<Awaited<T>>; <T>(value: T | PromiseLike<T>): Promise<Awaited<T>>; }
 >then : <TResult1 = void, TResult2 = never>(onfulfilled?: ((value: void) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>
->() => {			if (1 < 2) {				return 'SOMETHING';			}			return 'ELSE';		} : () => "SOMETHING" | "ELSE"
+>() => {			if (1 < 2) {				return 'SOMETHING';			}			return 'ELSE';		} : () => "ELSE" | "SOMETHING"

 			if (1 < 2) {
 >1 < 2 : boolean
@@= skipped -27, +27 lines =@@
 >() : Promise<DooDad> => {		return Promise.resolve().then(() => {			return 'ELSE';		});	} : () => Promise<DooDad>

 		return Promise.resolve().then(() => {
->Promise.resolve().then(() => {			return 'ELSE';		}) : Promise<"SOMETHING" | "ELSE">
+>Promise.resolve().then(() => {			return 'ELSE';		}) : Promise<"ELSE" | "SOMETHING">
 >Promise.resolve().then : <TResult1 = void, TResult2 = never>(onfulfilled?: ((value: void) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>
 >Promise.resolve() : Promise<void>
 >Promise.resolve : { (): Promise<void>; <T>(value: T): Promise<Awaited<T>>; <T>(value: T | PromiseLike<T>): Promise<Awaited<T>>; }
@@= skipped -19, +19 lines =@@
 >() : Promise<DooDad> => {		return Promise.resolve().then(() => {			if (1 < 2) {				return 'SOMETHING';			}			return 'SOMETHING';		});	} : () => Promise<DooDad>

 		return Promise.resolve().then(() => {
->Promise.resolve().then(() => {			if (1 < 2) {				return 'SOMETHING';			}			return 'SOMETHING';		}) : Promise<"SOMETHING" | "ELSE">
+>Promise.resolve().then(() => {			if (1 < 2) {				return 'SOMETHING';			}			return 'SOMETHING';		}) : Promise<"ELSE" | "SOMETHING">
 >Promise.resolve().then : <TResult1 = void, TResult2 = never>(onfulfilled?: ((value: void) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>
 >Promise.resolve() : Promise<void>
 >Promise.resolve : { (): Promise<void>; <T>(value: T): Promise<Awaited<T>>; <T>(value: T | PromiseLike<T>): Promise<Awaited<T>>; }