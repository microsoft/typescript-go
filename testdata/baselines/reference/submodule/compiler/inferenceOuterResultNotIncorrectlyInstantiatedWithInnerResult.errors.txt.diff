--- old.inferenceOuterResultNotIncorrectlyInstantiatedWithInnerResult.errors.txt
+++ new.inferenceOuterResultNotIncorrectlyInstantiatedWithInnerResult.errors.txt
@@= skipped -0, +-1 lines =@@
-<no content>
@@= skipped --1, +1 lines =@@
+error TS2318: Cannot find global type 'Array'.
+error TS2318: Cannot find global type 'Function'.
+error TS2318: Cannot find global type 'IArguments'.
+error TS2318: Cannot find global type 'RegExp'.
+error TS2318: Cannot find global type 'String'.
+error TS2552: Cannot find name 'Boolean'. Did you mean 'boolean'?
+error TS2552: Cannot find name 'Number'. Did you mean 'number'?
+error TS2552: Cannot find name 'Object'. Did you mean 'object'?
+inferenceOuterResultNotIncorrectlyInstantiatedWithInnerResult.ts(27,21): error TS2304: Cannot find name 'Omit'.
+inferenceOuterResultNotIncorrectlyInstantiatedWithInnerResult.ts(35,45): error TS2304: Cannot find name 'Object'.
+
+
+!!! error TS2318: Cannot find global type 'Array'.
+!!! error TS2318: Cannot find global type 'Function'.
+!!! error TS2318: Cannot find global type 'IArguments'.
+!!! error TS2318: Cannot find global type 'RegExp'.
+!!! error TS2318: Cannot find global type 'String'.
+!!! error TS2552: Cannot find name 'Boolean'. Did you mean 'boolean'?
+!!! error TS2552: Cannot find name 'Number'. Did you mean 'number'?
+!!! error TS2552: Cannot find name 'Object'. Did you mean 'object'?
+==== inferenceOuterResultNotIncorrectlyInstantiatedWithInnerResult.ts (2 errors) ====
+    // simple example
+    export class Test<A, B> {
+        constructor(public a: A, public b: B) { }
+    
+        test<C>(c: C): Test<B, C> {
+            return new Test(this.b, c);
+        }
+    }
+    
+    // complicated one
+    interface Supervisor<out T> {
+        zip<A>(right: Supervisor<A>): Supervisor<[T, A]>;
+    }
+    
+    export class Zip<out T0, out T1> implements Supervisor<readonly [T0, T1]> {
+        constructor(
+            readonly left: Supervisor<T0>,
+            readonly right: Supervisor<T1>,
+        ) { }
+    
+        zip<A>(right: Supervisor<A>): Supervisor<[[T0, T1], A]> {
+            return new Zip(this, right);
+        }
+    }
+    
+    // indirect
+    type Assign<T, U> = Omit<T, keyof U> & U;
+                        ~~~~
+!!! error TS2304: Cannot find name 'Omit'.
+    
+    class Base<T> {
+        constructor(public t: T) { }
+    }
+    
+    export class Foo<T> extends Base<T> {
+        update(): Foo<Assign<T, { x: number }>> {
+            const v: Assign<T, { x: number }> = Object.assign(this.t, { x: 1 });
+                                                ~~~~~~
+!!! error TS2304: Cannot find name 'Object'.
+            return new Foo(v);
+        }
+    }
