//// [tests/cases/compiler/contravariantOnlyInferenceFromAnnotatedFunctionJs.ts] ////

=== index.js ===
/**
 * @typedef {{ [K in keyof B]: { fn: (a: A, b: B) => void; thing: B[K]; } }} Funcs
>K : Symbol(K, Decl(index.js, 1, 16))
>B : Symbol(B)
>fn : Symbol(fn, Decl(index.js, 1, 32))
>a : Symbol(a, Decl(index.js, 1, 38))
>A : Symbol(A)
>b : Symbol(b, Decl(index.js, 1, 43))
>B : Symbol(B)
>thing : Symbol(thing, Decl(index.js, 1, 58))
>B : Symbol(B)
>K : Symbol(K, Decl(index.js, 1, 16))

 * @template A
 * @template {Record<string, unknown>} B
 */

/**
 * @template A
 * @template {Record<string, unknown>} B
 * @param {Funcs<A, B>} fns
 * @returns {[A, B]}
 */
function foo(fns) {
>foo : Symbol(foo, Decl(index.js, 0, 0))
>fns : Symbol(fns, Decl(index.js, 12, 13))

  return /** @type {any} */ (null);
}

const result = foo({
>result : Symbol(result, Decl(index.js, 16, 5))
>foo : Symbol(foo, Decl(index.js, 0, 0))

  bar: {
>bar : Symbol(bar, Decl(index.js, 16, 20))

    fn:
>fn : Symbol(fn, Decl(index.js, 17, 8))

      /** @param {string} a */
      (a) => {},
>a : Symbol(a, Decl(index.js, 20, 7))

    thing: "asd",
>thing : Symbol(thing, Decl(index.js, 20, 16))

  },
});
