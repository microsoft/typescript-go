--- old.declarationEmitMappedTypePreservesTypeParameterConstraint.types
+++ new.declarationEmitMappedTypePreservesTypeParameterConstraint.types
@@= skipped -80, +80 lines =@@
 >evaluate : { [k in keyof t]: t[k]; }

 export type entryOf<o> = evaluate<
->entryOf : { [k_1 in keyof o]-?: [k_1, o[k_1] & ({} | null)]; }[o extends readonly unknown[] ? keyof o & number : keyof o] extends infer T ? { [k in keyof T]: T[k]; } : never
+>entryOf : { [k in keyof o]-?: [k, o[k] & ({} | null)]; }[o extends readonly unknown[] ? keyof o & number : keyof o] extends infer T ? { [k in keyof T]: T[k]; } : never

     { [k in keyof o]-?: [k, o[k] & ({} | null)] }[o extends readonly unknown[]
         ? keyof o & number
@@= skipped -8, +8 lines =@@
 >

 export type entriesOf<o extends object> = evaluate<entryOf<o>[]>
->entriesOf : ({ [k_1 in keyof o]-?: [k_1, o[k_1] & ({} | null)]; }[o extends readonly unknown[] ? keyof o & number : keyof o] extends infer T ? { [k in keyof T]: T[k]; } : never)[]
+>entriesOf : ({ [k in keyof o]-?: [k, o[k] & ({} | null)]; }[o extends readonly unknown[] ? keyof o & number : keyof o] extends infer T ? { [k in keyof T]: T[k]; } : never)[]

 export const entriesOf = <o extends object>(o: o) =>
 >entriesOf : <o extends object>(o: o) => entriesOf<o>
@@= skipped -8, +8 lines =@@
 >o : o

     Object.entries(o) as entriesOf<o>
->Object.entries(o) as entriesOf<o> : ({ [k_1 in keyof o]-?: [k_1, o[k_1] & ({} | null)]; }[o extends readonly unknown[] ? keyof o & number : keyof o] extends infer T ? { [k in keyof T]: T[k]; } : never)[]
+>Object.entries(o) as entriesOf<o> : ({ [k in keyof o]-?: [k, o[k] & ({} | null)]; }[o extends readonly unknown[] ? keyof o & number : keyof o] extends infer T ? { [k in keyof T]: T[k]; } : never)[]
 >Object.entries(o) : [string, any][]
 >Object.entries : { <T>(o: { [s: string]: T; } | ArrayLike<T>): [string, T][]; (o: {}): [string, any][]; }
 >Object : ObjectConstructor