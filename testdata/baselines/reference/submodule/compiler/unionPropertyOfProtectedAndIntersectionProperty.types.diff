--- old.unionPropertyOfProtectedAndIntersectionProperty.types
+++ new.unionPropertyOfProtectedAndIntersectionProperty.types
@@= skipped -2, +2 lines =@@
 === unionPropertyOfProtectedAndIntersectionProperty.ts ===
 class Foo {
 >Foo : Foo
->    : ^^^
 
   protected foo = 0;
 >foo : number
->    : ^^^^^^
 >0 : 0
->  : ^
 }
 
 class Bar {
 >Bar : Bar
->    : ^^^
 
   protected foo = 0;
 >foo : number
->    : ^^^^^^
 >0 : 0
->  : ^
 }
 
 type Nothing<V extends Foo> = void;
 >Nothing : void
->        : ^^^^
+>V : V
 
 type Broken<V extends Array<Foo | Bar>> = {
 >Broken : Broken<V>
->       : ^^^^^^^^^
+>V : V
 
   readonly [P in keyof V]: V[P] extends Foo ? Nothing<V[P]> : never;
+>P : P
+
 };
 
 // The issue above, #49517, is fixed very indirectly. Here's some code
@@= skipped -36, +32 lines =@@
 
 type _3 = (Foo & Bar)['foo'];         // Ok
 >_3 : number
->   : ^^^^^^
 
 type _4 = (Foo | Bar)['foo'];         // Error
 >_4 : any
->   : ^^^
 
 type _5 = (Foo | (Foo & Bar))['foo']; // Prev error, now ok
 >_5 : number
->   : ^^^^^^
 
 // V[P] in `Nothing<V[P]>` is the substitution type `V[P] & Foo`. When
 // checking if that's assignable to `Foo` in the constraint of `Nothing`,
