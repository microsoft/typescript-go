--- old.coAndContraVariantInferences3.symbols
+++ new.coAndContraVariantInferences3.symbols
@@= skipped -4, +4 lines =@@
 >DeprecationOptions : Symbol(DeprecationOptions, Decl(coAndContraVariantInferences3.ts, 0, 0))
 
     message?: string;
->message : Symbol(DeprecationOptions.message, Decl(coAndContraVariantInferences3.ts, 0, 30))
+>message : Symbol(message, Decl(coAndContraVariantInferences3.ts, 0, 30))
 
     error?: boolean;
->error : Symbol(DeprecationOptions.error, Decl(coAndContraVariantInferences3.ts, 1, 21))
+>error : Symbol(error, Decl(coAndContraVariantInferences3.ts, 1, 21))
 
     name?: string;
->name : Symbol(DeprecationOptions.name, Decl(coAndContraVariantInferences3.ts, 2, 20))
+>name : Symbol(name, Decl(coAndContraVariantInferences3.ts, 2, 20))
 }
 
 type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
@@= skipped -115, +115 lines =@@
 >OverloadBuilder : Symbol(OverloadBuilder, Decl(coAndContraVariantInferences3.ts, 24, 122))
 
     overload<T extends OverloadDefinitions>(overloads: T): BindableOverloadBuilder<T>;
->overload : Symbol(OverloadBuilder.overload, Decl(coAndContraVariantInferences3.ts, 26, 27))
+>overload : Symbol(overload, Decl(coAndContraVariantInferences3.ts, 26, 27))
 >T : Symbol(T, Decl(coAndContraVariantInferences3.ts, 27, 13))
 >OverloadDefinitions : Symbol(OverloadDefinitions, Decl(coAndContraVariantInferences3.ts, 6, 114))
 >overloads : Symbol(overloads, Decl(coAndContraVariantInferences3.ts, 27, 44))
@@= skipped -15, +15 lines =@@
 >OverloadDefinitions : Symbol(OverloadDefinitions, Decl(coAndContraVariantInferences3.ts, 6, 114))
 
     bind(binder: OverloadBinders<T>): BoundOverloadBuilder<T>;
->bind : Symbol(BindableOverloadBuilder.bind, Decl(coAndContraVariantInferences3.ts, 30, 66))
+>bind : Symbol(bind, Decl(coAndContraVariantInferences3.ts, 30, 66))
 >binder : Symbol(binder, Decl(coAndContraVariantInferences3.ts, 31, 9))
 >OverloadBinders : Symbol(OverloadBinders, Decl(coAndContraVariantInferences3.ts, 16, 87))
 >T : Symbol(T, Decl(coAndContraVariantInferences3.ts, 30, 34))
@@= skipped -14, +14 lines =@@
 >OverloadDefinitions : Symbol(OverloadDefinitions, Decl(coAndContraVariantInferences3.ts, 6, 114))
 
     finish(): OverloadFunction<T>;
->finish : Symbol(FinishableOverloadBuilder.finish, Decl(coAndContraVariantInferences3.ts, 34, 68))
+>finish : Symbol(finish, Decl(coAndContraVariantInferences3.ts, 34, 68))
 >OverloadFunction : Symbol(OverloadFunction, Decl(coAndContraVariantInferences3.ts, 14, 120))
 >T : Symbol(T, Decl(coAndContraVariantInferences3.ts, 34, 36))
 }
@@= skipped -13, +13 lines =@@
 >T : Symbol(T, Decl(coAndContraVariantInferences3.ts, 38, 31))
 
     deprecate(deprecations: OverloadDeprecations<T>): FinishableOverloadBuilder<T>;
->deprecate : Symbol(BoundOverloadBuilder.deprecate, Decl(coAndContraVariantInferences3.ts, 38, 100))
+>deprecate : Symbol(deprecate, Decl(coAndContraVariantInferences3.ts, 38, 100))
 >deprecations : Symbol(deprecations, Decl(coAndContraVariantInferences3.ts, 39, 14))
 >OverloadDeprecations : Symbol(OverloadDeprecations, Decl(coAndContraVariantInferences3.ts, 18, 136))
 >T : Symbol(T, Decl(coAndContraVariantInferences3.ts, 38, 31))
@@= skipped -17, +17 lines =@@
 >SyntaxKind : Symbol(SyntaxKind, Decl(coAndContraVariantInferences3.ts, 42, 62))
 
     ImportDeclaration,
->ImportDeclaration : Symbol(SyntaxKind.ImportDeclaration, Decl(coAndContraVariantInferences3.ts, 44, 23))
+>ImportDeclaration : Symbol(ImportDeclaration, Decl(coAndContraVariantInferences3.ts, 44, 23))
 
     Modifier,
->Modifier : Symbol(SyntaxKind.Modifier, Decl(coAndContraVariantInferences3.ts, 45, 22))
+>Modifier : Symbol(Modifier, Decl(coAndContraVariantInferences3.ts, 45, 22))
 
     ImportClause,
->ImportClause : Symbol(SyntaxKind.ImportClause, Decl(coAndContraVariantInferences3.ts, 46, 13))
+>ImportClause : Symbol(ImportClause, Decl(coAndContraVariantInferences3.ts, 46, 13))
 
     AssertClause,
->AssertClause : Symbol(SyntaxKind.AssertClause, Decl(coAndContraVariantInferences3.ts, 47, 17))
+>AssertClause : Symbol(AssertClause, Decl(coAndContraVariantInferences3.ts, 47, 17))
 
     Decorator
->Decorator : Symbol(SyntaxKind.Decorator, Decl(coAndContraVariantInferences3.ts, 48, 17))
+>Decorator : Symbol(Decorator, Decl(coAndContraVariantInferences3.ts, 48, 17))
 }
 
 interface Node {
 >Node : Symbol(Node, Decl(lib.dom.d.ts, --, --), Decl(lib.dom.d.ts, --, --), Decl(coAndContraVariantInferences3.ts, 50, 1))
 
     kind: SyntaxKind;
->kind : Symbol(Node.kind, Decl(coAndContraVariantInferences3.ts, 52, 16))
+>kind : Symbol(kind, Decl(coAndContraVariantInferences3.ts, 52, 16))
 >SyntaxKind : Symbol(SyntaxKind, Decl(coAndContraVariantInferences3.ts, 42, 62))
 }
 
 interface Declaration extends Node { _declarationBrand: any }
 >Declaration : Symbol(Declaration, Decl(coAndContraVariantInferences3.ts, 54, 1))
 >Node : Symbol(Node, Decl(lib.dom.d.ts, --, --), Decl(lib.dom.d.ts, --, --), Decl(coAndContraVariantInferences3.ts, 50, 1))
->_declarationBrand : Symbol(Declaration._declarationBrand, Decl(coAndContraVariantInferences3.ts, 56, 36))
+>_declarationBrand : Symbol(_declarationBrand, Decl(coAndContraVariantInferences3.ts, 56, 36))
 
 interface Statement extends Node { _statementBrand: any };
 >Statement : Symbol(Statement, Decl(coAndContraVariantInferences3.ts, 56, 61))
 >Node : Symbol(Node, Decl(lib.dom.d.ts, --, --), Decl(lib.dom.d.ts, --, --), Decl(coAndContraVariantInferences3.ts, 50, 1))
->_statementBrand : Symbol(Statement._statementBrand, Decl(coAndContraVariantInferences3.ts, 57, 34))
+>_statementBrand : Symbol(_statementBrand, Decl(coAndContraVariantInferences3.ts, 57, 34))
 
 interface Expression extends Node { _expressionBrand: any; }
 >Expression : Symbol(Expression, Decl(coAndContraVariantInferences3.ts, 57, 58))
 >Node : Symbol(Node, Decl(lib.dom.d.ts, --, --), Decl(lib.dom.d.ts, --, --), Decl(coAndContraVariantInferences3.ts, 50, 1))
->_expressionBrand : Symbol(Expression._expressionBrand, Decl(coAndContraVariantInferences3.ts, 58, 35))
+>_expressionBrand : Symbol(_expressionBrand, Decl(coAndContraVariantInferences3.ts, 58, 35))
 
 interface ImportDeclaration extends Statement { kind: SyntaxKind.ImportDeclaration; }
 >ImportDeclaration : Symbol(ImportDeclaration, Decl(coAndContraVariantInferences3.ts, 58, 60))
 >Statement : Symbol(Statement, Decl(coAndContraVariantInferences3.ts, 56, 61))
->kind : Symbol(ImportDeclaration.kind, Decl(coAndContraVariantInferences3.ts, 60, 47))
+>kind : Symbol(kind, Decl(coAndContraVariantInferences3.ts, 60, 47))
 >SyntaxKind : Symbol(SyntaxKind, Decl(coAndContraVariantInferences3.ts, 42, 62))
->ImportDeclaration : Symbol(SyntaxKind.ImportDeclaration, Decl(coAndContraVariantInferences3.ts, 44, 23))
+>ImportDeclaration : Symbol(ImportDeclaration, Decl(coAndContraVariantInferences3.ts, 44, 23))
 
 interface Modifier extends Node { kind: SyntaxKind.Modifier; }
 >Modifier : Symbol(Modifier, Decl(coAndContraVariantInferences3.ts, 60, 85))
 >Node : Symbol(Node, Decl(lib.dom.d.ts, --, --), Decl(lib.dom.d.ts, --, --), Decl(coAndContraVariantInferences3.ts, 50, 1))
->kind : Symbol(Modifier.kind, Decl(coAndContraVariantInferences3.ts, 61, 33))
+>kind : Symbol(kind, Decl(coAndContraVariantInferences3.ts, 61, 33))
 >SyntaxKind : Symbol(SyntaxKind, Decl(coAndContraVariantInferences3.ts, 42, 62))
->Modifier : Symbol(SyntaxKind.Modifier, Decl(coAndContraVariantInferences3.ts, 45, 22))
+>Modifier : Symbol(Modifier, Decl(coAndContraVariantInferences3.ts, 45, 22))
 
 interface Decorator extends Node { kind: SyntaxKind.Decorator; }
 >Decorator : Symbol(Decorator, Decl(coAndContraVariantInferences3.ts, 61, 62))
 >Node : Symbol(Node, Decl(lib.dom.d.ts, --, --), Decl(lib.dom.d.ts, --, --), Decl(coAndContraVariantInferences3.ts, 50, 1))
->kind : Symbol(Decorator.kind, Decl(coAndContraVariantInferences3.ts, 62, 34))
+>kind : Symbol(kind, Decl(coAndContraVariantInferences3.ts, 62, 34))
 >SyntaxKind : Symbol(SyntaxKind, Decl(coAndContraVariantInferences3.ts, 42, 62))
->Decorator : Symbol(SyntaxKind.Decorator, Decl(coAndContraVariantInferences3.ts, 48, 17))
+>Decorator : Symbol(Decorator, Decl(coAndContraVariantInferences3.ts, 48, 17))
 
 interface ImportClause extends Declaration { kind: SyntaxKind.ImportClause; }
 >ImportClause : Symbol(ImportClause, Decl(coAndContraVariantInferences3.ts, 62, 64))
 >Declaration : Symbol(Declaration, Decl(coAndContraVariantInferences3.ts, 54, 1))
->kind : Symbol(ImportClause.kind, Decl(coAndContraVariantInferences3.ts, 63, 44))
+>kind : Symbol(kind, Decl(coAndContraVariantInferences3.ts, 63, 44))
 >SyntaxKind : Symbol(SyntaxKind, Decl(coAndContraVariantInferences3.ts, 42, 62))
->ImportClause : Symbol(SyntaxKind.ImportClause, Decl(coAndContraVariantInferences3.ts, 46, 13))
+>ImportClause : Symbol(ImportClause, Decl(coAndContraVariantInferences3.ts, 46, 13))
 
 interface AssertClause extends Node { kind: SyntaxKind.AssertClause; }
 >AssertClause : Symbol(AssertClause, Decl(coAndContraVariantInferences3.ts, 63, 77))
 >Node : Symbol(Node, Decl(lib.dom.d.ts, --, --), Decl(lib.dom.d.ts, --, --), Decl(coAndContraVariantInferences3.ts, 50, 1))
->kind : Symbol(AssertClause.kind, Decl(coAndContraVariantInferences3.ts, 64, 37))
+>kind : Symbol(kind, Decl(coAndContraVariantInferences3.ts, 64, 37))
 >SyntaxKind : Symbol(SyntaxKind, Decl(coAndContraVariantInferences3.ts, 42, 62))
->AssertClause : Symbol(SyntaxKind.AssertClause, Decl(coAndContraVariantInferences3.ts, 47, 17))
+>AssertClause : Symbol(AssertClause, Decl(coAndContraVariantInferences3.ts, 47, 17))
 
 declare function isExpression(node: Node): node is Expression;
 >isExpression : Symbol(isExpression, Decl(coAndContraVariantInferences3.ts, 64, 70))
@@= skipped -192, +192 lines =@@
 >DeprecationOptions : Symbol(DeprecationOptions, Decl(coAndContraVariantInferences3.ts, 0, 0))
 
 buildOverload("updateImportDeclaration")
->buildOverload("updateImportDeclaration")    .overload({        0(node: ImportDeclaration, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {            return updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause);        },        1(node: ImportDeclaration, _decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {            return updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause);        },    })    .bind({        0: ([, modifiers, importClause, moduleSpecifier, assertClause, other]) =>            (other === undefined) &&            (modifiers === undefined || every(modifiers, isModifier)) &&            (importClause === undefined || !isArray(importClause)) &&            (moduleSpecifier === undefined || isExpression(moduleSpecifier)) &&            (assertClause === undefined || isAssertClause(assertClause)),        1: ([, decorators, modifiers, importClause, moduleSpecifier, assertClause]) =>            (decorators === undefined || every(decorators, isDecorator)) &&            (modifiers === undefined || isArray(modifiers)) &&            (importClause === undefined || isImportClause(importClause)) &&            (moduleSpecifier !== undefined && isExpression(moduleSpecifier)) &&            (assertClause === undefined || isAssertClause(assertClause)),    })    .deprecate({        1: DISALLOW_DECORATORS    })    .finish : Symbol(FinishableOverloadBuilder.finish, Decl(coAndContraVariantInferences3.ts, 34, 68))
->buildOverload("updateImportDeclaration")    .overload({        0(node: ImportDeclaration, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {            return updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause);        },        1(node: ImportDeclaration, _decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {            return updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause);        },    })    .bind({        0: ([, modifiers, importClause, moduleSpecifier, assertClause, other]) =>            (other === undefined) &&            (modifiers === undefined || every(modifiers, isModifier)) &&            (importClause === undefined || !isArray(importClause)) &&            (moduleSpecifier === undefined || isExpression(moduleSpecifier)) &&            (assertClause === undefined || isAssertClause(assertClause)),        1: ([, decorators, modifiers, importClause, moduleSpecifier, assertClause]) =>            (decorators === undefined || every(decorators, isDecorator)) &&            (modifiers === undefined || isArray(modifiers)) &&            (importClause === undefined || isImportClause(importClause)) &&            (moduleSpecifier !== undefined && isExpression(moduleSpecifier)) &&            (assertClause === undefined || isAssertClause(assertClause)),    })    .deprecate : Symbol(BoundOverloadBuilder.deprecate, Decl(coAndContraVariantInferences3.ts, 38, 100))
->buildOverload("updateImportDeclaration")    .overload({        0(node: ImportDeclaration, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {            return updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause);        },        1(node: ImportDeclaration, _decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {            return updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause);        },    })    .bind : Symbol(BindableOverloadBuilder.bind, Decl(coAndContraVariantInferences3.ts, 30, 66))
->buildOverload("updateImportDeclaration")    .overload : Symbol(OverloadBuilder.overload, Decl(coAndContraVariantInferences3.ts, 26, 27))
+>buildOverload("updateImportDeclaration")    .overload({        0(node: ImportDeclaration, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {            return updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause);        },        1(node: ImportDeclaration, _decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {            return updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause);        },    })    .bind({        0: ([, modifiers, importClause, moduleSpecifier, assertClause, other]) =>            (other === undefined) &&            (modifiers === undefined || every(modifiers, isModifier)) &&            (importClause === undefined || !isArray(importClause)) &&            (moduleSpecifier === undefined || isExpression(moduleSpecifier)) &&            (assertClause === undefined || isAssertClause(assertClause)),        1: ([, decorators, modifiers, importClause, moduleSpecifier, assertClause]) =>            (decorators === undefined || every(decorators, isDecorator)) &&            (modifiers === undefined || isArray(modifiers)) &&            (importClause === undefined || isImportClause(importClause)) &&            (moduleSpecifier !== undefined && isExpression(moduleSpecifier)) &&            (assertClause === undefined || isAssertClause(assertClause)),    })    .deprecate({        1: DISALLOW_DECORATORS    })    .finish : Symbol(finish, Decl(coAndContraVariantInferences3.ts, 34, 68))
+>buildOverload("updateImportDeclaration")    .overload({        0(node: ImportDeclaration, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {            return updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause);        },        1(node: ImportDeclaration, _decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {            return updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause);        },    })    .bind({        0: ([, modifiers, importClause, moduleSpecifier, assertClause, other]) =>            (other === undefined) &&            (modifiers === undefined || every(modifiers, isModifier)) &&            (importClause === undefined || !isArray(importClause)) &&            (moduleSpecifier === undefined || isExpression(moduleSpecifier)) &&            (assertClause === undefined || isAssertClause(assertClause)),        1: ([, decorators, modifiers, importClause, moduleSpecifier, assertClause]) =>            (decorators === undefined || every(decorators, isDecorator)) &&            (modifiers === undefined || isArray(modifiers)) &&            (importClause === undefined || isImportClause(importClause)) &&            (moduleSpecifier !== undefined && isExpression(moduleSpecifier)) &&            (assertClause === undefined || isAssertClause(assertClause)),    })    .deprecate : Symbol(deprecate, Decl(coAndContraVariantInferences3.ts, 38, 100))
+>buildOverload("updateImportDeclaration")    .overload({        0(node: ImportDeclaration, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {            return updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause);        },        1(node: ImportDeclaration, _decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {            return updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause);        },    })    .bind : Symbol(bind, Decl(coAndContraVariantInferences3.ts, 30, 66))
+>buildOverload("updateImportDeclaration")    .overload : Symbol(overload, Decl(coAndContraVariantInferences3.ts, 26, 27))
 >buildOverload : Symbol(buildOverload, Decl(coAndContraVariantInferences3.ts, 40, 1))
 
     .overload({
->overload : Symbol(OverloadBuilder.overload, Decl(coAndContraVariantInferences3.ts, 26, 27))
+>overload : Symbol(overload, Decl(coAndContraVariantInferences3.ts, 26, 27))
 
         0(node: ImportDeclaration, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration {
 >0 : Symbol(0, Decl(coAndContraVariantInferences3.ts, 86, 15))
@@= skipped -60, +60 lines =@@
         },
     })
     .bind({
->bind : Symbol(BindableOverloadBuilder.bind, Decl(coAndContraVariantInferences3.ts, 30, 66))
+>bind : Symbol(bind, Decl(coAndContraVariantInferences3.ts, 30, 66))
 
         0: ([, modifiers, importClause, moduleSpecifier, assertClause, other]) =>
 >0 : Symbol(0, Decl(coAndContraVariantInferences3.ts, 95, 11))
@@= skipped -80, +80 lines =@@
 
     })
     .deprecate({
->deprecate : Symbol(BoundOverloadBuilder.deprecate, Decl(coAndContraVariantInferences3.ts, 38, 100))
+>deprecate : Symbol(deprecate, Decl(coAndContraVariantInferences3.ts, 38, 100))
 
         1: DISALLOW_DECORATORS
 >1 : Symbol(1, Decl(coAndContraVariantInferences3.ts, 110, 16))
@@= skipped -8, +8 lines =@@
 
     })
     .finish();
->finish : Symbol(FinishableOverloadBuilder.finish, Decl(coAndContraVariantInferences3.ts, 34, 68))
+>finish : Symbol(finish, Decl(coAndContraVariantInferences3.ts, 34, 68))
 
 
 declare const modifiers: readonly Modifier[] | readonly Decorator[];
