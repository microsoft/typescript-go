--- old.reverseMappedPartiallyInferableTypes.types
+++ new.reverseMappedPartiallyInferableTypes.types
@@= skipped -56, +56 lines =@@
 }

 const r = extend({
->r : RecordPropsDefinition<{ notResolved: MyType; explicit: MyType; }>
->extend({    props: {        notResolved: {            type: Object as PropType<MyType>,            validator: x => {                return x.valid;            }        },        explicit: {            type: Object as PropType<MyType>,            validator: (x: MyType) => {                return x.valid;            }        }    }}) : RecordPropsDefinition<{ notResolved: MyType; explicit: MyType; }>
+>r : RecordPropsDefinition<{ notResolved: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; explicit: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; }>
+>extend({    props: {        notResolved: {            type: Object as PropType<MyType>,            validator: x => {                return x.valid;            }        },        explicit: {            type: Object as PropType<MyType>,            validator: (x: MyType) => {                return x.valid;            }        }    }}) : RecordPropsDefinition<{ notResolved: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; explicit: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; }>
 >extend : <T>({ props }: { props: PropsDefinition<T>; }) => PropsDefinition<T>
 >{    props: {        notResolved: {            type: Object as PropType<MyType>,            validator: x => {                return x.valid;            }        },        explicit: {            type: Object as PropType<MyType>,            validator: (x: MyType) => {                return x.valid;            }        }    }} : { props: { notResolved: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; explicit: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; }; }

@@= skipped -54, +54 lines =@@

 r.explicit
 >r.explicit : PropValidator<MyType>
->r : RecordPropsDefinition<{ notResolved: MyType; explicit: MyType; }>
+>r : RecordPropsDefinition<{ notResolved: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; explicit: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; }>
 >explicit : PropValidator<MyType>

 r.notResolved
 >r.notResolved : PropValidator<MyType>
->r : RecordPropsDefinition<{ notResolved: MyType; explicit: MyType; }>
+>r : RecordPropsDefinition<{ notResolved: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; explicit: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; }>
 >notResolved : PropValidator<MyType>

 r.explicit.required
 >r.explicit.required : boolean | undefined
 >r.explicit : PropValidator<MyType>
->r : RecordPropsDefinition<{ notResolved: MyType; explicit: MyType; }>
+>r : RecordPropsDefinition<{ notResolved: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; explicit: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; }>
 >explicit : PropValidator<MyType>
 >required : boolean | undefined

 r.notResolved.required
 >r.notResolved.required : boolean | undefined
 >r.notResolved : PropValidator<MyType>
->r : RecordPropsDefinition<{ notResolved: MyType; explicit: MyType; }>
+>r : RecordPropsDefinition<{ notResolved: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; explicit: { type: PropType<MyType>; validator: (x: MyType) => boolean; }; }>
 >notResolved : PropValidator<MyType>
 >required : boolean | undefined

@@= skipped -49, +49 lines =@@
 // All properties have inferable types

 const obj1 = id({
->obj1 : Mapped<{ foo: string; }>
->id({    foo: {        contents: ""    }}) : Mapped<{ foo: string; }>
+>obj1 : Mapped<{ foo: { contents: string; }; }>
+>id({    foo: {        contents: ""    }}) : Mapped<{ foo: { contents: string; }; }>
 >id : <T>(arg: Mapped<T>) => Mapped<T>
 >{    foo: {        contents: ""    }} : { foo: { contents: string; }; }

@@= skipped -18, +18 lines =@@
 // Some properties have inferable types

 const obj2 = id({
->obj2 : Mapped<{ foo: string; }>
->id({    foo: {        contents: "",        contains(k) {            return k.length > 0;        }    }}) : Mapped<{ foo: string; }>
+>obj2 : Mapped<{ foo: { contents: string; contains(k: string): boolean; }; }>
+>id({    foo: {        contents: "",        contains(k) {            return k.length > 0;        }    }}) : Mapped<{ foo: { contents: string; contains(k: string): boolean; }; }>
 >id : <T>(arg: Mapped<T>) => Mapped<T>
 >{    foo: {        contents: "",        contains(k) {            return k.length > 0;        }    }} : { foo: { contents: string; contains(k: string): boolean; }; }
