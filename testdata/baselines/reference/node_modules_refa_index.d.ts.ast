SourceFile
  ImportDeclaration
    ImportClause
      NamedImports
        ImportSpecifier
          Identifier: ' AST'
        ImportSpecifier
          Identifier: ' RegExpParser'
    StringLiteral
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' SourceLocation'
    PropertySignature
      Identifier: '
	start'
      NumberKeyword
    PropertySignature
      Identifier: '
	end'
      NumberKeyword
  InterfaceDeclaration
    Identifier: ' NodeBase'
    PropertySignature
      Identifier: '
	type'
      IndexedAccessType
        TypeReference
          Identifier: ' Node'
        LiteralType
          StringLiteral
    PropertySignature
      Identifier: '
	parent'
      IndexedAccessType
        TypeReference
          Identifier: ' Node'
        LiteralType
          StringLiteral
    PropertySignature
      Identifier: '
	source'
      QuestionToken
      TypeReference
        Identifier: ' SourceLocation'
  TypeAliasDeclaration
    ExportKeyword
    Identifier: ' Element'
    UnionType
      TypeReference
        Identifier: ' CharacterClass'
      TypeReference
        Identifier: ' Alternation'
      TypeReference
        Identifier: ' Quantifier'
      TypeReference
        Identifier: ' Assertion'
      TypeReference
        Identifier: ' Unknown'
  TypeAliasDeclaration
    ExportKeyword
    Identifier: ' Parent'
    UnionType
      TypeReference
        Identifier: ' Expression'
      TypeReference
        Identifier: ' Alternation'
      TypeReference
        Identifier: ' Quantifier'
      TypeReference
        Identifier: ' Assertion'
  TypeAliasDeclaration
    ExportKeyword
    Identifier: ' Node'
    UnionType
      TypeReference
        Identifier: ' Expression'
      TypeReference
        Identifier: ' CharacterClass'
      TypeReference
        Identifier: ' Alternation'
      TypeReference
        Identifier: ' Quantifier'
      TypeReference
        Identifier: ' Assertion'
      TypeReference
        Identifier: ' Concatenation'
      TypeReference
        Identifier: ' Unknown'
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' Alternation'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' NodeBase'
    PropertySignature
      Identifier: '
	type'
      LiteralType
        StringLiteral
    PropertySignature
      Identifier: '
	parent'
      TypeReference
        Identifier: ' Concatenation'
    PropertySignature
      Identifier: '
	alternatives'
      ArrayType
        TypeReference
          Identifier: ' Concatenation'
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' Assertion'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' NodeBase'
    PropertySignature
      Identifier: '
	type'
      LiteralType
        StringLiteral
    PropertySignature
      Identifier: '
	parent'
      TypeReference
        Identifier: ' Concatenation'
    PropertySignature
      Identifier: '
	alternatives'
      ArrayType
        TypeReference
          Identifier: ' Concatenation'
    PropertySignature
      Identifier: '
	kind'
      UnionType
        LiteralType
          StringLiteral
        LiteralType
          StringLiteral
    PropertySignature
      Identifier: '
	negate'
      BooleanKeyword
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' Quantifier'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' NodeBase'
    PropertySignature
      Identifier: '
	type'
      LiteralType
        StringLiteral
    PropertySignature
      Identifier: '
	parent'
      TypeReference
        Identifier: ' Concatenation'
    PropertySignature
      Identifier: '
	alternatives'
      ArrayType
        TypeReference
          Identifier: ' Concatenation'
    PropertySignature
      Identifier: '
	lazy'
      BooleanKeyword
    PropertySignature
      Identifier: '
	min'
      NumberKeyword
    PropertySignature
      Identifier: '
	max'
      NumberKeyword
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' CharacterClass'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' NodeBase'
    PropertySignature
      Identifier: '
	type'
      LiteralType
        StringLiteral
    PropertySignature
      Identifier: '
	parent'
      TypeReference
        Identifier: ' Concatenation'
    PropertySignature
      Identifier: '
	characters'
      TypeReference
        Identifier: ' CharSet'
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' Unknown'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' NodeBase'
    PropertySignature
      Identifier: '
	type'
      LiteralType
        StringLiteral
    PropertySignature
      Identifier: '
	parent'
      TypeReference
        Identifier: ' Concatenation'
    PropertySignature
      Identifier: '
	id'
      StringKeyword
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' Expression'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' NodeBase'
    PropertySignature
      Identifier: '
	type'
      LiteralType
        StringLiteral
    PropertySignature
      Identifier: '
	parent'
      LiteralType
        NullKeyword
    PropertySignature
      Identifier: '
	alternatives'
      ArrayType
        TypeReference
          Identifier: ' Concatenation'
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' Concatenation'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' NodeBase'
    PropertySignature
      Identifier: '
	type'
      LiteralType
        StringLiteral
    PropertySignature
      Identifier: '
	parent'
      TypeReference
        Identifier: ' Parent'
    PropertySignature
      Identifier: '
	elements'
      ArrayType
        TypeReference
          Identifier: ' Element'
  TypeAliasDeclaration
    Identifier: ' NodeIdent'
    TypeLiteral
      PropertySignature
        Identifier: '
	type'
        IndexedAccessType
          TypeReference
            Identifier: ' Node'
          LiteralType
            StringLiteral
  TypeAliasDeclaration
    Identifier: ' NoParentArray'
    TypeParameter
      Identifier: 'T'
    MappedType
      TypeParameter
        Identifier: 'K'
        TypeOperator
          TypeReference
            Identifier: ' T'
      TypeReference
        Identifier: ' NoParent'
        IndexedAccessType
          TypeReference
            Identifier: 'T'
          TypeReference
            Identifier: 'K'
  TypeAliasDeclaration
    Identifier: ' NoParentNode'
    TypeParameter
      Identifier: 'T'
      TypeReference
        Identifier: ' NodeIdent'
    MappedType
      TypeParameter
        Identifier: 'K'
        TypeOperator
          TypeReference
            Identifier: ' NoParentNodePick'
            TypeReference
              Identifier: 'T'
      TypeReference
        Identifier: ' NoParent'
        IndexedAccessType
          TypeReference
            Identifier: 'NoParentNodePick'
            TypeReference
              Identifier: 'T'
          TypeReference
            Identifier: 'K'
  TypeAliasDeclaration
    Identifier: ' NoParentNodePick'
    TypeParameter
      Identifier: 'T'
      TypeReference
        Identifier: ' NodeIdent'
    TypeReference
      Identifier: ' Pick'
      TypeReference
        Identifier: 'T'
      TypeReference
        Identifier: ' Exclude'
        TypeOperator
          TypeReference
            Identifier: ' T'
        LiteralType
          StringLiteral
  TypeAliasDeclaration
    ExportKeyword
    Identifier: ' NoParent'
    TypeParameter
      Identifier: 'T'
    ConditionalType
      TypeReference
        Identifier: ' T'
      TypeReference
        Identifier: ' NodeIdent'
      TypeReference
        Identifier: ' NoParentNode'
        TypeReference
          Identifier: 'T'
      ConditionalType
        TypeReference
          Identifier: ' T'
        ArrayType
          UnknownKeyword
        TypeReference
          Identifier: ' NoParentArray'
          TypeReference
            Identifier: 'T'
        TypeReference
          Identifier: ' T'
  FunctionDeclaration
    ExportKeyword
    Identifier: ' setParent'
    TypeParameter
      Identifier: 'T'
      TypeReference
        Identifier: ' Node'
    Parameter
      Identifier: 'node'
      UnionType
        TypeReference
          Identifier: ' T'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'T'
    Parameter
      Identifier: ' parent'
      IndexedAccessType
        TypeReference
          Identifier: ' T'
        LiteralType
          StringLiteral
    TypePredicate
      AssertsKeyword
      Identifier: ' node'
      TypeReference
        Identifier: ' T'
  FunctionDeclaration
    ExportKeyword
    Identifier: ' setSource'
    Parameter
      Identifier: '
	node'
      TypeReference
        Identifier: ' NoParent'
        TypeReference
          Identifier: 'Node'
    Parameter
      Identifier: '
	source'
      UnionType
        TypeReference
          Identifier: ' SourceLocation'
        ParenthesizedType
          FunctionType
            TypeReference
              Identifier: ' SourceLocation'
    Parameter
      Identifier: '
	overwrite'
      QuestionToken
      BooleanKeyword
    VoidKeyword
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' VisitAstHandler'
    MethodSignature
      Identifier: '
	onAlternationEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' Alternation'
      VoidKeyword
    MethodSignature
      Identifier: '
	onAlternationLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' Alternation'
      VoidKeyword
    MethodSignature
      Identifier: '
	onAssertionEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' Assertion'
      VoidKeyword
    MethodSignature
      Identifier: '
	onAssertionLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' Assertion'
      VoidKeyword
    MethodSignature
      Identifier: '
	onCharacterClassEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' CharacterClass'
      VoidKeyword
    MethodSignature
      Identifier: '
	onCharacterClassLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' CharacterClass'
      VoidKeyword
    MethodSignature
      Identifier: '
	onConcatenationEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' Concatenation'
      VoidKeyword
    MethodSignature
      Identifier: '
	onConcatenationLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' Concatenation'
      VoidKeyword
    MethodSignature
      Identifier: '
	onExpressionEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' Expression'
      VoidKeyword
    MethodSignature
      Identifier: '
	onExpressionLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' Expression'
      VoidKeyword
    MethodSignature
      Identifier: '
	onQuantifierEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' Quantifier'
      VoidKeyword
    MethodSignature
      Identifier: '
	onQuantifierLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' Quantifier'
      VoidKeyword
    MethodSignature
      Identifier: '
	onUnknownEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' Unknown'
      VoidKeyword
    MethodSignature
      Identifier: '
	onUnknownLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' Unknown'
      VoidKeyword
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' VisitNoParentAstHandler'
    MethodSignature
      Identifier: '
	onAlternationEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Alternation'
      VoidKeyword
    MethodSignature
      Identifier: '
	onAlternationLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Alternation'
      VoidKeyword
    MethodSignature
      Identifier: '
	onAssertionEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Assertion'
      VoidKeyword
    MethodSignature
      Identifier: '
	onAssertionLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Assertion'
      VoidKeyword
    MethodSignature
      Identifier: '
	onCharacterClassEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'CharacterClass'
      VoidKeyword
    MethodSignature
      Identifier: '
	onCharacterClassLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'CharacterClass'
      VoidKeyword
    MethodSignature
      Identifier: '
	onConcatenationEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Concatenation'
      VoidKeyword
    MethodSignature
      Identifier: '
	onConcatenationLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Concatenation'
      VoidKeyword
    MethodSignature
      Identifier: '
	onExpressionEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Expression'
      VoidKeyword
    MethodSignature
      Identifier: '
	onExpressionLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Expression'
      VoidKeyword
    MethodSignature
      Identifier: '
	onQuantifierEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Quantifier'
      VoidKeyword
    MethodSignature
      Identifier: '
	onQuantifierLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Quantifier'
      VoidKeyword
    MethodSignature
      Identifier: '
	onUnknownEnter'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Unknown'
      VoidKeyword
    MethodSignature
      Identifier: '
	onUnknownLeave'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Unknown'
      VoidKeyword
  FunctionDeclaration
    ExportKeyword
    Identifier: ' visitAst'
    Parameter
      Identifier: 'node'
      TypeReference
        Identifier: ' Node'
    Parameter
      Identifier: ' visitor'
      TypeReference
        Identifier: ' VisitAstHandler'
    VoidKeyword
  FunctionDeclaration
    ExportKeyword
    Identifier: ' visitAst'
    Parameter
      Identifier: 'node'
      TypeReference
        Identifier: ' NoParent'
        TypeReference
          Identifier: 'Node'
    Parameter
      Identifier: ' visitor'
      TypeReference
        Identifier: ' VisitNoParentAstHandler'
    VoidKeyword
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' Transformer'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' name'
      QuestionToken
      StringKeyword
    MethodSignature
      Identifier: '
	onAlternation'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Alternation'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
    MethodSignature
      Identifier: '
	onAssertion'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Assertion'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
    MethodSignature
      Identifier: '
	onCharacterClass'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'CharacterClass'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
    MethodSignature
      Identifier: '
	onConcatenation'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Concatenation'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
    MethodSignature
      Identifier: '
	onExpression'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Expression'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
    MethodSignature
      Identifier: '
	onQuantifier'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Quantifier'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
    MethodSignature
      Identifier: '
	onUnknown'
      QuestionToken
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Unknown'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' TransformContext'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' maxCharacter'
      TypeReference
        Identifier: ' Char'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' signalMutation'
      FunctionType
        VoidKeyword
  ClassDeclaration
    ExportKeyword
    Identifier: ' CombinedTransformer'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' Transformer'
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' name'
      StringLiteral
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' transformers'
      TypeOperator
        ArrayType
          TypeReference
            Identifier: ' Transformer'
    Constructor
      Parameter
        Identifier: 'transformers'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'Transformer'
    MethodDeclaration
      Identifier: '
	onAlternation'
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Alternation'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	onAssertion'
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Assertion'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	onCharacterClass'
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'CharacterClass'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	onConcatenation'
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Concatenation'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	onExpression'
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Expression'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	onQuantifier'
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Quantifier'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	onUnknown'
      Parameter
        Identifier: 'node'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Unknown'
      Parameter
        Identifier: ' context'
        TypeReference
          Identifier: ' TransformContext'
      VoidKeyword
  FunctionDeclaration
    ExportKeyword
    Identifier: ' combineTransformers'
    Parameter
      Identifier: 'transformers'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'Transformer'
    TypeReference
      Identifier: ' CombinedTransformer'
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' TransformEvents'
    PropertySignature
      Identifier: '
	/**
	 * An optional callback that will be called at the start of every pass.
	 *
	 * @param ast The AST that will be transformed.
	 * @param pass The number of the pass that will be performed. Starts at `1`.
	 */
	onPassStart'
      QuestionToken
      FunctionType
        Parameter
          Identifier: 'ast'
          TypeReference
            Identifier: ' NoParent'
            TypeReference
              Identifier: 'Expression'
        Parameter
          Identifier: ' pass'
          NumberKeyword
        VoidKeyword
    PropertySignature
      Identifier: '
	/**
	 * An optional callback that will be called every time a transformer mutates the AST.
	 *
	 * @param ast The AST that was transformed.
	 * @param node The node that was mutated by the transformer. Descendants of this node may have been mutated as well.
	 * @param transformer The transformer that mutated the AST.
	 */
	onChange'
      QuestionToken
      FunctionType
        Parameter
          Identifier: 'ast'
          TypeReference
            Identifier: ' NoParent'
            TypeReference
              Identifier: 'Expression'
        Parameter
          Identifier: ' node'
          TypeReference
            Identifier: ' NoParent'
            TypeReference
              Identifier: 'Node'
        Parameter
          Identifier: ' transformer'
          TypeReference
            Identifier: ' Transformer'
        VoidKeyword
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' TransformOptions'
    PropertySignature
      Identifier: '
	/**
	 * The maximum number of times the transformer will be applied to the AST.
	 *
	 * This is only a maximum. The transformer will be stopped before this number is reach if the AST isn't modified
	 * anymore.
	 *
	 * @default 10
	 */
	maxPasses'
      QuestionToken
      NumberKeyword
    PropertySignature
      Identifier: '
	/**
	 * Optional events to observe the transformation process.
	 */
	events'
      QuestionToken
      TypeReference
        Identifier: ' TransformEvents'
  FunctionDeclaration
    ExportKeyword
    Identifier: ' transform'
    Parameter
      Identifier: '
	transformer'
      TypeReference
        Identifier: ' Transformer'
    Parameter
      Identifier: '
	ast'
      TypeReference
        Identifier: ' NoParent'
        TypeReference
          Identifier: 'Expression'
    Parameter
      Identifier: '
	options'
      QuestionToken
      TypeReference
        Identifier: ' Readonly'
        TypeReference
          Identifier: 'TransformOptions'
    TypeReference
      Identifier: ' NoParent'
      TypeReference
        Identifier: 'Expression'
  ClassDeclaration
    ExportKeyword
    Identifier: ' CharBase'
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' sets'
      TypeOperator
        ArrayType
          TypeReference
            Identifier: ' CharSet'
    Constructor
      Parameter
        Identifier: 'charSets'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'CharSet'
    MethodDeclaration
      Identifier: '
	/**
	 * Splits the given character set into its base sets.
	 *
	 * The returned array will be a list of indexes of base sets necessary to construct the given character sets. The
	 * indexes will be sorted and occur at most once.
	 *
	 * **Note**: This assumes that `charSet` is either empty or can be constructed from the base sets. If the
	 * assumption is not met, the output of this function will be undefined.
	 *
	 * @param charSet
	 */
	split'
      Parameter
        Identifier: 'charSet'
        TypeReference
          Identifier: ' CharSet'
      ArrayType
        NumberKeyword
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' ReadonlyCharMap'
    TypeParameter
      Identifier: 'T'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' Iterable'
        TupleType
          TypeReference
            Identifier: 'CharRange'
          TypeReference
            Identifier: ' T'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' isEmpty'
      BooleanKeyword
    PropertySignature
      ReadonlyKeyword
      Identifier: ' size'
      NumberKeyword
    PropertySignature
      ReadonlyKeyword
      Identifier: ' entryCount'
      NumberKeyword
    MethodSignature
      Identifier: '
	/**
	 * Returns whether the given character is a key in the map.
	 *
	 * @param char
	 */
	has'
      Parameter
        Identifier: 'char'
        TypeReference
          Identifier: ' Char'
      BooleanKeyword
    MethodSignature
      Identifier: '
	/**
	 * Returns whether every character in the given range is a key in the map.
	 *
	 * This is equivalent to: `[...chars].every(char => this.has(char))`.
	 *
	 * @param chars
	 */
	hasEvery'
      Parameter
        Identifier: 'chars'
        TypeReference
          Identifier: ' CharRange'
      BooleanKeyword
    MethodSignature
      Identifier: '
	/**
	 * Returns whether some character in the given range is a key in the map.
	 *
	 * This is equivalent to: `[...chars].some(char => this.has(char))`.
	 *
	 * @param chars
	 */
	hasSome'
      Parameter
        Identifier: 'chars'
        TypeReference
          Identifier: ' CharRange'
      BooleanKeyword
    MethodSignature
      Identifier: '
	/**
	 * Returns the value associated with the given character of `undefined` if the character is not key in the map.
	 *
	 * @param char
	 */
	get'
      Parameter
        Identifier: 'char'
        TypeReference
          Identifier: ' Char'
      UnionType
        TypeReference
          Identifier: ' T'
        UndefinedKeyword
    MethodSignature
      Identifier: '
	/**
	 * Invokes the given callback for every item of the character map.
	 *
	 * This method is implemented more efficiently than other iterator based methods, so chose `forEach` where every
	 * possible.
	 *
	 * @param callback
	 */
	forEach'
      Parameter
        Identifier: 'callback'
        FunctionType
          Parameter
            Identifier: 'value'
            TypeReference
              Identifier: ' T'
          Parameter
            Identifier: ' chars'
            TypeReference
              Identifier: ' CharRange'
          Parameter
            Identifier: ' map'
            TypeReference
              Identifier: ' ReadonlyCharMap'
              TypeReference
                Identifier: 'T'
          VoidKeyword
      VoidKeyword
    MethodSignature
      Identifier: '
	/**
	 * Returns all ranges of characters that are keys in the map.
	 *
	 * Keys will be returned in the same order as `this.entries()`.
	 */
	keys'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'CharRange'
    MethodSignature
      Identifier: '
	/**
	 * Returns all values in the map. Values might not be unique if more than one range maps to the same value.
	 *
	 * Values will be returned in the same order as `this.entries()`.
	 */
	values'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'T'
    MethodSignature
      Identifier: '
	/**
	 * Returns all key-value pairs in the map.
	 *
	 * Entries will be returned in the order of ascending ranges.
	 */
	entries'
      TypeReference
        Identifier: ' Iterable'
        TupleType
          TypeReference
            Identifier: 'CharRange'
          TypeReference
            Identifier: ' T'
    MethodSignature
      Identifier: '
	/**
	 * Returns a mapping from the values of this map to its keys.
	 */
	invert'
      Parameter
        Identifier: 'maxCharacter'
        TypeReference
          Identifier: ' Char'
      TypeReference
        Identifier: ' Map'
        TypeReference
          Identifier: 'T'
        TypeReference
          Identifier: ' CharSet'
    MethodSignature
      Identifier: '
	/**
	 * Returns a new map with all values mapped by the given function.
	 *
	 * If no function is given, the identity function is used.
	 */
	copy'
      TypeReference
        Identifier: ' CharMap'
        TypeReference
          Identifier: 'T'
    MethodSignature
      Identifier: '
	copy'
      TypeParameter
        Identifier: 'U'
      Parameter
        Identifier: 'mapFn'
        FunctionType
          Parameter
            Identifier: 'value'
            TypeReference
              Identifier: ' T'
          TypeReference
            Identifier: ' U'
      TypeReference
        Identifier: ' CharMap'
        TypeReference
          Identifier: 'U'
  ClassDeclaration
    ExportKeyword
    Identifier: ' CharMap'
    TypeParameter
      Identifier: 'T'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' ReadonlyCharMap'
        TypeReference
          Identifier: 'T'
    GetAccessor
      Identifier: ' isEmpty'
      BooleanKeyword
    GetAccessor
      Identifier: ' size'
      NumberKeyword
    GetAccessor
      Identifier: ' entryCount'
      NumberKeyword
    MethodDeclaration
      Identifier: '
	has'
      Parameter
        Identifier: 'char'
        TypeReference
          Identifier: ' Char'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	hasEvery'
      Parameter
        Identifier: 'chars'
        TypeReference
          Identifier: ' CharRange'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	hasSome'
      Parameter
        Identifier: 'chars'
        TypeReference
          Identifier: ' CharRange'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	get'
      Parameter
        Identifier: 'char'
        TypeReference
          Identifier: ' Char'
      UnionType
        TypeReference
          Identifier: ' T'
        UndefinedKeyword
    MethodDeclaration
      Identifier: '
	set'
      Parameter
        Identifier: 'char'
        TypeReference
          Identifier: ' Char'
      Parameter
        Identifier: ' value'
        TypeReference
          Identifier: ' T'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Sets the value for all characters in the given range.
	 *
	 * This is equivalent to `[...chars].forEach(char => this.set(char, value))`.
	 *
	 * @param chars
	 * @param value
	 */
	setRange'
      Parameter
        Identifier: 'chars'
        TypeReference
          Identifier: ' CharRange'
      Parameter
        Identifier: ' value'
        TypeReference
          Identifier: ' T'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Sets the value for all characters in the given character set.
	 *
	 * This is equivalent to `[...charSet.characters()].forEach(char => this.set(char, value))`.
	 *
	 * @param charSet
	 * @param value
	 */
	setCharSet'
      Parameter
        Identifier: 'charSet'
        TypeReference
          Identifier: ' CharSet'
      Parameter
        Identifier: ' value'
        TypeReference
          Identifier: ' T'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	delete'
      Parameter
        Identifier: 'char'
        TypeReference
          Identifier: ' Char'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Deletes all characters in the given range.
	 *
	 * This is equivalent to `[...range].forEach(char => this.delete(char))`.
	 *
	 * @param range
	 */
	deleteRange'
      Parameter
        Identifier: 'range'
        TypeReference
          Identifier: ' CharRange'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Deletes all entries in the map.
	 */
	clear'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	copy'
      TypeReference
        Identifier: ' CharMap'
        TypeReference
          Identifier: 'T'
    MethodDeclaration
      Identifier: '
	copy'
      TypeParameter
        Identifier: 'U'
      Parameter
        Identifier: 'mapFn'
        FunctionType
          Parameter
            Identifier: 'value'
            TypeReference
              Identifier: ' T'
          TypeReference
            Identifier: ' U'
      TypeReference
        Identifier: ' CharMap'
        TypeReference
          Identifier: 'U'
    MethodDeclaration
      Identifier: '
	map'
      Parameter
        Identifier: 'mapFn'
        FunctionType
          Parameter
            Identifier: 'value'
            TypeReference
              Identifier: ' T'
          Parameter
            Identifier: ' chars'
            TypeReference
              Identifier: ' CharRange'
          Parameter
            Identifier: ' map'
            TypeReference
              Identifier: ' ReadonlyCharMap'
              TypeReference
                Identifier: 'T'
          TypeReference
            Identifier: ' T'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	mapRange'
      Parameter
        Identifier: '
		range'
        TypeReference
          Identifier: ' CharRange'
      Parameter
        Identifier: '
		mapFn'
        FunctionType
          Parameter
            Identifier: 'value'
            UnionType
              TypeReference
                Identifier: ' T'
              UndefinedKeyword
          Parameter
            Identifier: ' chars'
            TypeReference
              Identifier: ' CharRange'
          Parameter
            Identifier: ' map'
            TypeReference
              Identifier: ' ReadonlyCharMap'
              TypeReference
                Identifier: 'T'
          UnionType
            TypeReference
              Identifier: ' T'
            UndefinedKeyword
      VoidKeyword
    MethodDeclaration
      Identifier: '
	filter'
      Parameter
        Identifier: 'conditionFn'
        FunctionType
          Parameter
            Identifier: 'value'
            TypeReference
              Identifier: ' T'
          Parameter
            Identifier: ' chars'
            TypeReference
              Identifier: ' CharRange'
          Parameter
            Identifier: ' map'
            TypeReference
              Identifier: ' ReadonlyCharMap'
              TypeReference
                Identifier: 'T'
          BooleanKeyword
      VoidKeyword
    MethodDeclaration
      Identifier: '
	invert'
      Parameter
        Identifier: 'maxCharacter'
        TypeReference
          Identifier: ' Char'
      TypeReference
        Identifier: ' Map'
        TypeReference
          Identifier: 'T'
        TypeReference
          Identifier: ' CharSet'
    MethodDeclaration
      Identifier: '
	forEach'
      Parameter
        Identifier: 'callback'
        FunctionType
          Parameter
            Identifier: 'value'
            TypeReference
              Identifier: ' T'
          Parameter
            Identifier: ' chars'
            TypeReference
              Identifier: ' CharRange'
          Parameter
            Identifier: ' map'
            TypeReference
              Identifier: ' ReadonlyCharMap'
              TypeReference
                Identifier: 'T'
          VoidKeyword
      VoidKeyword
    MethodDeclaration
      Identifier: '
	keys'
      TypeReference
        Identifier: ' IterableIterator'
        TypeReference
          Identifier: 'CharRange'
    MethodDeclaration
      Identifier: '
	values'
      TypeReference
        Identifier: ' IterableIterator'
        TypeReference
          Identifier: 'T'
    MethodDeclaration
      Identifier: '
	entries'
      TypeReference
        Identifier: ' IterableIterator'
        TupleType
          TypeReference
            Identifier: 'CharRange'
          TypeReference
            Identifier: ' T'
    MethodDeclaration
      ComputedPropertyName
        PropertyAccessExpression
          Identifier: 'Symbol'
          Identifier: 'iterator'
      TypeReference
        Identifier: ' IterableIterator'
        TupleType
          TypeReference
            Identifier: 'CharRange'
          TypeReference
            Identifier: ' T'
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' CharRange'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' min'
      TypeReference
        Identifier: ' Char'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' max'
      TypeReference
        Identifier: ' Char'
  ClassDeclaration
    ExportKeyword
    Identifier: ' CharSet'
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' maximum'
      TypeReference
        Identifier: ' Char'
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' ranges'
      TypeOperator
        ArrayType
          TypeReference
            Identifier: ' CharRange'
    GetAccessor
      Identifier: ' isEmpty'
      BooleanKeyword
    GetAccessor
      Identifier: ' isAll'
      BooleanKeyword
    GetAccessor
      Identifier: ' size'
      NumberKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Returns an iterable of all characters in this set.
	 *
	 * Characters are sorted by ascending order and each character is yielded exactly once.
	 *
	 * Note: The iterable is stable. It can be iterated multiple times.
	 */
	characters'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'Char'
    MethodDeclaration
      Identifier: '
	/**
	 * Returns a string representation of the character set.
	 */
	toString'
      StringKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Returns a string representation of the ranges of this character set.
	 *
	 * The string representation has the following rules:
	 *
	 * 1. Each character is represented as a hexadecimal number.
	 * 2. Each range where `min == max` will be represented by the `min` character.
	 * 3. Each range where `min != max` will be represented by `min` followed by `".."` followed by `max`.
	 * 4. The sequence of ranges will be joined together using `", "`.
	 *
	 * The returned string representation will have the following format:
	 *
	 * ```
	 * string = [ ranges ]
	 * ranges = range *( ", " range )
	 * range  = +hex [ ".." +hex ]
	 * hex    = "a" | "b" | "c" | "d" | "e" | "f" | digit
	 * digit  = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	 * ```
	 */
	toRangesString'
      StringKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Returns a string representation of the Unicode ranges of this character set.
	 *
	 * The primary purpose of this function is provide an easy way to get a readable representation of a Unicode or
	 * Unicode-like character set. The format is optimized for ease of reading for humans.
	 *
	 * The format follows these rules:
	 * - If the character set is empty, `empty` will be returned.
	 * - If the character set contains all characters, `all` will be returned.
	 * - Ranges may be negated, which is indicated with `not`. E.g. `not a b` is the character set that contains all
	 *   characters except for a and b.
	 * - A contiguous range of characters is represented using `min-max` where `min` and `max` are formatted characters.
	 * - Single characters are formatted as either:
	 *   - a Unicode character (e.g. `a`),
	 *   - a quoted Unicode character (e.g. `'-'`), or
	 *   - a Unicode escape (e.g. `U+FF`).
	 *
	 * The returned string representation will have the following format:
	 *
	 * ```
	 * string  = "all" | "empty" | ranges | "not " ranges
	 * ranges  = range *( " " range )
	 * range   = char [ "-" char ]
	 * char    = literal | quoted | escape
	 * literal = ?Printable Unicode characters?
	 * literal = "'" ?any character? "'"
	 * escape  = "U+" +hex
	 * hex     = "A" | "B" | "C" | "D" | "E" | "F" | digit
	 * digit   = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	 * ```
	 */
	toUnicodeString'
      StringKeyword
    MethodDeclaration
      StaticKeyword
      Identifier: ' empty'
      Parameter
        Identifier: 'maximum'
        TypeReference
          Identifier: ' Char'
      TypeReference
        Identifier: ' CharSet'
    MethodDeclaration
      StaticKeyword
      Identifier: ' all'
      Parameter
        Identifier: 'maximum'
        TypeReference
          Identifier: ' Char'
      TypeReference
        Identifier: ' CharSet'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromCharacters'
      Parameter
        Identifier: 'maximum'
        TypeReference
          Identifier: ' Char'
      Parameter
        Identifier: ' characters'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'Char'
      TypeReference
        Identifier: ' CharSet'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromRange'
      Parameter
        Identifier: 'maximum'
        TypeReference
          Identifier: ' Char'
      Parameter
        Identifier: ' range'
        TypeReference
          Identifier: ' CharRange'
      TypeReference
        Identifier: ' CharSet'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromCharacter'
      Parameter
        Identifier: 'maximum'
        TypeReference
          Identifier: ' Char'
      Parameter
        Identifier: ' char'
        TypeReference
          Identifier: ' Char'
      TypeReference
        Identifier: ' CharSet'
    MethodDeclaration
      Identifier: '
	/**
	 * Returns whether this and the given character set are equivalent.
	 *
	 * Two `CharSet`s are equal if and only if:
	 *
	 * 1.  They have the same maximum.
	 * 2.  They contain the same characters.
	 *
	 * Since each set of characters has a unique range representation, 2 equal `CharSet`s are guaranteed to have equal
	 * ranges.
	 *
	 * A `CharSet` and a `CharRange` are equal if and only if they contain the same characters.
	 *
	 * @param other
	 */
	equals'
      Parameter
        Identifier: 'other'
        UnionType
          TypeReference
            Identifier: ' CharSet'
          TypeReference
            Identifier: ' CharRange'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Compares this set with given set and returns an integer value describing their relation. Two equivalent set are
	 * always guaranteed to return 0.
	 *
	 * The order defined by this function is guaranteed to be a
	 * [total order](https://en.wikipedia.org/wiki/Total_order). Apart from this, no other guarantees are given.
	 *
	 * @param other
	 */
	compare'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' CharSet'
      NumberKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Returns a character set with the given maximum.
	 *
	 * The ranges of the returned character set are equivalent to the ranges of
	 * `this.intersect({ min: 0, max: newMaximum })`.
	 *
	 * @param newMaximum
	 * @returns
	 */
	resize'
      Parameter
        Identifier: 'newMaximum'
        TypeReference
          Identifier: ' Char'
      TypeReference
        Identifier: ' CharSet'
    MethodDeclaration
      Identifier: '
	/**
	 * Returns [the complement](https://en.wikipedia.org/wiki/Complement_(set_theory)) of this set.
	 *
	 * The returned set will have the same maximum as this set.
	 */
	negate'
      TypeReference
        Identifier: ' CharSet'
    MethodDeclaration
      Identifier: '
	/**
	 * Returns [the union](https://en.wikipedia.org/wiki/Union_(set_theory)) of this set and all given sets and
	 * character ranges.
	 *
	 * The returned set will have the same maximum as this set.
	 *
	 * @param data
	 * @throws `RangeError` If the maximum of one of the given sets differs from the maximum of this set or if the
	 * maximum of one of the given ranges is greater than the maximum of this set.
	 */
	union'
      Parameter
        DotDotDotToken
        Identifier: 'data'
        ArrayType
          ParenthesizedType
            UnionType
              TypeReference
                Identifier: 'Iterable'
                TypeReference
                  Identifier: 'CharRange'
              TypeReference
                Identifier: ' CharSet'
      TypeReference
        Identifier: ' CharSet'
    MethodDeclaration
      Identifier: '
	/**
	 * Returns [the intersection](https://en.wikipedia.org/wiki/Intersection_(set_theory)) of this set and the given
	 * set/ranges of characters.
	 *
	 * The returned set will have the same maximum as this set.
	 *
	 * @param other
	 * @throws `RangeError` If the maximum of the given set differs from the maximum of this set.
	 */
	intersect'
      Parameter
        Identifier: 'other'
        UnionType
          TypeReference
            Identifier: ' CharSet'
          TypeReference
            Identifier: ' CharRange'
      TypeReference
        Identifier: ' CharSet'
    MethodDeclaration
      Identifier: '
	/**
	 * Returns a set that contains all characters of this set that are not in the given set/range.
	 *
	 * The returned set will have the same maximum as this set.
	 *
	 * @param other
	 * @throws `RangeError` If the maximum of the given set differs from the maximum of this set.
	 */
	without'
      Parameter
        Identifier: 'other'
        UnionType
          TypeReference
            Identifier: ' CharSet'
          TypeReference
            Identifier: ' CharRange'
      TypeReference
        Identifier: ' CharSet'
    MethodDeclaration
      Identifier: '
	/**
	 * Returns whether this set contains the given character.
	 *
	 * @param character
	 */
	has'
      Parameter
        Identifier: 'character'
        TypeReference
          Identifier: ' Char'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Returns whether `this ⊇ other`.
	 *
	 * @param other
	 */
	isSupersetOf'
      Parameter
        Identifier: 'other'
        UnionType
          TypeReference
            Identifier: ' CharSet'
          TypeReference
            Identifier: ' CharRange'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Returns whether `this ⊆ other`.
	 *
	 * @param other
	 */
	isSubsetOf'
      Parameter
        Identifier: 'other'
        UnionType
          TypeReference
            Identifier: ' CharSet'
          TypeReference
            Identifier: ' CharRange'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Returns whether `this ⊃ other`.
	 *
	 * @param other
	 */
	isProperSupersetOf'
      Parameter
        Identifier: 'other'
        UnionType
          TypeReference
            Identifier: ' CharSet'
          TypeReference
            Identifier: ' CharRange'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Returns whether `this ⊂ other`.
	 *
	 * @param other
	 */
	isProperSubsetOf'
      Parameter
        Identifier: 'other'
        UnionType
          TypeReference
            Identifier: ' CharSet'
          TypeReference
            Identifier: ' CharRange'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Returns whether this set and the given set (or range) are disjoint.
	 *
	 * @param other
	 */
	isDisjointWith'
      Parameter
        Identifier: 'other'
        UnionType
          TypeReference
            Identifier: ' CharSet'
          TypeReference
            Identifier: ' CharRange'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Returns any one of the common characters of this set and the given set or range.
	 *
	 * If this character set is disjoint with the given character set/range, then `undefined` will be returned.
	 *
	 * @param other
	 */
	commonCharacter'
      Parameter
        Identifier: 'other'
        UnionType
          TypeReference
            Identifier: ' CharSet'
          TypeReference
            Identifier: ' CharRange'
      UnionType
        TypeReference
          Identifier: ' Char'
        UndefinedKeyword
  TypeAliasDeclaration
    ExportKeyword
    Identifier: ' Char'
    IntersectionType
      NumberKeyword
      TypeLiteral
        PropertySignature
          Identifier: '
	__char'
          QuestionToken
          NeverKeyword
  TypeAliasDeclaration
    ExportKeyword
    Identifier: ' Word'
    ArrayType
      TypeReference
        Identifier: ' Char'
  TypeAliasDeclaration
    ExportKeyword
    Identifier: ' ReadonlyWord'
    TypeOperator
      ArrayType
        TypeReference
          Identifier: ' Char'
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' FiniteAutomaton'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' isEmpty'
      BooleanKeyword
    PropertySignature
      ReadonlyKeyword
      Identifier: ' isFinite'
      BooleanKeyword
    PropertySignature
      ReadonlyKeyword
      Identifier: ' maxCharacter'
      TypeReference
        Identifier: ' Char'
    MethodSignature
      Identifier: '
	/**
	 * Returns whether this FA accepts the given word.
	 *
	 * @param word The characters of the word to test.
	 */
	test'
      Parameter
        Identifier: 'word'
        TypeReference
          Identifier: ' ReadonlyWord'
      BooleanKeyword
    MethodSignature
      Identifier: '
	/**
	 * Returns an iterable that will yield all words accepted by this FA. Words are yielded by ascending length.
	 *
	 * If this FA accepts infinitely many words, the iterable will never end.
	 */
	words'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'Word'
    MethodSignature
      Identifier: '
	/**
	 * Returns an iterable that will yield all word sets accepted by this FA. Word sets are yielded by ascending length.
	 *
	 * If this FA accepts infinitely many words, the iterable will never end. If this FA is finite, the iterable will
	 * end after at most `2^O(n)` word sets (`n` = number of states).
	 *
	 * If you analyse the words of an FA, consider using this method instead of `words`. If this method yields `k` word
	 * sets, then `words` will yield up to `O(k * m ^ l)` words (`m` = number of possible characters, `l` = the maximum
	 * length of any of the `k` word sets).
	 */
	wordSets'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'WordSet'
    MethodSignature
      Identifier: '
	/**
	 * Returns a string representation of this FA.
	 */
	toString'
      StringKeyword
    MethodSignature
      Identifier: '
	/**
	 * Returns the AST of a regular expression that accepts the same language as this FA.
	 *
	 * @param options
	 */
	toRegex'
      Parameter
        Identifier: 'options'
        QuestionToken
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            Identifier: 'ToRegexOptions'
      TypeReference
        Identifier: ' NoParent'
        TypeReference
          Identifier: 'Expression'
    MethodSignature
      Identifier: '
	/**
	 * Returns the string representation of this FA in the
	 * [DOT format](https://en.wikipedia.org/wiki/DOT_(graph_description_language)).
	 *
	 * The output of this function can passed to any graph visualization program. This can be a
	 * [local installation](https://graphviz.org/download/) or an [online editor](https://edotor.net/).
	 *
	 * By default, {@link CharSet#toUnicodeString} is used to represent {@link CharSet}s. It's possible to provide a
	 * custom stringify function using the `charSetToString` parameter.
	 *
	 * @param charSetToString
	 */
	toDot'
      Parameter
        Identifier: 'charSetToString'
        QuestionToken
        FunctionType
          Parameter
            Identifier: 'charSet'
            TypeReference
              Identifier: ' CharSet'
          StringKeyword
      StringKeyword
    MethodSignature
      Identifier: '
	/**
	 * Returns the string representation of this FA in the [Mermaid format](https://mermaid.js.org/).
	 *
	 * By default, {@link CharSet#toUnicodeString} is used to represent {@link CharSet}s. It's possible to provide a
	 * custom stringify function using the `charSetToString` parameter.
	 *
	 * @param charSetToString
	 */
	toMermaid'
      Parameter
        Identifier: 'charSetToString'
        QuestionToken
        FunctionType
          Parameter
            Identifier: 'charSet'
            TypeReference
              Identifier: ' CharSet'
          StringKeyword
      StringKeyword
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' FAIterator'
    TypeParameter
      Identifier: 'S'
    TypeParameter
      Identifier: ' O'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'S'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' initial'
      TypeReference
        Identifier: ' S'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' getOut'
      FunctionType
        Parameter
          Identifier: 'state'
          TypeReference
            Identifier: ' S'
        TypeReference
          Identifier: ' O'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' stableOut'
      QuestionToken
      BooleanKeyword
    PropertySignature
      ReadonlyKeyword
      Identifier: ' isFinal'
      FunctionType
        Parameter
          Identifier: 'state'
          TypeReference
            Identifier: ' S'
        BooleanKeyword
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' NodeFactory'
    TypeParameter
      Identifier: 'S'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' createNode'
      FunctionType
        TypeReference
          Identifier: ' S'
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' FABuilder'
    TypeParameter
      Identifier: 'S'
    TypeParameter
      Identifier: ' T'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' NodeFactory'
        TypeReference
          Identifier: 'S'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' initial'
      TypeReference
        Identifier: ' S'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' makeFinal'
      FunctionType
        Parameter
          Identifier: 'state'
          TypeReference
            Identifier: ' S'
        VoidKeyword
    PropertySignature
      ReadonlyKeyword
      Identifier: ' isFinal'
      FunctionType
        Parameter
          Identifier: 'state'
          TypeReference
            Identifier: ' S'
        BooleanKeyword
    PropertySignature
      ReadonlyKeyword
      Identifier: ' linkNodes'
      FunctionType
        Parameter
          Identifier: 'from'
          TypeReference
            Identifier: ' S'
        Parameter
          Identifier: ' to'
          TypeReference
            Identifier: ' S'
        Parameter
          Identifier: ' transition'
          TypeReference
            Identifier: ' T'
        VoidKeyword
  TypeAliasDeclaration
    ExportKeyword
    Identifier: ' TransitionIterator'
    TypeParameter
      Identifier: 'T'
    TypeReference
      Identifier: ' FAIterator'
      TypeReference
        Identifier: 'T'
      TypeReference
        Identifier: ' ReadonlyMap'
        TypeReference
          Identifier: 'T'
        TypeReference
          Identifier: ' CharSet'
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' TransitionIterable'
    TypeParameter
      Identifier: 'T'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' maxCharacter'
      TypeReference
        Identifier: ' Char'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' transitionIterator'
      FunctionType
        TypeReference
          Identifier: ' TransitionIterator'
          TypeReference
            Identifier: 'T'
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' ToRegexOptions'
    PropertySignature
      Identifier: '
	/**
	 * The maximum number of RE AST nodes the implementation is allowed to create.
	 *
	 * If the implementation has to create more nodes to create the RE, a `TooManyNodesError` will be thrown. This
	 * maximum will be check before any optimization passes.
	 *
	 * @default 10000
	 */
	maxNodes'
      QuestionToken
      NumberKeyword
    PropertySignature
      Identifier: '
	/**
	 * The maximum number of optimization passes that will be done after the initial RE AST was created.
	 *
	 * The initial AST is usually a lot more complex than necessary. Optimizations are then applied in order to minimize
	 * the AST until this limit is reached or the AST can be optimized no further.
	 *
	 * The default number of passes is implementation defined.
	 */
	maxOptimizationPasses'
      QuestionToken
      NumberKeyword
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' ReadonlyDFA'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' FiniteAutomaton'
      ExpressionWithTypeArguments
        Identifier: ' TransitionIterable'
        TypeReference
          QualifiedName
            Identifier: 'DFA'
            Identifier: 'ReadonlyNode'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' initial'
      TypeReference
        QualifiedName
          Identifier: ' DFA'
          Identifier: 'ReadonlyNode'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' finals'
      TypeReference
        Identifier: ' ReadonlySet'
        TypeReference
          QualifiedName
            Identifier: 'DFA'
            Identifier: 'ReadonlyNode'
    MethodSignature
      Identifier: '
	stateIterator'
      TypeReference
        Identifier: ' FAIterator'
        TypeReference
          QualifiedName
            Identifier: 'DFA'
            Identifier: 'ReadonlyNode'
    MethodSignature
      Identifier: '
	/**
	 * Yields all nodes reachable from the initial state including the initial state.
	 *
	 * This may include trap states, but it will not include unreachable final states.
	 *
	 * The order in which nodes will be returned is implementation defined and may change after any operation that
	 * modifies the DFA.
	 *
	 * Modifying the DFA while iterating will result in implementation-defined behavior. The implementation may stop the
	 * iteration or yield an nodes.
	 *
	 * This operation runs in _O(E + V)_ where _E_ is the number of nodes reachable from the initial state and _V_ is
	 * the number of transitions.
	 */
	nodes'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          QualifiedName
            Identifier: 'DFA'
            Identifier: 'ReadonlyNode'
    MethodSignature
      Identifier: '
	/**
	 * Returns the number of nodes reachable from the initial state including the initial state.
	 *
	 * This returns the number of nodes returned by {@link nodes}.
	 */
	countNodes'
      NumberKeyword
    MethodSignature
      Identifier: '
	/**
	 * Creates a new DFA equivalent to this one.
	 */
	copy'
      Parameter
        Identifier: 'factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' DFA'
    MethodSignature
      Identifier: '
	/**
	 * Returns whether this and the given DFA are structurally equal meaning that all nodes and all transitions are
	 * equal.
	 *
	 * @param other
	 */
	structurallyEqual'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' ReadonlyDFA'
      BooleanKeyword
  ClassDeclaration
    ExportKeyword
    Identifier: ' DFA'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' ReadonlyDFA'
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' initial'
      TypeReference
        QualifiedName
          Identifier: ' DFA'
          Identifier: 'Node'
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' finals'
      TypeReference
        Identifier: ' Set'
        TypeReference
          QualifiedName
            Identifier: 'DFA'
            Identifier: 'Node'
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' maxCharacter'
      TypeReference
        Identifier: ' Char'
    GetAccessor
      Identifier: ' isEmpty'
      BooleanKeyword
    GetAccessor
      Identifier: ' isFinite'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	stateIterator'
      TypeReference
        Identifier: ' FAIterator'
        TypeReference
          QualifiedName
            Identifier: 'DFA'
            Identifier: 'ReadonlyNode'
    MethodDeclaration
      Identifier: '
	transitionIterator'
      TypeReference
        Identifier: ' TransitionIterator'
        TypeReference
          QualifiedName
            Identifier: 'DFA'
            Identifier: 'ReadonlyNode'
    MethodDeclaration
      Identifier: '
	nodes'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          QualifiedName
            Identifier: 'DFA'
            Identifier: 'Node'
    MethodDeclaration
      Identifier: '
	countNodes'
      NumberKeyword
    MethodDeclaration
      Identifier: '
	test'
      Parameter
        Identifier: 'word'
        TypeReference
          Identifier: ' ReadonlyWord'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	wordSets'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'WordSet'
    MethodDeclaration
      Identifier: '
	words'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'Word'
    MethodDeclaration
      Identifier: '
	toString'
      StringKeyword
    MethodDeclaration
      Identifier: '
	toRegex'
      Parameter
        Identifier: 'options'
        QuestionToken
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            Identifier: 'ToRegexOptions'
      TypeReference
        Identifier: ' NoParent'
        TypeReference
          Identifier: 'Expression'
    MethodDeclaration
      Identifier: '
	toDot'
      Parameter
        Identifier: 'charSetToString'
        QuestionToken
        FunctionType
          Parameter
            Identifier: 'charSet'
            TypeReference
              Identifier: ' CharSet'
          StringKeyword
      StringKeyword
    MethodDeclaration
      Identifier: '
	toMermaid'
      Parameter
        Identifier: 'charSetToString'
        QuestionToken
        FunctionType
          Parameter
            Identifier: 'charSet'
            TypeReference
              Identifier: ' CharSet'
          StringKeyword
      StringKeyword
    MethodDeclaration
      Identifier: '
	copy'
      Parameter
        Identifier: 'factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' DFA'
    MethodDeclaration
      Identifier: '
	structurallyEqual'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' ReadonlyDFA'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	removeUnreachable'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * [Minimizes](https://en.wikipedia.org/wiki/DFA_minimization) this DFA.
	 */
	minimize'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Complements this DFA.
	 *
	 * This DFA after calling this function will accept all words that are not accepted by this DFA before calling this
	 * function.
	 *
	 * This operation will create at most 1 node with the given factory.
	 *
	 * @param factory
	 */
	complement'
      Parameter
        Identifier: 'factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this DFA such that all prefixes of all accepted words are also accepted.
	 *
	 * If the language of this DFA is empty, then it will remain empty.
	 *
	 * Unreachable states will be removed by this operation.
	 */
	prefixes'
      VoidKeyword
    MethodDeclaration
      StaticKeyword
      Identifier: ' empty'
      Parameter
        Identifier: 'options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Options'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' DFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' emptyWord'
      Parameter
        Identifier: 'options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Options'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' DFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' all'
      Parameter
        Identifier: 'options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Options'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' DFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromCharSet'
      Parameter
        Identifier: 'charSet'
        TypeReference
          Identifier: ' CharSet'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' DFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromIntersection'
      TypeParameter
        Identifier: 'L'
      TypeParameter
        Identifier: ' R'
      Parameter
        Identifier: '
		left'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'L'
      Parameter
        Identifier: '
		right'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'R'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' DFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromWords'
      Parameter
        Identifier: '
		words'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'ReadonlyWord'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' DFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromWordSets'
      Parameter
        Identifier: '
		wordSets'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'ReadonlyWordSet'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' DFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromFA'
      TypeParameter
        Identifier: 'InputNode'
      Parameter
        Identifier: 'fa'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'InputNode'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' DFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromTransitionIterator'
      TypeParameter
        Identifier: 'InputNode'
      Parameter
        Identifier: '
		iter'
        TypeReference
          Identifier: ' TransitionIterator'
          TypeReference
            Identifier: 'InputNode'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' DFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromBuilder'
      Parameter
        Identifier: 'builder'
        TypeReference
          QualifiedName
            Identifier: ' DFA'
            Identifier: 'Builder'
      Parameter
        Identifier: ' options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'DFA'
              Identifier: 'Options'
      TypeReference
        Identifier: ' DFA'
  ModuleDeclaration
    ExportKeyword
    Identifier: ' DFA'
    ModuleBlock
      InterfaceDeclaration
        Identifier: ' ReadonlyNode'
        PropertySignature
          ReadonlyKeyword
          Identifier: ' out'
          TypeReference
            Identifier: ' ReadonlyCharMap'
            TypeReference
              Identifier: 'ReadonlyNode'
      ClassDeclaration
        Identifier: ' Node'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' ReadonlyNode'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' out'
          TypeReference
            Identifier: ' CharMap'
            TypeReference
              Identifier: 'Node'
        MethodDeclaration
          Identifier: '
		link'
          Parameter
            Identifier: 'to'
            TypeReference
              Identifier: ' Node'
          Parameter
            Identifier: ' via'
            TypeReference
              Identifier: ' CharSet'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		unlink'
          Parameter
            Identifier: 'to'
            TypeReference
              Identifier: ' Node'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Unlinks all outgoing and incoming transitions of this node.
		 */
		unlinkAll'
          VoidKeyword
      VariableStatement
        VariableDeclarationList
          VariableDeclaration
            Identifier: ' nodeFactory'
            TypeReference
              Identifier: ' NodeFactory'
              TypeReference
                Identifier: 'Node'
      ClassDeclaration
        Identifier: ' LimitedNodeFactory'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' NodeFactory'
            TypeReference
              Identifier: 'Node'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' limit'
          NumberKeyword
        Constructor
          Parameter
            Identifier: 'limit'
            QuestionToken
            NumberKeyword
        MethodDeclaration
          Identifier: '
		createNode'
          TypeReference
            Identifier: ' Node'
      ClassDeclaration
        Identifier: ' Builder'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' FABuilder'
            TypeReference
              Identifier: 'Node'
            TypeReference
              Identifier: ' CharSet'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' initial'
          TypeReference
            Identifier: ' Node'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' finals'
          TypeReference
            Identifier: ' Set'
            TypeReference
              Identifier: 'Node'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' factory'
          TypeReference
            Identifier: ' NodeFactory'
            TypeReference
              Identifier: 'Node'
        Constructor
          Parameter
            Identifier: 'factory'
            TypeReference
              Identifier: ' NodeFactory'
              TypeReference
                Identifier: 'Node'
        MethodDeclaration
          Identifier: '
		makeFinal'
          Parameter
            Identifier: 'state'
            TypeReference
              Identifier: ' Node'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		isFinal'
          Parameter
            Identifier: 'state'
            TypeReference
              Identifier: ' Node'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		linkNodes'
          Parameter
            Identifier: 'from'
            TypeReference
              Identifier: ' Node'
          Parameter
            Identifier: ' to'
            TypeReference
              Identifier: ' Node'
          Parameter
            Identifier: ' transition'
            TypeReference
              Identifier: ' CharSet'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		createNode'
          TypeReference
            Identifier: ' Node'
      InterfaceDeclaration
        Identifier: ' Options'
        PropertySignature
          Identifier: '
		/**
		 * The maximum numerical value any character can have.
		 *
		 * This will be the maximum of all underlying {@link CharSet}s.
		 */
		maxCharacter'
          TypeReference
            Identifier: ' Char'
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' ReadonlyENFA'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' FiniteAutomaton'
      ExpressionWithTypeArguments
        Identifier: ' TransitionIterable'
        TypeReference
          QualifiedName
            Identifier: 'ENFA'
            Identifier: 'ReadonlyNode'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' initial'
      TypeReference
        QualifiedName
          Identifier: ' ENFA'
          Identifier: 'ReadonlyNode'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' final'
      TypeReference
        QualifiedName
          Identifier: ' ENFA'
          Identifier: 'ReadonlyNode'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' isNormalized'
      BooleanKeyword
    MethodSignature
      Identifier: '
	stateIterator'
      Parameter
        Identifier: 'resolveEpsilon'
        BooleanKeyword
      TypeReference
        Identifier: ' FAIterator'
        TypeReference
          QualifiedName
            Identifier: 'ENFA'
            Identifier: 'ReadonlyNode'
    MethodSignature
      Identifier: '
	/**
	 * Yields all nodes reachable from the initial state including the initial state.
	 *
	 * This may include trap states, but it will not include the final states if it is unreachable from the initial
	 * state.
	 *
	 * The order in which nodes will be returned is implementation defined and may change after any operation that
	 * modifies the ENFA.
	 *
	 * Modifying the ENFA while iterating will result in implementation-defined behavior. The implementation may stop
	 * the iteration or yield an nodes.
	 *
	 * This operation runs in _O(E + V)_ where _E_ is the number of nodes reachable from the initial state and _V_ is
	 * the number of transitions.
	 */
	nodes'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          QualifiedName
            Identifier: 'ENFA'
            Identifier: 'ReadonlyNode'
    MethodSignature
      Identifier: '
	/**
	 * Returns the number of nodes reachable from the initial state including the initial state.
	 *
	 * This returns the number of nodes returned by {@link nodes}.
	 */
	countNodes'
      NumberKeyword
    MethodSignature
      Identifier: '
	/**
	 * Create a mutable copy of this ENFA.
	 */
	copy'
      Parameter
        Identifier: 'factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' ENFA'
  ClassDeclaration
    ExportKeyword
    Identifier: ' ENFA'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' ReadonlyENFA'
    PropertyDeclaration
      Identifier: '
	initial'
      TypeReference
        QualifiedName
          Identifier: ' ENFA'
          Identifier: 'Node'
    PropertyDeclaration
      Identifier: '
	final'
      TypeReference
        QualifiedName
          Identifier: ' ENFA'
          Identifier: 'Node'
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' maxCharacter'
      TypeReference
        Identifier: ' Char'
    GetAccessor
      Identifier: ' isEmpty'
      BooleanKeyword
    GetAccessor
      Identifier: ' isFinite'
      BooleanKeyword
    GetAccessor
      Identifier: ' isNormalized'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Brings this ENFA is in its normal form.
	 *
	 * This operation will create at most 2 nodes with the given factory.
	 *
	 * @param factory
	 * @see {@link ENFA}
	 */
	normalize'
      Parameter
        Identifier: 'factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	stateIterator'
      Parameter
        Identifier: 'resolveEpsilon'
        BooleanKeyword
      TypeReference
        Identifier: ' FAIterator'
        TypeReference
          QualifiedName
            Identifier: 'ENFA'
            Identifier: 'ReadonlyNode'
    MethodDeclaration
      Identifier: '
	transitionIterator'
      TypeReference
        Identifier: ' TransitionIterator'
        TypeReference
          QualifiedName
            Identifier: 'ENFA'
            Identifier: 'ReadonlyNode'
    MethodDeclaration
      Identifier: '
	nodes'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          QualifiedName
            Identifier: 'ENFA'
            Identifier: 'Node'
    MethodDeclaration
      Identifier: '
	countNodes'
      NumberKeyword
    MethodDeclaration
      Identifier: '
	copy'
      Parameter
        Identifier: 'factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' ENFA'
    MethodDeclaration
      Identifier: '
	test'
      Parameter
        Identifier: 'word'
        TypeReference
          Identifier: ' ReadonlyWord'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	wordSets'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'WordSet'
    MethodDeclaration
      Identifier: '
	words'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'Word'
    MethodDeclaration
      Identifier: '
	toString'
      StringKeyword
    MethodDeclaration
      Identifier: '
	toRegex'
      Parameter
        Identifier: 'options'
        QuestionToken
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            Identifier: 'ToRegexOptions'
      TypeReference
        Identifier: ' NoParent'
        TypeReference
          Identifier: 'Expression'
    MethodDeclaration
      Identifier: '
	toDot'
      Parameter
        Identifier: 'charSetToString'
        QuestionToken
        FunctionType
          Parameter
            Identifier: 'charSet'
            TypeReference
              Identifier: ' CharSet'
          StringKeyword
      StringKeyword
    MethodDeclaration
      Identifier: '
	toMermaid'
      Parameter
        Identifier: 'charSetToString'
        QuestionToken
        FunctionType
          Parameter
            Identifier: 'charSet'
            TypeReference
              Identifier: ' CharSet'
          StringKeyword
      StringKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this ENFA to accept the concatenation of this ENFA and the given FA.
	 *
	 * @param other
	 * @param factory
	 */
	append'
      TypeParameter
        Identifier: 'O'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'O'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this ENFA to accept the concatenation of this ENFA and the other ENFA.
	 *
	 * This operation is implemented by moving (not copying) the states from the other ENFA into this ENFA. The other
	 * ENFA will be in an **invalid state** after this operation completes. The initial and final states of the other
	 * ENFA will be random nodes of this ENFA. Makes sure that you never use the other ENFA again.
	 *
	 * This operation will create at most 4 nodes with the given factory.
	 *
	 * @param other
	 * @param factory
	 */
	appendInto'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' ENFA'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this ENFA to accept the concatenation of the given FA and this ENFA.
	 *
	 * @param other
	 * @param factory
	 */
	prepend'
      TypeParameter
        Identifier: 'O'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'O'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this ENFA to accept the concatenation of the other ENFA and this ENFA.
	 *
	 * This operation is implemented by moving (not copying) the states from the other ENFA into this ENFA. The other
	 * ENFA will be in an **invalid state** after this operation completes. The initial and final states of the other
	 * ENFA will be random nodes of this ENFA. Makes sure that you never use the other ENFA again.
	 *
	 * This operation will create at most 4 nodes with the given factory.
	 *
	 * @param other
	 * @param factory
	 */
	prependInto'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' ENFA'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this ENFA to accept the language of this ENFA and the language of the given FA.
	 *
	 * If the union kind is `left`, then this ENFA will be modified to accept `<other>|<this>`. Otherwise, it will be
	 * modified to accept `<this>|<other>`.
	 *
	 * @param other
	 * @param kind
	 * @param factory
	 */
	union'
      TypeParameter
        Identifier: 'O'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'O'
      Parameter
        Identifier: ' kind'
        QuestionToken
        UnionType
          LiteralType
            StringLiteral
          LiteralType
            StringLiteral
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this ENFA to accept the language of this ENFA and the language of the other ENFA.
	 *
	 * If the union kind is `left`, then this ENFA will be modified to accept `<other>|<this>`. Otherwise, it will be
	 * modified to accept `<this>|<other>`.
	 *
	 * This operation is implemented by moving (not copying) the states from the other ENFA into this ENFA. The other
	 * ENFA will be in an **invalid state** after this operation completes. The initial and final states of the other
	 * ENFA will be random nodes of this ENFA. Makes sure that you never use the other ENFA again.
	 *
	 * This operation will create at most 6 nodes with the given factory.
	 *
	 * @param other
	 * @param kind
	 * @param factory
	 */
	unionInto'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' ENFA'
      Parameter
        Identifier: ' kind'
        QuestionToken
        UnionType
          LiteralType
            StringLiteral
          LiteralType
            StringLiteral
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this ENFA to accept at least `min` and at most `max` concatenations of itself.
	 *
	 * Both `min` and `max` both have to be non-negative integers with `min <= max`.
	 * `max` is also allowed to be `Infinity`.
	 *
	 * @param min
	 * @param max
	 * @param lazy
	 * @param factory
	 */
	quantify'
      Parameter
        Identifier: 'min'
        NumberKeyword
      Parameter
        Identifier: ' max'
        NumberKeyword
      Parameter
        Identifier: ' lazy'
        QuestionToken
        BooleanKeyword
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Removes the empty word from the accepted languages of this ENFA.
	 *
	 * Unreachable states will be removed by this operation.
	 *
	 * @param factory
	 */
	withoutEmptyWord'
      Parameter
        Identifier: 'factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * All states which cannot be reached from the initial state or cannot reach (or are) a final state, will be
	 * removed.
	 */
	removeUnreachable'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this ENFA such that all prefixes of all accepted words are also accepted.
	 *
	 * If the language of this ENFA is empty, then it will remain empty.
	 *
	 * Unreachable states will be removed by this operation.
	 *
	 * @param factory
	 */
	prefixes'
      Parameter
        Identifier: 'factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this ENFA such that all suffixes of all accepted words are also accepted.
	 *
	 * If the language of this ENFA is empty, then it will remain empty.
	 *
	 * Unreachable states will be removed by this operation.
	 *
	 * @param factory
	 */
	suffixes'
      Parameter
        Identifier: 'factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      StaticKeyword
      Identifier: ' empty'
      Parameter
        Identifier: 'options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Options'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' ENFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' emptyWord'
      Parameter
        Identifier: 'options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Options'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' ENFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' all'
      Parameter
        Identifier: 'options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Options'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' ENFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromCharSet'
      Parameter
        Identifier: 'charSet'
        TypeReference
          Identifier: ' CharSet'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' ENFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromRegex'
      Parameter
        Identifier: '
		concat'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Node'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		creationOptions'
        QuestionToken
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'FromRegexOptions'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' ENFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromRegex'
      Parameter
        Identifier: '
		alternatives'
        TypeOperator
          ArrayType
            TypeReference
              Identifier: ' NoParent'
              TypeReference
                Identifier: 'Concatenation'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		creationOptions'
        QuestionToken
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'FromRegexOptions'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' ENFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromWords'
      Parameter
        Identifier: '
		words'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'ReadonlyWord'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' ENFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromWordSets'
      Parameter
        Identifier: '
		wordSets'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'ReadonlyWordSet'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' ENFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromFA'
      TypeParameter
        Identifier: 'InputNode'
      Parameter
        Identifier: 'fa'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'InputNode'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' ENFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromTransitionIterator'
      TypeParameter
        Identifier: 'InputNode'
      Parameter
        Identifier: '
		iter'
        TypeReference
          Identifier: ' TransitionIterator'
          TypeReference
            Identifier: 'InputNode'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' ENFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromBuilder'
      Parameter
        Identifier: 'builder'
        TypeReference
          QualifiedName
            Identifier: ' ENFA'
            Identifier: 'Builder'
      Parameter
        Identifier: ' options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'ENFA'
              Identifier: 'Options'
      TypeReference
        Identifier: ' ENFA'
  ModuleDeclaration
    ExportKeyword
    Identifier: ' ENFA'
    ModuleBlock
      InterfaceDeclaration
        Identifier: ' ReadonlyNode'
        PropertySignature
          ReadonlyKeyword
          Identifier: ' out'
          TypeReference
            Identifier: ' ReadonlyMap'
            TypeReference
              Identifier: 'ReadonlyNode'
            UnionType
              TypeReference
                Identifier: ' CharSet'
              LiteralType
                NullKeyword
        PropertySignature
          ReadonlyKeyword
          Identifier: ' in'
          TypeReference
            Identifier: ' ReadonlyMap'
            TypeReference
              Identifier: 'ReadonlyNode'
            UnionType
              TypeReference
                Identifier: ' CharSet'
              LiteralType
                NullKeyword
        MethodSignature
          Identifier: '
		/**
		 * Calls the given consumer function on every non-epsilon transition directly reachable from the given node.
		 *
		 * Epsilon transitions will be resolved using a DFS algorithm. This means that for the following graph:
		 *
		 * ```text
		 * (0) -> (1) : "a"
		 *     -> (2) : epsilon
		 *     -> (3) : "b"
		 *
		 * (1) -> (3) : "c"
		 *
		 * (2) -> (4) : "d"
		 *     -> (1) : "e"
		 *     -> (2) : epsilon
		 *
		 * (3) -> (1) : epsilon
		 *
		 * (4) -> empty
		 * ```
		 *
		 * The node `(0)` will return the resolved list:
		 *
		 * ```text
		 * [(1), "a"]
		 * [(4), "d"]
		 * [(1), "e"]
		 * [(3), "b"]
		 * ```
		 */
		resolveEpsilon'
          Parameter
            Identifier: 'direction'
            UnionType
              LiteralType
                StringLiteral
              LiteralType
                StringLiteral
          Parameter
            Identifier: ' consumerFn'
            FunctionType
              Parameter
                Identifier: 'charSet'
                TypeReference
                  Identifier: ' CharSet'
              Parameter
                Identifier: ' node'
                TypeReference
                  Identifier: ' ReadonlyNode'
              VoidKeyword
          VoidKeyword
        MethodSignature
          Identifier: '
		/**
		 * Returns a set of all nodes that are reachable from the given node by only following epsilon transitions in
		 * the given direction. The returned set is guaranteed to always contain the given node.
		 *
		 * The order of the nodes in the returned set in implementation-defined and cannot be relied upon.
		 *
		 * ---
		 *
		 * This method can be used to determine the set of all effectively final states.
		 *
		 * ```
		 * const effectivelyFinal = final.reachableViaEpsilon("in");
		 * ```
		 */
		reachableViaEpsilon'
          Parameter
            Identifier: 'direction'
            UnionType
              LiteralType
                StringLiteral
              LiteralType
                StringLiteral
          TypeReference
            Identifier: ' Set'
            TypeReference
              Identifier: 'ReadonlyNode'
      ClassDeclaration
        Identifier: ' Node'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' ReadonlyNode'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' out'
          TypeReference
            Identifier: ' Map'
            TypeReference
              Identifier: 'Node'
            UnionType
              TypeReference
                Identifier: ' CharSet'
              LiteralType
                NullKeyword
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' in'
          TypeReference
            Identifier: ' Map'
            TypeReference
              Identifier: 'Node'
            UnionType
              TypeReference
                Identifier: ' CharSet'
              LiteralType
                NullKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Adds a transition from `this` to `to` using the given non-empty set of characters.
		 *
		 * If two nodes are already linked, an error will be thrown.
		 *
		 * @param to
		 * @param via
		 */
		link'
          Parameter
            Identifier: 'to'
            TypeReference
              Identifier: ' Node'
          Parameter
            Identifier: ' via'
            UnionType
              TypeReference
                Identifier: ' CharSet'
              LiteralType
                NullKeyword
          VoidKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Removes the transition from `this` to `to`.
		 *
		 * This will do nothing if `this` isn't linked to `to`.
		 *
		 * @param to
		 */
		unlink'
          Parameter
            Identifier: 'to'
            TypeReference
              Identifier: ' Node'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Unlinks all outgoing and incoming transitions of this node.
		 */
		unlinkAll'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Unlinks all outgoing transitions of this node.
		 */
		unlinkAllOut'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Unlinks all incoming transitions of this node.
		 */
		unlinkAllIn'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		resolveEpsilon'
          Parameter
            Identifier: 'direction'
            UnionType
              LiteralType
                StringLiteral
              LiteralType
                StringLiteral
          Parameter
            Identifier: ' consumerFn'
            FunctionType
              Parameter
                Identifier: 'charSet'
                TypeReference
                  Identifier: ' CharSet'
              Parameter
                Identifier: ' node'
                TypeReference
                  Identifier: ' Node'
              VoidKeyword
          VoidKeyword
        MethodDeclaration
          Identifier: '
		reachableViaEpsilon'
          Parameter
            Identifier: 'direction'
            UnionType
              LiteralType
                StringLiteral
              LiteralType
                StringLiteral
          TypeReference
            Identifier: ' Set'
            TypeReference
              Identifier: 'Node'
      VariableStatement
        VariableDeclarationList
          VariableDeclaration
            Identifier: ' nodeFactory'
            TypeReference
              Identifier: ' NodeFactory'
              TypeReference
                Identifier: 'Node'
      ClassDeclaration
        Identifier: ' LimitedNodeFactory'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' NodeFactory'
            TypeReference
              Identifier: 'Node'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' limit'
          NumberKeyword
        Constructor
          Parameter
            Identifier: 'limit'
            QuestionToken
            NumberKeyword
        MethodDeclaration
          Identifier: '
		createNode'
          TypeReference
            Identifier: ' Node'
      ClassDeclaration
        Identifier: ' Builder'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' FABuilder'
            TypeReference
              Identifier: 'Node'
            UnionType
              TypeReference
                Identifier: ' CharSet'
              LiteralType
                NullKeyword
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' initial'
          TypeReference
            Identifier: ' Node'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' final'
          TypeReference
            Identifier: ' Node'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' factory'
          TypeReference
            Identifier: ' NodeFactory'
            TypeReference
              Identifier: 'Node'
        Constructor
          Parameter
            Identifier: 'factory'
            TypeReference
              Identifier: ' NodeFactory'
              TypeReference
                Identifier: 'Node'
        MethodDeclaration
          Identifier: '
		makeFinal'
          Parameter
            Identifier: 'state'
            TypeReference
              Identifier: ' Node'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		isFinal'
          Parameter
            Identifier: 'state'
            TypeReference
              Identifier: ' Node'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		linkNodes'
          Parameter
            Identifier: 'from'
            TypeReference
              Identifier: ' Node'
          Parameter
            Identifier: ' to'
            TypeReference
              Identifier: ' Node'
          Parameter
            Identifier: ' transition'
            UnionType
              TypeReference
                Identifier: ' CharSet'
              LiteralType
                NullKeyword
          VoidKeyword
        MethodDeclaration
          Identifier: '
		createNode'
          TypeReference
            Identifier: ' Node'
      InterfaceDeclaration
        Identifier: ' Options'
        PropertySignature
          Identifier: '
		/**
		 * The maximum numerical value any character can have.
		 *
		 * This will be the maximum of all underlying {@link CharSet}s.
		 */
		maxCharacter'
          TypeReference
            Identifier: ' Char'
      InterfaceDeclaration
        Identifier: ' FromRegexOptions'
        PropertySignature
          Identifier: '
		/**
		 * How to handle assertions when construction the ENFA.
		 *
		 * - `"throw"`
		 *
		 *   This method will throw an error when encountering an assertion.
		 *
		 * - `"disable"`
		 *
		 *   This method will replace any assertion with an empty character class, effectively removing it.
		 *
		 * - `"ignore"`
		 *
		 *   This method will replace any assertion with an empty group.
		 *
		 * @default "throw"
		 */
		assertions'
          QuestionToken
          UnionType
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
        PropertySignature
          Identifier: '
		/**
		 * How to handle unknowns when construction the ENFA.
		 *
		 * - `"throw"`
		 *
		 *   This method will throw an error when encountering an unknown.
		 *
		 * - `"disable"`
		 *
		 *   This method will replace any unknown with an empty character class, effectively removing it.
		 *
		 * @default "throw"
		 */
		unknowns'
          QuestionToken
          UnionType
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
        PropertySignature
          Identifier: '
		/**
		 * The number at which the maximum of a quantifier will be assumed to be infinity.
		 *
		 * Quantifiers with a large finite maximum (e.g. `a{1,10000}`) can create huge NFAs with thousands of states.
		 * Any Quantifier with a maximum greater or equal to this threshold will be assumed to be infinite.
		 *
		 * @default Infinity
		 */
		infinityThreshold'
          QuestionToken
          NumberKeyword
  ClassDeclaration
    ExportKeyword
    Identifier: ' MaxCharacterError'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' Error'
    MethodDeclaration
      StaticKeyword
      Identifier: ' assert'
      Parameter
        Identifier: '
		a'
        UnionType
          TypeReference
            Identifier: ' Char'
          TypeLiteral
            PropertySignature
              Identifier: '
					maxCharacter'
              TypeReference
                Identifier: ' Char'
      Parameter
        Identifier: '
		b'
        UnionType
          TypeReference
            Identifier: ' Char'
          TypeLiteral
            PropertySignature
              Identifier: '
					maxCharacter'
              TypeReference
                Identifier: ' Char'
      Parameter
        Identifier: '
		kind'
        QuestionToken
        StringKeyword
      VoidKeyword
  ClassDeclaration
    ExportKeyword
    Identifier: ' TooManyNodesError'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' Error'
    MethodDeclaration
      StaticKeyword
      Identifier: ' assert'
      Parameter
        Identifier: 'current'
        NumberKeyword
      Parameter
        Identifier: ' limit'
        NumberKeyword
      Parameter
        Identifier: ' kind'
        StringKeyword
      VoidKeyword
  FunctionDeclaration
    ExportKeyword
    Identifier: ' getIntersectionIterator'
    TypeParameter
      Identifier: 'L'
    TypeParameter
      Identifier: ' R'
    Parameter
      Identifier: '
	left'
      TypeReference
        Identifier: ' TransitionIterable'
        TypeReference
          Identifier: 'L'
    Parameter
      Identifier: '
	right'
      TypeReference
        Identifier: ' TransitionIterable'
        TypeReference
          Identifier: 'R'
    Parameter
      Identifier: '
	maxNodes'
      QuestionToken
      NumberKeyword
    TypeReference
      Identifier: ' TransitionIterator'
      TypeReference
        QualifiedName
          Identifier: 'FAIterators'
          Identifier: 'MapFABuilderNode'
  FunctionDeclaration
    ExportKeyword
    Identifier: ' isDisjointWith'
    TypeParameter
      Identifier: 'L'
    TypeParameter
      Identifier: ' R'
    Parameter
      Identifier: '
	left'
      TypeReference
        Identifier: ' TransitionIterable'
        TypeReference
          Identifier: 'L'
    Parameter
      Identifier: '
	right'
      TypeReference
        Identifier: ' TransitionIterable'
        TypeReference
          Identifier: 'R'
    Parameter
      Identifier: '
	maxNodes'
      QuestionToken
      NumberKeyword
    BooleanKeyword
  FunctionDeclaration
    ExportKeyword
    Identifier: ' getIntersectionWordSets'
    TypeParameter
      Identifier: 'L'
    TypeParameter
      Identifier: ' R'
    Parameter
      Identifier: '
	left'
      TypeReference
        Identifier: ' TransitionIterable'
        TypeReference
          Identifier: 'L'
    Parameter
      Identifier: '
	right'
      TypeReference
        Identifier: ' TransitionIterable'
        TypeReference
          Identifier: 'R'
    Parameter
      Identifier: '
	maxNodes'
      QuestionToken
      NumberKeyword
    TypeReference
      Identifier: ' Iterable'
      TypeReference
        Identifier: 'WordSet'
  FunctionDeclaration
    ExportKeyword
    Identifier: ' getIntersectionWords'
    TypeParameter
      Identifier: 'L'
    TypeParameter
      Identifier: ' R'
    Parameter
      Identifier: '
	left'
      TypeReference
        Identifier: ' TransitionIterable'
        TypeReference
          Identifier: 'L'
    Parameter
      Identifier: '
	right'
      TypeReference
        Identifier: ' TransitionIterable'
        TypeReference
          Identifier: 'R'
    Parameter
      Identifier: '
	maxNodes'
      QuestionToken
      NumberKeyword
    TypeReference
      Identifier: ' Iterable'
      TypeReference
        Identifier: 'Word'
  InterfaceDeclaration
    ExportKeyword
    Identifier: ' ReadonlyNFA'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' FiniteAutomaton'
      ExpressionWithTypeArguments
        Identifier: ' TransitionIterable'
        TypeReference
          QualifiedName
            Identifier: 'NFA'
            Identifier: 'ReadonlyNode'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' initial'
      TypeReference
        QualifiedName
          Identifier: ' NFA'
          Identifier: 'ReadonlyNode'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' finals'
      TypeReference
        Identifier: ' ReadonlySet'
        TypeReference
          QualifiedName
            Identifier: 'NFA'
            Identifier: 'ReadonlyNode'
    PropertySignature
      ReadonlyKeyword
      Identifier: ' isNormalized'
      BooleanKeyword
    MethodSignature
      Identifier: '
	stateIterator'
      TypeReference
        Identifier: ' FAIterator'
        TypeReference
          QualifiedName
            Identifier: 'NFA'
            Identifier: 'ReadonlyNode'
    MethodSignature
      Identifier: '
	/**
	 * Yields all nodes reachable from the initial state including the initial state.
	 *
	 * This may include trap states, but it will not include unreachable final states.
	 *
	 * The order in which nodes will be returned is implementation defined and may change after any operation that
	 * modifies the NFA.
	 *
	 * Modifying the NFA while iterating will result in implementation-defined behavior. The implementation may stop the
	 * iteration or yield an nodes.
	 *
	 * This operation runs in _O(E + V)_ where _E_ is the number of nodes reachable from the initial state and _V_ is
	 * the number of transitions.
	 */
	nodes'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          QualifiedName
            Identifier: 'NFA'
            Identifier: 'ReadonlyNode'
    MethodSignature
      Identifier: '
	/**
	 * Returns the number of nodes reachable from the initial state including the initial state.
	 *
	 * This returns the number of nodes returned by {@link nodes}.
	 */
	countNodes'
      NumberKeyword
    MethodSignature
      Identifier: '
	/**
	 * Create a mutable copy of this NFA.
	 *
	 * @param factory
	 */
	copy'
      Parameter
        Identifier: 'factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
  ClassDeclaration
    ExportKeyword
    Identifier: ' NFA'
    HeritageClause
      ExpressionWithTypeArguments
        Identifier: ' ReadonlyNFA'
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' initial'
      TypeReference
        QualifiedName
          Identifier: ' NFA'
          Identifier: 'Node'
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' finals'
      TypeReference
        Identifier: ' Set'
        TypeReference
          QualifiedName
            Identifier: 'NFA'
            Identifier: 'Node'
    PropertyDeclaration
      ReadonlyKeyword
      Identifier: ' maxCharacter'
      TypeReference
        Identifier: ' Char'
    GetAccessor
      Identifier: ' isEmpty'
      BooleanKeyword
    GetAccessor
      Identifier: ' isFinite'
      BooleanKeyword
    GetAccessor
      Identifier: ' isNormalized'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Brings this NFA is in its normal form.
	 *
	 * This operation will create at most 1 node with the given factory.
	 *
	 * @param factory
	 * @see {@link NFA}
	 */
	normalize'
      Parameter
        Identifier: 'factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	stateIterator'
      TypeReference
        Identifier: ' FAIterator'
        TypeReference
          QualifiedName
            Identifier: 'NFA'
            Identifier: 'ReadonlyNode'
    MethodDeclaration
      Identifier: '
	transitionIterator'
      TypeReference
        Identifier: ' TransitionIterator'
        TypeReference
          QualifiedName
            Identifier: 'NFA'
            Identifier: 'ReadonlyNode'
    MethodDeclaration
      Identifier: '
	nodes'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          QualifiedName
            Identifier: 'NFA'
            Identifier: 'Node'
    MethodDeclaration
      Identifier: '
	countNodes'
      NumberKeyword
    MethodDeclaration
      Identifier: '
	copy'
      Parameter
        Identifier: 'factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
    MethodDeclaration
      Identifier: '
	test'
      Parameter
        Identifier: 'word'
        TypeReference
          Identifier: ' ReadonlyWord'
      BooleanKeyword
    MethodDeclaration
      Identifier: '
	wordSets'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'WordSet'
    MethodDeclaration
      Identifier: '
	words'
      TypeReference
        Identifier: ' Iterable'
        TypeReference
          Identifier: 'Word'
    MethodDeclaration
      Identifier: '
	toString'
      StringKeyword
    MethodDeclaration
      Identifier: '
	toRegex'
      Parameter
        Identifier: 'options'
        QuestionToken
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            Identifier: 'ToRegexOptions'
      TypeReference
        Identifier: ' NoParent'
        TypeReference
          Identifier: 'Expression'
    MethodDeclaration
      Identifier: '
	toDot'
      Parameter
        Identifier: 'charSetToString'
        QuestionToken
        FunctionType
          Parameter
            Identifier: 'charSet'
            TypeReference
              Identifier: ' CharSet'
          StringKeyword
      StringKeyword
    MethodDeclaration
      Identifier: '
	toMermaid'
      Parameter
        Identifier: 'charSetToString'
        QuestionToken
        FunctionType
          Parameter
            Identifier: 'charSet'
            TypeReference
              Identifier: ' CharSet'
          StringKeyword
      StringKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this NFA to accept all words from this NFA and the given FA.
	 *
	 * @param other
	 * @param factory
	 */
	union'
      TypeParameter
        Identifier: 'O'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'O'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this NFA to accept all words from this NFA and the given NFA.
	 *
	 * This is implemented by simply moving the nodes from the given NFA into this NFA. The given NFA will be empty
	 * after this operation as nodes are moved, not shared.
	 *
	 * @param other
	 * @param factory
	 */
	unionInto'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' NFA'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this NFA to accept the concatenation of this NFA and the given FA.
	 *
	 * @param other
	 * @param factory
	 */
	append'
      TypeParameter
        Identifier: 'O'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'O'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this NFA to accept the concatenation of this NFA and the given FA.
	 *
	 * This is implemented by simply moving the nodes from the given NFA into this NFA. The given NFA will be empty
	 * after this operation as nodes are moved, not shared.
	 *
	 * @param other
	 * @param factory
	 */
	appendInto'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' NFA'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this NFA to accept the concatenation of the given NFA and this FA.
	 *
	 * @param other
	 * @param factory
	 */
	prepend'
      TypeParameter
        Identifier: 'O'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'O'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this NFA to accept the concatenation of the given NFA and this FA.
	 *
	 * This is implemented by simply moving the nodes from the given NFA into this NFA. The given NFA will be empty
	 * after this operation as nodes are moved, not shared.
	 *
	 * @param other
	 * @param factory
	 */
	prependInto'
      Parameter
        Identifier: 'other'
        TypeReference
          Identifier: ' NFA'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this NFA to accept at least `min` and at most `max` concatenations of itself.
	 *
	 * Both `min` and `max` both have to be non-negative integers with `min <= max`.
	 * `max` is also allowed to be `Infinity`.
	 *
	 * @param min
	 * @param max
	 * @param factory
	 */
	quantify'
      Parameter
        Identifier: 'min'
        NumberKeyword
      Parameter
        Identifier: ' max'
        NumberKeyword
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Removes the empty word from the accepted languages of this NFA.
	 */
	withoutEmptyWord'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Removes all states that are unreachable.
	 *
	 * Only the following states will remain after this operation:
	 *
	 * 1. The initial state.
	 * 2. All states that are reachable from the initial state and can reach one of the final states.
	 */
	removeUnreachable'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this NFA such that all prefixes of all accepted words are also accepted.
	 *
	 * If the language of this NFA is empty, then it will remain empty.
	 *
	 * Unreachable states will be removed by this operation.
	 */
	prefixes'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this NFA such that all suffixes of all accepted words are also accepted.
	 *
	 * If the language of this NFA is empty, then it will remain empty.
	 *
	 * Unreachable states will be removed by this operation.
	 */
	suffixes'
      VoidKeyword
    MethodDeclaration
      Identifier: '
	/**
	 * Modifies this NFA such that it accepts the reverse of all words it currently accepts.
	 *
	 * If the language of this NFA is empty, then it will remain empty.
	 *
	 * Unreachable states will be removed by this operation.
	 */
	reverse'
      VoidKeyword
    MethodDeclaration
      StaticKeyword
      Identifier: ' empty'
      Parameter
        Identifier: 'options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Options'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' emptyWord'
      Parameter
        Identifier: 'options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Options'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' all'
      Parameter
        Identifier: 'options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Options'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromCharSet'
      Parameter
        Identifier: 'charSet'
        TypeReference
          Identifier: ' CharSet'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromIntersection'
      TypeParameter
        Identifier: 'L'
      TypeParameter
        Identifier: ' R'
      Parameter
        Identifier: '
		left'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'L'
      Parameter
        Identifier: '
		right'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'R'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromRegex'
      Parameter
        Identifier: '
		concat'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Node'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		creationOptions'
        QuestionToken
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'FromRegexOptions'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromRegex'
      Parameter
        Identifier: '
		alternatives'
        TypeOperator
          ArrayType
            TypeReference
              Identifier: ' NoParent'
              TypeReference
                Identifier: 'Concatenation'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		creationOptions'
        QuestionToken
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'FromRegexOptions'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromWords'
      Parameter
        Identifier: '
		words'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'ReadonlyWord'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromWordSets'
      Parameter
        Identifier: '
		wordSets'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'ReadonlyWordSet'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromFA'
      TypeParameter
        Identifier: 'InputNode'
      Parameter
        Identifier: 'fa'
        TypeReference
          Identifier: ' TransitionIterable'
          TypeReference
            Identifier: 'InputNode'
      Parameter
        Identifier: ' factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromTransitionIterator'
      TypeParameter
        Identifier: 'InputNode'
      Parameter
        Identifier: '
		iter'
        TypeReference
          Identifier: ' TransitionIterator'
          TypeReference
            Identifier: 'InputNode'
      Parameter
        Identifier: '
		options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Options'
      Parameter
        Identifier: '
		factory'
        QuestionToken
        TypeReference
          Identifier: ' NodeFactory'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Node'
      TypeReference
        Identifier: ' NFA'
    MethodDeclaration
      StaticKeyword
      Identifier: ' fromBuilder'
      Parameter
        Identifier: 'builder'
        TypeReference
          QualifiedName
            Identifier: ' NFA'
            Identifier: 'Builder'
      Parameter
        Identifier: ' options'
        TypeReference
          Identifier: ' Readonly'
          TypeReference
            QualifiedName
              Identifier: 'NFA'
              Identifier: 'Options'
      TypeReference
        Identifier: ' NFA'
  ModuleDeclaration
    ExportKeyword
    Identifier: ' NFA'
    ModuleBlock
      InterfaceDeclaration
        Identifier: ' ReadonlyNode'
        PropertySignature
          ReadonlyKeyword
          Identifier: ' out'
          TypeReference
            Identifier: ' ReadonlyMap'
            TypeReference
              Identifier: 'ReadonlyNode'
            TypeReference
              Identifier: ' CharSet'
        PropertySignature
          ReadonlyKeyword
          Identifier: ' in'
          TypeReference
            Identifier: ' ReadonlyMap'
            TypeReference
              Identifier: 'ReadonlyNode'
            TypeReference
              Identifier: ' CharSet'
      ClassDeclaration
        Identifier: ' Node'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' ReadonlyNode'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' out'
          TypeReference
            Identifier: ' Map'
            TypeReference
              Identifier: 'Node'
            TypeReference
              Identifier: ' CharSet'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' in'
          TypeReference
            Identifier: ' Map'
            TypeReference
              Identifier: 'Node'
            TypeReference
              Identifier: ' CharSet'
        MethodDeclaration
          Identifier: '
		link'
          Parameter
            Identifier: 'to'
            TypeReference
              Identifier: ' Node'
          Parameter
            Identifier: ' via'
            TypeReference
              Identifier: ' CharSet'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		unlink'
          Parameter
            Identifier: 'to'
            TypeReference
              Identifier: ' Node'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Unlinks all outgoing and incoming transitions of this node.
		 */
		unlinkAll'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Unlinks all outgoing transitions of this node.
		 */
		unlinkAllOut'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Unlinks all incoming transitions of this node.
		 */
		unlinkAllIn'
          VoidKeyword
      VariableStatement
        VariableDeclarationList
          VariableDeclaration
            Identifier: ' nodeFactory'
            TypeReference
              Identifier: ' NodeFactory'
              TypeReference
                Identifier: 'Node'
      ClassDeclaration
        Identifier: ' LimitedNodeFactory'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' NodeFactory'
            TypeReference
              Identifier: 'Node'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' limit'
          NumberKeyword
        Constructor
          Parameter
            Identifier: 'limit'
            QuestionToken
            NumberKeyword
        MethodDeclaration
          Identifier: '
		createNode'
          TypeReference
            Identifier: ' Node'
      ClassDeclaration
        Identifier: ' Builder'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' FABuilder'
            TypeReference
              Identifier: 'Node'
            TypeReference
              Identifier: ' CharSet'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' initial'
          TypeReference
            Identifier: ' Node'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' finals'
          TypeReference
            Identifier: ' Set'
            TypeReference
              Identifier: 'Node'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' factory'
          TypeReference
            Identifier: ' NodeFactory'
            TypeReference
              Identifier: 'Node'
        Constructor
          Parameter
            Identifier: 'factory'
            TypeReference
              Identifier: ' NodeFactory'
              TypeReference
                Identifier: 'Node'
        MethodDeclaration
          Identifier: '
		makeFinal'
          Parameter
            Identifier: 'state'
            TypeReference
              Identifier: ' Node'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		isFinal'
          Parameter
            Identifier: 'state'
            TypeReference
              Identifier: ' Node'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		linkNodes'
          Parameter
            Identifier: 'from'
            TypeReference
              Identifier: ' Node'
          Parameter
            Identifier: ' to'
            TypeReference
              Identifier: ' Node'
          Parameter
            Identifier: ' transition'
            TypeReference
              Identifier: ' CharSet'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		createNode'
          TypeReference
            Identifier: ' Node'
      InterfaceDeclaration
        Identifier: ' Options'
        PropertySignature
          Identifier: '
		/**
		 * The maximum numerical value any character can have.
		 *
		 * This will be the maximum of all underlying {@link CharSet}s.
		 */
		maxCharacter'
          TypeReference
            Identifier: ' Char'
      InterfaceDeclaration
        Identifier: ' FromRegexOptions'
        PropertySignature
          Identifier: '
		/**
		 * How to handle assertions when construction the NFA.
		 *
		 * - `"throw"`
		 *
		 *   This method will throw an error when encountering an assertion.
		 *
		 * - `"disable"`
		 *
		 *   This method will replace any assertion with an empty character class, effectively removing it.
		 *
		 * - `"ignore"`
		 *
		 *   This method will replace any assertion with an empty group.
		 *
		 * @default "throw"
		 */
		assertions'
          QuestionToken
          UnionType
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
        PropertySignature
          Identifier: '
		/**
		 * How to handle unknowns when construction the NFA.
		 *
		 * - `"throw"`
		 *
		 *   This method will throw an error when encountering an unknown.
		 *
		 * - `"disable"`
		 *
		 *   This method will replace any unknown with an empty character class, effectively removing it.
		 *
		 * @default "throw"
		 */
		unknowns'
          QuestionToken
          UnionType
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
        PropertySignature
          Identifier: '
		/**
		 * The number at which the maximum of a quantifier will be assumed to be infinity.
		 *
		 * Quantifiers with a large finite maximum (e.g. `a{1,10000}`) can create huge NFAs with thousands of states.
		 * Any Quantifier with a maximum greater or equal to this threshold will be assumed to be infinite.
		 *
		 * @default Infinity
		 */
		infinityThreshold'
          QuestionToken
          NumberKeyword
  TypeAliasDeclaration
    ExportKeyword
    Identifier: ' WordSet'
    ArrayType
      TypeReference
        Identifier: ' CharSet'
  TypeAliasDeclaration
    ExportKeyword
    Identifier: ' ReadonlyWordSet'
    TypeOperator
      ArrayType
        TypeReference
          Identifier: ' CharSet'
  ModuleDeclaration
    ExportKeyword
    Identifier: ' Transformers'
    ModuleBlock
      InterfaceDeclaration
        Identifier: ' CreationOptions'
        PropertySignature
          Identifier: '
		/**
		 * If `true`, transformers are allowed to reorder alternatives and to change/ignore the laziness of quantifiers.
		 * This may cause the behavior of the regex to change.
		 *
		 * @default false
		 */
		ignoreOrder'
          QuestionToken
          BooleanKeyword
        PropertySignature
          Identifier: '
		/**
		 * If `true`, transformers are allowed to reduce or increase the ambiguity of the regular expression.
		 *
		 * @default false
		 */
		ignoreAmbiguity'
          QuestionToken
          BooleanKeyword
      FunctionDeclaration
        Identifier: ' applyAssertions'
        Parameter
          Identifier: '_options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'CreationOptions'
        TypeReference
          Identifier: ' Transformer'
      FunctionDeclaration
        Identifier: ' factorOut'
        Parameter
          Identifier: 'options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'CreationOptions'
        TypeReference
          Identifier: ' Transformer'
      FunctionDeclaration
        Identifier: ' inline'
        Parameter
          Identifier: '_options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'CreationOptions'
        TypeReference
          Identifier: ' Transformer'
      FunctionDeclaration
        Identifier: ' makeGreedy'
        Parameter
          Identifier: 'options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'CreationOptions'
        TypeReference
          Identifier: ' Transformer'
      FunctionDeclaration
        Identifier: ' mergeWithQuantifier'
        Parameter
          Identifier: 'options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'CreationOptions'
        TypeReference
          Identifier: ' Transformer'
      FunctionDeclaration
        Identifier: ' moveUpEmpty'
        Parameter
          Identifier: 'options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'CreationOptions'
        TypeReference
          Identifier: ' Transformer'
      FunctionDeclaration
        Identifier: ' nestedQuantifiers'
        Parameter
          Identifier: 'options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'CreationOptions'
        TypeReference
          Identifier: ' Transformer'
      InterfaceDeclaration
        Identifier: ' PatternEdgeAssertionsCreationOptions'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' CreationOptions'
        PropertySignature
          Identifier: '
		/**
		 * @default true
		 */
		inline'
          QuestionToken
          BooleanKeyword
        PropertySignature
          Identifier: '
		/**
		 * @default false
		 */
		remove'
          QuestionToken
          BooleanKeyword
      FunctionDeclaration
        Identifier: ' patternEdgeAssertions'
        Parameter
          Identifier: 'options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'PatternEdgeAssertionsCreationOptions'
        TypeReference
          Identifier: ' Transformer'
      FunctionDeclaration
        Identifier: ' removeDeadBranches'
        Parameter
          Identifier: '_options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'CreationOptions'
        TypeReference
          Identifier: ' Transformer'
      FunctionDeclaration
        Identifier: ' removeUnnecessaryAssertions'
        Parameter
          Identifier: '_options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'CreationOptions'
        TypeReference
          Identifier: ' Transformer'
      InterfaceDeclaration
        Identifier: ' RemoveAssertionsCreationOptions'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' CreationOptions'
        PropertySignature
          Identifier: '
		/**
		 * @default "empty-set"
		 */
		replacement'
          QuestionToken
          UnionType
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
      FunctionDeclaration
        Identifier: ' replaceAssertions'
        Parameter
          Identifier: 'options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'RemoveAssertionsCreationOptions'
        TypeReference
          Identifier: ' Transformer'
      FunctionDeclaration
        Identifier: ' sortAssertions'
        Parameter
          Identifier: '_options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'CreationOptions'
        TypeReference
          Identifier: ' Transformer'
      FunctionDeclaration
        Identifier: ' unionCharacters'
        Parameter
          Identifier: 'options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'CreationOptions'
        TypeReference
          Identifier: ' Transformer'
      FunctionDeclaration
        Identifier: ' simplify'
        Parameter
          Identifier: 'options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'CreationOptions'
        TypeReference
          Identifier: ' CombinedTransformer'
  ModuleDeclaration
    ExportKeyword
    Identifier: ' FAIterators'
    ModuleBlock
      FunctionDeclaration
        Identifier: ' fromWords'
        TypeParameter
          Identifier: 'S'
        Parameter
          Identifier: '
		builder'
          TypeReference
            Identifier: ' FABuilder'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' CharSet'
        Parameter
          Identifier: '
		getOutState'
          FunctionType
            Parameter
              Identifier: 'state'
              TypeReference
                Identifier: ' S'
            Parameter
              Identifier: ' char'
              TypeReference
                Identifier: ' Char'
            UnionType
              TypeReference
                Identifier: ' S'
              UndefinedKeyword
        Parameter
          Identifier: '
		words'
          TypeReference
            Identifier: ' Iterable'
            TypeReference
              Identifier: 'ReadonlyWord'
        Parameter
          Identifier: '
		maxCharacter'
          TypeReference
            Identifier: ' Char'
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          TypeReference
            Identifier: ' S'
      FunctionDeclaration
        Identifier: ' fromWordSets'
        TypeParameter
          Identifier: 'S'
        Parameter
          Identifier: '
		builder'
          TypeReference
            Identifier: ' FABuilder'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' CharSet'
        Parameter
          Identifier: '
		wordSets'
          TypeReference
            Identifier: ' Iterable'
            TypeReference
              Identifier: 'ReadonlyWordSet'
        Parameter
          Identifier: '
		maxCharacter'
          TypeReference
            Identifier: ' Char'
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          TypeReference
            Identifier: ' S'
      FunctionDeclaration
        Identifier: ' intersection'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' L'
        TypeParameter
          Identifier: ' R'
        Parameter
          Identifier: '
		builder'
          TypeReference
            Identifier: ' FABuilder'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' CharSet'
        Parameter
          Identifier: '
		left'
          TypeReference
            Identifier: ' TransitionIterator'
            TypeReference
              Identifier: 'L'
        Parameter
          Identifier: '
		right'
          TypeReference
            Identifier: ' TransitionIterator'
            TypeReference
              Identifier: 'R'
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          TypeReference
            Identifier: ' S'
      FunctionDeclaration
        Identifier: ' withInitial'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' O'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' O'
        Parameter
          Identifier: ' initial'
          TypeReference
            Identifier: ' S'
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          TypeReference
            Identifier: ' O'
      FunctionDeclaration
        Identifier: ' withGetOut'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' O'
        TypeParameter
          Identifier: ' T'
        Parameter
          Identifier: '
		iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' O'
        Parameter
          Identifier: '
		getOut'
          FunctionType
            Parameter
              Identifier: 'state'
              TypeReference
                Identifier: ' S'
            TypeReference
              Identifier: ' T'
        Parameter
          Identifier: '
		stableOut'
          QuestionToken
          BooleanKeyword
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          TypeReference
            Identifier: ' T'
      FunctionDeclaration
        Identifier: ' withIsFinal'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' O'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' O'
        Parameter
          Identifier: ' isFinal'
          FunctionType
            Parameter
              Identifier: 'state'
              TypeReference
                Identifier: ' S'
            BooleanKeyword
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          TypeReference
            Identifier: ' O'
      FunctionDeclaration
        Identifier: ' mapOut'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' O'
        TypeParameter
          Identifier: ' T'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' O'
        Parameter
          Identifier: ' mapFn'
          FunctionType
            Parameter
              Identifier: 'out'
              TypeReference
                Identifier: ' O'
            TypeReference
              Identifier: ' T'
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          TypeReference
            Identifier: ' T'
      FunctionDeclaration
        Identifier: ' mapOutIter'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' O'
        TypeParameter
          Identifier: ' T'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' Iterable'
              TypeReference
                Identifier: 'O'
        Parameter
          Identifier: ' mapFn'
          FunctionType
            Parameter
              Identifier: 'out'
              TypeReference
                Identifier: ' O'
            TypeReference
              Identifier: ' T'
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          TypeReference
            Identifier: ' Iterable'
            TypeReference
              Identifier: 'T'
      FunctionDeclaration
        Identifier: ' filterOutIter'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' O'
        Parameter
          Identifier: '
		iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' Iterable'
              TypeReference
                Identifier: 'O'
        Parameter
          Identifier: '
		conditionFn'
          FunctionType
            Parameter
              Identifier: 'out'
              TypeReference
                Identifier: ' O'
            BooleanKeyword
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          TypeReference
            Identifier: ' Iterable'
            TypeReference
              Identifier: 'O'
      FunctionDeclaration
        Identifier: ' forEach'
        TypeParameter
          Identifier: 'S'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
        Parameter
          Identifier: ' consumerFn'
          QuestionToken
          FunctionType
            Parameter
              Identifier: 'state'
              TypeReference
                Identifier: ' S'
            VoidKeyword
        VoidKeyword
      FunctionDeclaration
        Identifier: ' count'
        TypeParameter
          Identifier: 'S'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
        NumberKeyword
      FunctionDeclaration
        Identifier: ' ensureStableOut'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' O'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' O'
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          TypeReference
            Identifier: ' O'
      FunctionDeclaration
        Identifier: ' iterateStates'
        TypeParameter
          Identifier: 'S'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'S'
      FunctionDeclaration
        Identifier: ' canReachFinal'
        TypeParameter
          Identifier: 'S'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
        BooleanKeyword
      FunctionDeclaration
        Identifier: ' hasCycle'
        TypeParameter
          Identifier: 'S'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
        BooleanKeyword
      FunctionDeclaration
        Identifier: ' languageIsFinite'
        TypeParameter
          Identifier: 'S'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
        BooleanKeyword
      FunctionDeclaration
        Identifier: ' makeInitialFinal'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' O'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' O'
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          TypeReference
            Identifier: ' O'
      FunctionDeclaration
        Identifier: ' makeInitialNonFinal'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' O'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' O'
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          TypeReference
            Identifier: ' O'
      FunctionDeclaration
        Identifier: ' shortestAcceptingPath'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' T'
        Parameter
          Identifier: '
		iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' Iterable'
              TypeReference
                Identifier: 'T'
        Parameter
          Identifier: '
		selectState'
          FunctionType
            Parameter
              Identifier: 'item'
              TypeReference
                Identifier: ' T'
            TypeReference
              Identifier: ' S'
        UnionType
          ArrayType
            TypeReference
              Identifier: ' T'
          UndefinedKeyword
      FunctionDeclaration
        Identifier: ' makeDeterministic'
        TypeParameter
          Identifier: 'B'
        TypeParameter
          Identifier: ' I'
        Parameter
          Identifier: '
		builder'
          TypeReference
            Identifier: ' FABuilder'
            TypeReference
              Identifier: 'B'
            TypeReference
              Identifier: ' CharSet'
        Parameter
          Identifier: '
		iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'I'
            TypeReference
              Identifier: ' Iterable'
              TupleType
                TypeReference
                  Identifier: 'I'
                TypeReference
                  Identifier: ' CharSet'
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'B'
          TypeReference
            Identifier: ' B'
      ClassDeclaration
        Identifier: ' MapFABuilder'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' FABuilder'
            TypeReference
              Identifier: 'MapFABuilderNode'
            TypeReference
              Identifier: ' CharSet'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' initial'
          TypeReference
            Identifier: ' MapFABuilderNode'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' finals'
          TypeReference
            Identifier: ' Set'
            TypeReference
              Identifier: 'MapFABuilderNode'
        Constructor
          Parameter
            Identifier: 'maxNodes'
            QuestionToken
            NumberKeyword
        MethodDeclaration
          Identifier: '
		makeFinal'
          Parameter
            Identifier: 'state'
            TypeReference
              Identifier: ' MapFABuilderNode'
          VoidKeyword
        MethodDeclaration
          Identifier: '
		isFinal'
          Parameter
            Identifier: 'state'
            TypeReference
              Identifier: ' MapFABuilderNode'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		createNode'
          TypeReference
            Identifier: ' MapFABuilderNode'
        MethodDeclaration
          Identifier: '
		linkNodes'
          Parameter
            Identifier: 'from'
            TypeReference
              Identifier: ' MapFABuilderNode'
          Parameter
            Identifier: ' to'
            TypeReference
              Identifier: ' MapFABuilderNode'
          Parameter
            Identifier: ' transition'
            TypeReference
              Identifier: ' CharSet'
          VoidKeyword
      TypeAliasDeclaration
        Identifier: ' MapFABuilderNode'
        TypeReference
          Identifier: ' Map'
          TypeReference
            Identifier: 'MapFABuilderNode'
          TypeReference
            Identifier: ' CharSet'
      FunctionDeclaration
        Identifier: ' removeDeadStates'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' O'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' Iterable'
              TypeReference
                Identifier: 'O'
        Parameter
          Identifier: ' select'
          FunctionType
            Parameter
              Identifier: 'item'
              TypeReference
                Identifier: ' O'
            TypeReference
              Identifier: ' S'
        TypeReference
          Identifier: ' FAIterator'
          TypeReference
            Identifier: 'S'
          ArrayType
            TypeReference
              Identifier: ' O'
      FunctionDeclaration
        Identifier: ' toDot'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' T'
        Parameter
          Identifier: '
		iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' Iterable'
              TupleType
                TypeReference
                  Identifier: 'S'
                TypeReference
                  Identifier: ' T'
        Parameter
          Identifier: '
		options'
          UnionType
            TypeReference
              Identifier: ' ToDotOptions'
              TypeReference
                Identifier: 'S'
              TypeReference
                Identifier: ' T'
            TypeReference
              Identifier: ' SimplePrintOptions'
              TypeReference
                Identifier: 'T'
        StringKeyword
      TypeAliasDeclaration
        Identifier: ' ToDotAttrs'
        TypeReference
          Identifier: ' Record'
          StringKeyword
          UnionType
            StringKeyword
            NumberKeyword
            UndefinedKeyword
      InterfaceDeclaration
        Identifier: ' ToDotOptions'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' T'
        PropertySignature
          Identifier: '
		getEdgeAttributes'
          FunctionType
            Parameter
              Identifier: 'transition'
              TypeReference
                Identifier: ' T'
            Parameter
              Identifier: ' nth'
              NumberKeyword
            Parameter
              Identifier: ' from'
              TypeReference
                Identifier: ' S'
            Parameter
              Identifier: ' to'
              TypeReference
                Identifier: ' S'
            Parameter
              Identifier: ' info'
              TypeReference
                Identifier: ' NodeInfo'
                TypeReference
                  Identifier: 'S'
            TypeReference
              Identifier: ' Readonly'
              TypeReference
                Identifier: 'ToDotAttrs'
        PropertySignature
          Identifier: '
		getGraphAttributes'
          QuestionToken
          FunctionType
            TypeReference
              Identifier: ' Readonly'
              TypeReference
                Identifier: 'ToDotAttrs'
        PropertySignature
          Identifier: '
		getNodeAttributes'
          QuestionToken
          FunctionType
            Parameter
              Identifier: 'node'
              TypeReference
                Identifier: ' S'
            Parameter
              Identifier: ' info'
              TypeReference
                Identifier: ' NodeInfo'
                TypeReference
                  Identifier: 'S'
            TypeReference
              Identifier: ' Readonly'
              TypeReference
                Identifier: 'ToDotAttrs'
      FunctionDeclaration
        Identifier: ' toMermaid'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' T'
        Parameter
          Identifier: '
		iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' Iterable'
              TupleType
                TypeReference
                  Identifier: 'S'
                TypeReference
                  Identifier: ' T'
        Parameter
          Identifier: '
		options'
          UnionType
            TypeReference
              Identifier: ' ToMermaidOptions'
              TypeReference
                Identifier: 'S'
              TypeReference
                Identifier: ' T'
            TypeReference
              Identifier: ' SimplePrintOptions'
              TypeReference
                Identifier: 'T'
        StringKeyword
      InterfaceDeclaration
        Identifier: ' ToMermaidOptions'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' T'
        PropertySignature
          Identifier: '
		getNodeAttributes'
          QuestionToken
          FunctionType
            Parameter
              Identifier: 'node'
              TypeReference
                Identifier: ' S'
            Parameter
              Identifier: ' info'
              TypeReference
                Identifier: ' NodeInfo'
                TypeReference
                  Identifier: 'S'
            TypeReference
              Identifier: ' Readonly'
              TypeReference
                Identifier: 'MermaidNode'
        PropertySignature
          Identifier: '
		getEdgeAttributes'
          FunctionType
            Parameter
              Identifier: 'transition'
              TypeReference
                Identifier: ' T'
            Parameter
              Identifier: ' nth'
              NumberKeyword
            Parameter
              Identifier: ' from'
              TypeReference
                Identifier: ' S'
            Parameter
              Identifier: ' to'
              TypeReference
                Identifier: ' S'
            Parameter
              Identifier: ' info'
              TypeReference
                Identifier: ' NodeInfo'
                TypeReference
                  Identifier: 'S'
            TypeReference
              Identifier: ' MermaidEdge'
      InterfaceDeclaration
        Identifier: ' MermaidNode'
        PropertySignature
          Identifier: '
		label'
          StringKeyword
        PropertySignature
          Identifier: '
		shape'
          TupleType
            StringKeyword
            StringKeyword
      InterfaceDeclaration
        Identifier: ' MermaidEdge'
        PropertySignature
          Identifier: '
		label'
          QuestionToken
          StringKeyword
        PropertySignature
          Identifier: '
		length'
          QuestionToken
          NumberKeyword
      InterfaceDeclaration
        Identifier: ' NodeInfo'
        TypeParameter
          Identifier: 'S'
        MethodSignature
          Identifier: '
		isInitial'
          Parameter
            Identifier: 'node'
            TypeReference
              Identifier: ' S'
          BooleanKeyword
        MethodSignature
          Identifier: '
		isFinal'
          Parameter
            Identifier: 'node'
            TypeReference
              Identifier: ' S'
          BooleanKeyword
        MethodSignature
          Identifier: '
		getId'
          Parameter
            Identifier: 'node'
            TypeReference
              Identifier: ' S'
          NumberKeyword
        MethodSignature
          Identifier: '
		getNumberOfOutgoingEdges'
          Parameter
            Identifier: 'node'
            TypeReference
              Identifier: ' S'
          NumberKeyword
      InterfaceDeclaration
        Identifier: ' SimplePrintOptions'
        TypeParameter
          Identifier: 'T'
        PropertySignature
          Identifier: '
		/**
		 * Returns the string representation of the given transition.
		 *
		 * @param transition
		 * @returns
		 */
		transitionToString'
          FunctionType
            Parameter
              Identifier: 'transition'
              TypeReference
                Identifier: ' T'
            StringKeyword
        PropertySignature
          Identifier: '
		/**
		 * Whether transitions are ordered.
		 *
		 * @default false
		 */
		ordered'
          QuestionToken
          BooleanKeyword
      FunctionDeclaration
        Identifier: ' toRegex'
        TypeParameter
          Identifier: 'S'
        Parameter
          Identifier: '
		iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' Iterable'
              TupleType
                TypeReference
                  Identifier: 'S'
                UnionType
                  TypeReference
                    Identifier: ' CharSet'
                  LiteralType
                    NullKeyword
        Parameter
          Identifier: '
		options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'ToRegexOptions'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Expression'
      FunctionDeclaration
        Identifier: ' toString'
        TypeParameter
          Identifier: 'S'
        TypeParameter
          Identifier: ' T'
        Parameter
          Identifier: '
		iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' Iterable'
              TupleType
                TypeReference
                  Identifier: 'S'
                TypeReference
                  Identifier: ' T'
        Parameter
          Identifier: '
		toString'
          QuestionToken
          FunctionType
            Parameter
              Identifier: 'value'
              TypeReference
                Identifier: ' T'
            StringKeyword
        Parameter
          Identifier: '
		ordered'
          QuestionToken
          BooleanKeyword
        StringKeyword
      FunctionDeclaration
        Identifier: ' iterateWordSets'
        TypeParameter
          Identifier: 'S'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' Iterable'
              TupleType
                TypeReference
                  Identifier: 'S'
                TypeReference
                  Identifier: ' CharSet'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'WordSet'
      FunctionDeclaration
        Identifier: ' shortestWordSet'
        TypeParameter
          Identifier: 'S'
        Parameter
          Identifier: 'iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' Iterable'
              TupleType
                TypeReference
                  Identifier: 'S'
                TypeReference
                  Identifier: ' CharSet'
        UnionType
          TypeReference
            Identifier: ' WordSet'
          UndefinedKeyword
      FunctionDeclaration
        Identifier: ' approximateRejectingWordSet'
        TypeParameter
          Identifier: 'S'
        Parameter
          Identifier: '
		iter'
          TypeReference
            Identifier: ' FAIterator'
            TypeReference
              Identifier: 'S'
            TypeReference
              Identifier: ' Iterable'
              TupleType
                TypeReference
                  Identifier: 'S'
                TypeReference
                  Identifier: ' CharSet'
        Parameter
          Identifier: '
		inputCharacters'
          TypeReference
            Identifier: ' CharSet'
        UnionType
          TypeReference
            Identifier: ' WordSet'
          UndefinedKeyword
  ModuleDeclaration
    ExportKeyword
    Identifier: ' JS'
    ModuleBlock
      TypeAliasDeclaration
        Identifier: ' BoundaryAssertion'
        UnionType
          TypeReference
            Identifier: ' WordBoundaryAssertion'
          TypeReference
            Identifier: ' TextBoundaryAssertion'
      InterfaceDeclaration
        Identifier: ' WordBoundaryAssertion'
        PropertySignature
          Identifier: '
		kind'
          LiteralType
            StringLiteral
        PropertySignature
          Identifier: '
		negate'
          BooleanKeyword
      InterfaceDeclaration
        Identifier: ' TextBoundaryAssertion'
        PropertySignature
          Identifier: '
		kind'
          UnionType
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
      FunctionDeclaration
        Identifier: ' createAssertion'
        Parameter
          Identifier: 'assertion'
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'BoundaryAssertion'
        Parameter
          Identifier: ' flags'
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'Flags'
        TypeReference
          Identifier: ' NoParent'
          TypeReference
            Identifier: 'Element'
      TypeAliasDeclaration
        Identifier: ' PredefinedCharacterSet'
        UnionType
          TypeReference
            Identifier: ' AnyCharacterSet'
          TypeReference
            Identifier: ' DigitCharacterSet'
          TypeReference
            Identifier: ' PropertyCharacterSet'
          TypeReference
            Identifier: ' SpaceCharacterSet'
          TypeReference
            Identifier: ' WordCharacterSet'
      InterfaceDeclaration
        Identifier: ' AnyCharacterSet'
        PropertySignature
          Identifier: '
		kind'
          LiteralType
            StringLiteral
      InterfaceDeclaration
        Identifier: ' DigitCharacterSet'
        PropertySignature
          Identifier: '
		kind'
          LiteralType
            StringLiteral
        PropertySignature
          Identifier: '
		negate'
          BooleanKeyword
      TypeAliasDeclaration
        Identifier: ' PropertyCharacterSet'
        UnionType
          TypeReference
            Identifier: ' CharacterPropertyCharacterSet'
          TypeReference
            Identifier: ' StringPropertyCharacterSet'
      InterfaceDeclaration
        Identifier: ' CharacterPropertyCharacterSet'
        PropertySignature
          Identifier: '
		kind'
          LiteralType
            StringLiteral
        PropertySignature
          Identifier: '
		key'
          StringKeyword
        PropertySignature
          Identifier: '
		value'
          UnionType
            StringKeyword
            LiteralType
              NullKeyword
        PropertySignature
          Identifier: '
		strings'
          LiteralType
            FalseKeyword
        PropertySignature
          Identifier: '
		negate'
          BooleanKeyword
      InterfaceDeclaration
        Identifier: ' StringPropertyCharacterSet'
        PropertySignature
          Identifier: '
		kind'
          LiteralType
            StringLiteral
        PropertySignature
          Identifier: '
		key'
          StringKeyword
        PropertySignature
          Identifier: '
		value'
          LiteralType
            NullKeyword
        PropertySignature
          Identifier: '
		strings'
          LiteralType
            TrueKeyword
        PropertySignature
          Identifier: '
		negate'
          LiteralType
            FalseKeyword
      InterfaceDeclaration
        Identifier: ' SpaceCharacterSet'
        PropertySignature
          Identifier: '
		kind'
          LiteralType
            StringLiteral
        PropertySignature
          Identifier: '
		negate'
          BooleanKeyword
      InterfaceDeclaration
        Identifier: ' WordCharacterSet'
        PropertySignature
          Identifier: '
		kind'
          LiteralType
            StringLiteral
        PropertySignature
          Identifier: '
		negate'
          BooleanKeyword
      FunctionDeclaration
        Identifier: ' createCharSet'
        Parameter
          Identifier: '
		chars'
          TypeReference
            Identifier: ' Iterable'
            UnionType
              TypeReference
                Identifier: 'Char'
              TypeReference
                Identifier: ' CharRange'
              TypeReference
                Identifier: ' Readonly'
                TypeReference
                  Identifier: 'Exclude'
                  TypeReference
                    Identifier: 'PredefinedCharacterSet'
                  TypeReference
                    Identifier: ' StringPropertyCharacterSet'
        Parameter
          Identifier: '
		flags'
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'Flags'
        TypeReference
          Identifier: ' CharSet'
      InterfaceDeclaration
        Identifier: ' ToLiteralOptions'
        PropertySignature
          Identifier: '
		/**
		 * An optional template for the flags of the JavaScript RegExp literal to be created.
		 *
		 * All flags that are set to `false` are guaranteed to be disabled in the created literal. Likewise, all flags that
		 * are set to `true` are guaranteed to be enabled in the created literal.
		 *
		 * Flags that are `undefined` will be enabled/disabled depending on the implementation. While no guarantees are
		 * given, the implementation will generally try to choose flags such that it can create a literal that is as
		 * small/simple as possible.
		 *
		 * If the constraints on flags defined here make it impossible to create a literal, an error will be thrown.
		 */
		flags'
          QuestionToken
          TypeReference
            Identifier: ' Flags'
        PropertySignature
          Identifier: '
		/**
		 * This will force the function to print characters as fast as possible.
		 *
		 * Literals created with this option will usually be created about 10x faster but the result will usually be very
		 * hard to read. The is option is intended to provide performance benefits when readability is not a concern.
		 *
		 * @default false
		 */
		fastCharacters'
          QuestionToken
          BooleanKeyword
      FunctionDeclaration
        Identifier: ' toLiteral'
        Parameter
          Identifier: 'node'
          TypeReference
            Identifier: ' NoParent'
            TypeReference
              Identifier: 'Node'
        Parameter
          Identifier: ' options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'ToLiteralOptions'
        TypeReference
          Identifier: ' Literal'
      FunctionDeclaration
        Identifier: ' toLiteral'
        Parameter
          Identifier: 'alternatives'
          TypeOperator
            ArrayType
              TypeReference
                Identifier: ' NoParent'
                TypeReference
                  Identifier: 'Concatenation'
        Parameter
          Identifier: ' options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'ToLiteralOptions'
        TypeReference
          Identifier: ' Literal'
      InterfaceDeclaration
        Identifier: ' UncheckedFlags'
        PropertySignature
          Identifier: '
		/** @default false */
		dotAll'
          QuestionToken
          BooleanKeyword
        PropertySignature
          Identifier: '
		/** @default false */
		global'
          QuestionToken
          BooleanKeyword
        PropertySignature
          Identifier: '
		/** @default false */
		hasIndices'
          QuestionToken
          BooleanKeyword
        PropertySignature
          Identifier: '
		/** @default false */
		ignoreCase'
          QuestionToken
          BooleanKeyword
        PropertySignature
          Identifier: '
		/** @default false */
		multiline'
          QuestionToken
          BooleanKeyword
        PropertySignature
          Identifier: '
		/** @default false */
		sticky'
          QuestionToken
          BooleanKeyword
        PropertySignature
          Identifier: '
		/** @default false */
		unicode'
          QuestionToken
          BooleanKeyword
        PropertySignature
          Identifier: '
		/** @default false */
		unicodeSets'
          QuestionToken
          BooleanKeyword
      FunctionDeclaration
        Identifier: ' isFlags'
        Parameter
          Identifier: 'flags'
          TypeReference
            Identifier: ' UncheckedFlags'
        TypePredicate
          Identifier: ' flags'
          TypeReference
            Identifier: ' Flags'
      InterfaceDeclaration
        Identifier: ' NonUnicodeSetsFlags'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' UncheckedFlags'
        PropertySignature
          Identifier: '
		/** @default false */
		unicode'
          QuestionToken
          BooleanKeyword
        PropertySignature
          Identifier: '
		/** @default false */
		unicodeSets'
          QuestionToken
          LiteralType
            FalseKeyword
      InterfaceDeclaration
        Identifier: ' UnicodeSetsFlags'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' UncheckedFlags'
        PropertySignature
          Identifier: '
		/** @default false */
		unicode'
          QuestionToken
          LiteralType
            FalseKeyword
        PropertySignature
          Identifier: '
		/** @default false */
		unicodeSets'
          LiteralType
            TrueKeyword
      TypeAliasDeclaration
        Identifier: ' Flags'
        UnionType
          TypeReference
            Identifier: ' NonUnicodeSetsFlags'
          TypeReference
            Identifier: ' UnicodeSetsFlags'
      InterfaceDeclaration
        Identifier: ' Literal'
        PropertySignature
          ReadonlyKeyword
          Identifier: ' source'
          StringKeyword
        PropertySignature
          ReadonlyKeyword
          Identifier: ' flags'
          StringKeyword
      InterfaceDeclaration
        Identifier: ' ParseOptions'
        PropertySignature
          Identifier: '
		/**
		 * The maximum number of words a backreference can be replaced by.
		 *
		 * Set this to 0 to disable resolving backreferences.
		 *
		 * @default 100
		 */
		maxBackreferenceWords'
          QuestionToken
          NumberKeyword
        PropertySignature
          Identifier: '
		/**
		 * How to the parser will handle unresolved backreferences.
		 *
		 * - `"disable"`
		 *
		 *   The parser will replace all backreferences with an empty character class. This will cause all paths containing
		 *   a backreference to be (effectively) removed.
		 *
		 *   E.g. `(a*)(\1|b)` will be parsed as `(a*)(([])|b)` which is equivalent to `a*b`.
		 *
		 * - `"throw"`
		 *
		 *   The parser will throw an error when encountering a backreference that cannot be removed.
		 *
		 *   E.g. `(a*)b\1` will throw but `(a*)[^\s\S]\1` will not because the backreference will be removed anyway because
		 *   of the empty character class.
		 *
		 * - `"unknown"`
		 *
		 *   The parser will create a `Unknown` node for each backreference that cannot be removed. The id of the node will
		 *   be raw string of the backreference.
		 *
		 * Backreferences that have been resolved are not affected by this option.
		 *
		 * @default "throw"
		 */
		backreferences'
          QuestionToken
          UnionType
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
        PropertySignature
          Identifier: '
		/**
		 * How the parser will handle assertions.
		 *
		 * - `"parse"`
		 *
		 *   The parser will translate every assertion literally to an equivalent RE AST representation. Builtin assertions
		 *   (e.g. `\b`, `$`) will be transformed into equivalent assertions.
		 *
		 * - `"disable"`
		 *
		 *   The parser will disable all assertion by replacing them with an empty character class. This will cause all
		 *   paths containing an assertion to be (effectively) removed.
		 *
		 * - `"ignore"`
		 *
		 *   The parser will ignore all assertion by replacing them with an empty group.
		 *
		 * - `"throw"`
		 *
		 *   The parser will throw an error when encountering a assertion that cannot be removed.
		 *
		 *   E.g. `a\B` will throw but `a([]\b)(\b){0}` will not because none of the `\b`s can be reached.
		 *
		 * - `"unknown"`
		 *
		 *   The parser will create a `Unknown` node for each assertion. The id of the node will be raw string of the
		 *   assertion.
		 *
		 * @default "parse"
		 */
		assertions'
          QuestionToken
          UnionType
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
            LiteralType
              StringLiteral
        PropertySignature
          Identifier: '
		/**
		 * By default, the parser will try to simplify the generated RE as much as possible.
		 *
		 * If set to `false`, all trivial simplifications will be disabled. This includes:
		 *
		 * - Removing alternatives where all paths go through an empty character class, an alternation with 0 alternatives,
		 *   or a disabled backreference/assertion.
		 * - Removing constant 0 and constant 1 quantifiers.
		 * - Inlining single-alternative groups.
		 *
		 * These simplifications might prevent certain backreferences or assertions from throwing an error. It's usually
		 * good to have them enabled since parsing is usually faster and the produced RE AST is smaller.
		 *
		 * If the produced RE AST is supposed to be a literal translation, then simplifications have to be disabled.
		 *
		 * @default true
		 */
		simplify'
          QuestionToken
          BooleanKeyword
        PropertySignature
          Identifier: '
		/**
		 * The maximum number of nodes the parser is allowed to create.
		 *
		 * If the regexes requires more nodes, a {@link TooManyNodesError} will be thrown.
		 *
		 * @default 10000
		 */
		maxNodes'
          QuestionToken
          NumberKeyword
        PropertySignature
          Identifier: '
		/**
		 * `Unknown` nodes have an `id` property that can be used to identify the element that created the unknown. This
		 * function can be used to control the `id` value.
		 *
		 * By default, the raw of the element will be used as its id.
		 */
		getUnknownId'
          QuestionToken
          FunctionType
            Parameter
              Identifier: 'element'
              UnionType
                TypeReference
                  QualifiedName
                    Identifier: ' AST'
                    Identifier: 'Backreference'
                TypeReference
                  QualifiedName
                    Identifier: ' AST'
                    Identifier: 'Assertion'
            StringKeyword
      InterfaceDeclaration
        Identifier: ' RegexppAst'
        PropertySignature
          ReadonlyKeyword
          Identifier: ' pattern'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Pattern'
        PropertySignature
          ReadonlyKeyword
          Identifier: ' flags'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Flags'
      TypeAliasDeclaration
        Identifier: ' ParsableElement'
        UnionType
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Element'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Pattern'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Alternative'
      InterfaceDeclaration
        Identifier: ' ParseResult'
        PropertySignature
          Identifier: '
		expression'
          TypeReference
            Identifier: ' Expression'
        PropertySignature
          Identifier: '
		maxCharacter'
          TypeReference
            Identifier: ' Char'
      ClassDeclaration
        Identifier: ' Parser'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' literal'
          TypeReference
            Identifier: ' Literal'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' ast'
          TypeReference
            Identifier: ' RegexppAst'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' flags'
          TypeReference
            Identifier: ' Required'
            TypeReference
              Identifier: 'Flags'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' maxCharacter'
          TypeReference
            Identifier: ' Char'
        MethodDeclaration
          StaticKeyword
          Identifier: ' fromLiteral'
          Parameter
            Identifier: 'literal'
            UnionType
              TypeReference
                Identifier: ' Literal'
              StringKeyword
          Parameter
            Identifier: ' parserOptions'
            QuestionToken
            TypeReference
              QualifiedName
                Identifier: ' RegExpParser'
                Identifier: 'Options'
          TypeReference
            Identifier: ' Parser'
        MethodDeclaration
          StaticKeyword
          Identifier: ' fromAst'
          Parameter
            Identifier: 'ast'
            TypeReference
              Identifier: ' RegexppAst'
          TypeReference
            Identifier: ' Parser'
        MethodDeclaration
          Identifier: '
		/**
		 * Parsed the entire literal.
		 *
		 * For more information on parsing, see {@link parseElement}.
		 *
		 * @param options
		 */
		parse'
          Parameter
            Identifier: 'options'
            QuestionToken
            TypeReference
              Identifier: ' Readonly'
              TypeReference
                Identifier: 'ParseOptions'
          TypeReference
            Identifier: ' ParseResult'
        MethodDeclaration
          Identifier: '
		/**
		 * Parses a specific element of the literal.
		 *
		 * Use {@link ParseOptions} to control how the element is parsed.
		 *
		 * @param element
		 * @param options
		 */
		parseElement'
          Parameter
            Identifier: 'element'
            TypeReference
              Identifier: ' ParsableElement'
          Parameter
            Identifier: ' options'
            QuestionToken
            TypeReference
              Identifier: ' Readonly'
              TypeReference
                Identifier: 'ParseOptions'
          TypeReference
            Identifier: ' ParseResult'
      TypeAliasDeclaration
        Identifier: ' CharacterElement'
        UnionType
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'CharacterClass'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Character'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'CharacterClassRange'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'CharacterSet'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'ClassSetOperand'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'StringAlternative'
          IndexedAccessType
            TypeReference
              QualifiedName
                Identifier: ' AST'
                Identifier: 'ExpressionCharacterClass'
            LiteralType
              StringLiteral
      FunctionDeclaration
        Identifier: ' parseUnicodeSet'
        Parameter
          Identifier: 'element'
          TypeReference
            Identifier: ' CharacterElement'
        Parameter
          Identifier: ' flags'
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'Flags'
        TypeReference
          Identifier: ' UnicodeSet'
      FunctionDeclaration
        Identifier: ' parseCharSet'
        Parameter
          Identifier: '
		element'
          UnionType
            TypeReference
              QualifiedName
                Identifier: ' AST'
                Identifier: 'ClassRangesCharacterClass'
            TypeReference
              QualifiedName
                Identifier: ' AST'
                Identifier: 'Character'
            TypeReference
              QualifiedName
                Identifier: ' AST'
                Identifier: 'CharacterClassRange'
            TypeReference
              Identifier: ' Exclude'
              TypeReference
                QualifiedName
                  Identifier: 'AST'
                  Identifier: 'CharacterSet'
              TypeReference
                QualifiedName
                  Identifier: ' AST'
                  Identifier: 'StringsUnicodePropertyCharacterSet'
        Parameter
          Identifier: '
		flags'
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'Flags'
        TypeReference
          Identifier: ' CharSet'
      ClassDeclaration
        Identifier: ' StringSet'
        GetAccessor
          Identifier: ' isEmpty'
          BooleanKeyword
        GetAccessor
          Identifier: ' hasEmptyWord'
          BooleanKeyword
        GetAccessor
          Identifier: ' hasSingleCharacter'
          BooleanKeyword
        GetAccessor
          Identifier: ' wordSets'
          TypeOperator
            ArrayType
              TypeReference
                Identifier: ' ReadonlyWordSet'
        PropertyDeclaration
          StaticKeyword
          ReadonlyKeyword
          Identifier: ' empty'
          TypeReference
            Identifier: ' StringSet'
        MethodDeclaration
          StaticKeyword
          Identifier: ' from'
          Parameter
            Identifier: 'words'
            TypeReference
              Identifier: ' Iterable'
              TypeReference
                Identifier: 'ReadonlyWord'
          Parameter
            Identifier: ' caseFolding'
            TypeReference
              Identifier: ' CharCaseFolding'
          TypeReference
            Identifier: ' StringSet'
        MethodDeclaration
          StaticKeyword
          Identifier: ' fromWord'
          Parameter
            Identifier: 'word'
            TypeReference
              Identifier: ' ReadonlyWord'
          Parameter
            Identifier: ' caseFolding'
            TypeReference
              Identifier: ' CharCaseFolding'
          TypeReference
            Identifier: ' StringSet'
        MethodDeclaration
          Identifier: '
		/**
		 * Returns whether this set is compatible with the given set. Compatibility is defined as follows:
		 *
		 * 1. The empty set is compatible with all sets.
		 * 2. Sets with different case folding are incompatible.
		 *
		 * @param other
		 */
		isCompatibleWith'
          Parameter
            Identifier: 'other'
            TypeReference
              Identifier: ' StringSet'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Returns whether this set is equal to the given set.
		 *
		 * Equality is defined as the `wordSets` of both sets being the same formal language.
		 *
		 * @param other
		 */
		equals'
          Parameter
            Identifier: 'other'
            TypeReference
              Identifier: ' StringSet'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Returns the union of all given sets.
		 *
		 * Note: This operation is only allowed if all sets are compatible.
		 *
		 * @param others
		 */
		union'
          Parameter
            DotDotDotToken
            Identifier: 'others'
            ArrayType
              TypeReference
                Identifier: ' StringSet'
          TypeReference
            Identifier: ' StringSet'
        MethodDeclaration
          Identifier: '
		/**
		 * Returns the intersection of this set and the given set.
		 *
		 * Note: This operation is only allowed if all sets are compatible.
		 *
		 * @param other
		 */
		intersect'
          Parameter
            Identifier: 'other'
            TypeReference
              Identifier: ' StringSet'
          TypeReference
            Identifier: ' StringSet'
        MethodDeclaration
          Identifier: '
		/**
		 * Returns this set without the strings of the given set.
		 *
		 * Note: This operation is only allowed if all sets are compatible.
		 *
		 * @param other
		 */
		without'
          Parameter
            Identifier: 'other'
            TypeReference
              Identifier: ' StringSet'
          TypeReference
            Identifier: ' StringSet'
        MethodDeclaration
          Identifier: '
		/**
		 * Returns whether `this ⊇ other`.
		 *
		 * @param other
		 */
		isSupersetOf'
          Parameter
            Identifier: 'other'
            TypeReference
              Identifier: ' StringSet'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Returns whether `this ⊆ other`.
		 *
		 * @param other
		 */
		isSubsetOf'
          Parameter
            Identifier: 'other'
            TypeReference
              Identifier: ' StringSet'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Returns whether `this ⊃ other`.
		 *
		 * @param other
		 */
		isProperSupersetOf'
          Parameter
            Identifier: 'other'
            TypeReference
              Identifier: ' StringSet'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Returns whether `this ⊂ other`.
		 *
		 * @param other
		 */
		isProperSubsetOf'
          Parameter
            Identifier: 'other'
            TypeReference
              Identifier: ' StringSet'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		isDisjointWith'
          Parameter
            Identifier: 'other'
            TypeReference
              Identifier: ' StringSet'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Returns a set of all single-character words in this set or `undefined` if this set contains no single-character
		 * words.
		 */
		getSingleCharacters'
          UnionType
            TypeReference
              Identifier: ' CharSet'
            UndefinedKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Removes all single-character words from this set.
		 */
		withoutSingleCharacters'
          TypeReference
            Identifier: ' StringSet'
        MethodDeclaration
          Identifier: '
		/**
		 * Removes the empty word from this set.
		 */
		withoutEmptyWord'
          TypeReference
            Identifier: ' StringSet'
        MethodDeclaration
          Identifier: '
		/**
		 * Returns the minimum and maximum length of words in this set.
		 *
		 * If this set is empty, `undefined` will be returned returned.
		 */
		getLengthRange'
          UnionType
            TypeLiteral
              PropertySignature
                Identifier: '
					min'
                NumberKeyword
              PropertySignature
                Identifier: '
					max'
                NumberKeyword
            UndefinedKeyword
      ClassDeclaration
        Identifier: ' UnicodeSet'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' chars'
          TypeReference
            Identifier: ' CharSet'
        PropertyDeclaration
          ReadonlyKeyword
          Identifier: ' accept'
          TypeReference
            Identifier: ' StringSet'
        GetAccessor
          Identifier: ' maximum'
          TypeReference
            Identifier: ' Char'
        GetAccessor
          Identifier: ' isEmpty'
          BooleanKeyword
        GetAccessor
          Identifier: ' hasEmptyWord'
          BooleanKeyword
        GetAccessor
          Identifier: ' wordSets'
          TypeOperator
            ArrayType
              TypeReference
                Identifier: ' ReadonlyWordSet'
        MethodDeclaration
          StaticKeyword
          Identifier: ' empty'
          Parameter
            Identifier: 'maximum'
            TypeReference
              Identifier: ' Char'
          TypeReference
            Identifier: ' UnicodeSet'
        MethodDeclaration
          StaticKeyword
          Identifier: ' fromChars'
          Parameter
            Identifier: 'chars'
            TypeReference
              Identifier: ' CharSet'
          TypeReference
            Identifier: ' UnicodeSet'
        MethodDeclaration
          StaticKeyword
          Identifier: ' from'
          Parameter
            Identifier: 'chars'
            TypeReference
              Identifier: ' CharSet'
          Parameter
            Identifier: ' accept'
            TypeReference
              Identifier: ' StringSet'
          TypeReference
            Identifier: ' UnicodeSet'
        MethodDeclaration
          Identifier: '
		/**
		 * Returns whether this set and the other set contain the same formal language.
		 *
		 * @param other
		 */
		equals'
          Parameter
            Identifier: 'other'
            UnionType
              TypeReference
                Identifier: ' UnicodeSet'
              TypeReference
                Identifier: ' CharSet'
              TypeReference
                Identifier: ' CharRange'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		isCompatibleWith'
          Parameter
            Identifier: 'other'
            TypeReference
              Identifier: ' UnicodeSet'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		union'
          Parameter
            DotDotDotToken
            Identifier: 'others'
            ArrayType
              ParenthesizedType
                UnionType
                  TypeReference
                    Identifier: 'UnicodeSet'
                  TypeReference
                    Identifier: ' CharSet'
          TypeReference
            Identifier: ' UnicodeSet'
        MethodDeclaration
          Identifier: '
		intersect'
          Parameter
            Identifier: 'other'
            UnionType
              TypeReference
                Identifier: ' UnicodeSet'
              TypeReference
                Identifier: ' CharSet'
              TypeReference
                Identifier: ' CharRange'
          TypeReference
            Identifier: ' UnicodeSet'
        MethodDeclaration
          Identifier: '
		without'
          Parameter
            Identifier: 'other'
            UnionType
              TypeReference
                Identifier: ' UnicodeSet'
              TypeReference
                Identifier: ' CharSet'
              TypeReference
                Identifier: ' CharRange'
          TypeReference
            Identifier: ' UnicodeSet'
        MethodDeclaration
          Identifier: '
		/**
		 * Returns whether `this ⊇ other`.
		 *
		 * @param other
		 */
		isSupersetOf'
          Parameter
            Identifier: 'other'
            UnionType
              TypeReference
                Identifier: ' UnicodeSet'
              TypeReference
                Identifier: ' CharSet'
              TypeReference
                Identifier: ' CharRange'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Returns whether `this ⊆ other`.
		 *
		 * @param other
		 */
		isSubsetOf'
          Parameter
            Identifier: 'other'
            UnionType
              TypeReference
                Identifier: ' UnicodeSet'
              TypeReference
                Identifier: ' CharSet'
              TypeReference
                Identifier: ' CharRange'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Returns whether `this ⊃ other`.
		 *
		 * @param other
		 */
		isProperSupersetOf'
          Parameter
            Identifier: 'other'
            UnionType
              TypeReference
                Identifier: ' UnicodeSet'
              TypeReference
                Identifier: ' CharSet'
              TypeReference
                Identifier: ' CharRange'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Returns whether `this ⊂ other`.
		 *
		 * @param other
		 */
		isProperSubsetOf'
          Parameter
            Identifier: 'other'
            UnionType
              TypeReference
                Identifier: ' UnicodeSet'
              TypeReference
                Identifier: ' CharSet'
              TypeReference
                Identifier: ' CharRange'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		isDisjointWith'
          Parameter
            Identifier: 'other'
            UnionType
              TypeReference
                Identifier: ' UnicodeSet'
              TypeReference
                Identifier: ' CharSet'
              TypeReference
                Identifier: ' CharRange'
          BooleanKeyword
        MethodDeclaration
          Identifier: '
		/**
		 * Returns the minimum and maximum length of words in this set.
		 *
		 * If this set is empty, `undefined` will be returned returned.
		 */
		getLengthRange'
          UnionType
            TypeLiteral
              PropertySignature
                Identifier: '
					min'
                NumberKeyword
              PropertySignature
                Identifier: '
					max'
                NumberKeyword
            UndefinedKeyword
      InterfaceDeclaration
        Identifier: ' CharCaseFolding'
        PropertySignature
          ReadonlyKeyword
          Identifier: ' canonicalize'
          QuestionToken
          FunctionType
            Parameter
              Identifier: 'char'
              TypeReference
                Identifier: ' Char'
            TypeReference
              Identifier: ' Char'
        PropertySignature
          ReadonlyKeyword
          Identifier: ' toCharSet'
          FunctionType
            Parameter
              Identifier: 'char'
              TypeReference
                Identifier: ' Char'
            TypeReference
              Identifier: ' CharSet'
      FunctionDeclaration
        Identifier: ' getCharCaseFolding'
        Parameter
          Identifier: 'unicode'
          BooleanKeyword
        Parameter
          Identifier: ' ignoreCase'
          BooleanKeyword
        TypeReference
          Identifier: ' CharCaseFolding'
      FunctionDeclaration
        Identifier: ' getCharCaseFolding'
        Parameter
          Identifier: 'flags'
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'Flags'
        TypeReference
          Identifier: ' CharCaseFolding'
  ModuleDeclaration
    ExportKeyword
    Identifier: ' Words'
    ModuleBlock
      FunctionDeclaration
        Identifier: ' fromUTF16ToString'
        Parameter
          Identifier: 'word'
          TypeReference
            Identifier: ' ReadonlyWord'
        StringKeyword
      FunctionDeclaration
        Identifier: ' fromUnicodeToString'
        Parameter
          Identifier: 'word'
          TypeReference
            Identifier: ' ReadonlyWord'
        StringKeyword
      FunctionDeclaration
        Identifier: ' fromStringToUTF16'
        Parameter
          Identifier: 'string'
          StringKeyword
        TypeReference
          Identifier: ' Word'
      FunctionDeclaration
        Identifier: ' fromStringToUnicode'
        Parameter
          Identifier: 'string'
          StringKeyword
        TypeReference
          Identifier: ' Word'
      FunctionDeclaration
        Identifier: ' pickMostReadableCharacter'
        Parameter
          Identifier: 'set'
          TypeReference
            Identifier: ' CharSet'
        UnionType
          TypeReference
            Identifier: ' Char'
          UndefinedKeyword
      FunctionDeclaration
        Identifier: ' pickMostReadableWord'
        Parameter
          Identifier: 'wordSet'
          TypeReference
            Identifier: ' ReadonlyWordSet'
        TypeReference
          Identifier: ' Word'
      FunctionDeclaration
        Identifier: ' wordSetsToWords'
        Parameter
          Identifier: 'wordSets'
          TypeReference
            Identifier: ' Iterable'
            TypeReference
              Identifier: 'ReadonlyWordSet'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'Word'
      FunctionDeclaration
        Identifier: ' wordSetToWords'
        Parameter
          Identifier: 'wordSet'
          TypeReference
            Identifier: ' ReadonlyWordSet'
        TypeReference
          Identifier: ' Iterable'
          TypeReference
            Identifier: 'Word'
