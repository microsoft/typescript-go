SourceFile
  ModuleDeclaration
    DeclareKeyword
    StringLiteral
    ModuleBlock
      ImportDeclaration
        ImportClause
          NamedImports
            ImportSpecifier
              Identifier: ' CharSet'
        StringLiteral
      ImportDeclaration
        ImportClause
          NamedImports
            ImportSpecifier
              Identifier: ' AST'
        StringLiteral
      InterfaceDeclaration
        ExportKeyword
        Identifier: ' AnalysisResult'
        PropertySignature
          Identifier: '
		/**
		 * The parse AST of the analysed literal.
		 */
		parsed'
          TypeReference
            Identifier: ' ParsedLiteral'
        PropertySignature
          Identifier: '
		/**
		 * The analysed literal.
		 */
		literal'
          TypeReference
            Identifier: ' Literal'
        PropertySignature
          Identifier: '
		/**
		 * A list of all reports found under the constraints of the given analysis options.
		 */
		reports'
          ArrayType
            TypeReference
              Identifier: ' Report'
      InterfaceDeclaration
        ExportKeyword
        Identifier: ' ReportBase'
        PropertySignature
          Identifier: '
		type'
          IndexedAccessType
            TypeReference
              Identifier: ' Report'
            LiteralType
              StringLiteral
        PropertySignature
          Identifier: '
		/**
		 * The character to be repeated in order to create an input for which the analysed literal will have super-linear
		 * runtime behavior.
		 */
		character'
          TypeLiteral
            PropertySignature
              Identifier: '
			/**
			 * A non-empty set of characters that can be repeated to cause super-linear runtime.
			 *
			 * CharSet is a class from the [refa](https://github.com/RunDevelopment/refa) library.
			 */
			set'
              TypeReference
                Identifier: ' CharSet'
            PropertySignature
              Identifier: '
			/**
			 * A single character that can be repeated to cause super-linear runtime.
			 *
			 * The implementation is allowed to pick any character in `set` but makes a best effort to pick a
			 * "humanly readable" character.
			 */
			pick'
              StringKeyword
            PropertySignature
              Identifier: '
			/**
			 * A literal that represents `set`.
			 *
			 * E.g. if `set` only contained the character "a" (lower case A), then the literal may be `/a/`.
			 */
			literal'
              TypeReference
                Identifier: ' Literal'
        MethodSignature
          Identifier: '
		/**
		 * Returns a new literal with this cause of super-linear runtime being fixed. If the cause of this report could not
		 * be automatically fixed, `undefined` will be returned.
		 *
		 * A fixed literal is guaranteed to behave exactly the same as the analysed literal.
		 */
		fix'
          UnionType
            TypeReference
              Identifier: ' Literal'
            UndefinedKeyword
        PropertySignature
          Identifier: '
		/**
		 * Whether the polynomial backtracking of this report causes exponential backtracking.
		 */
		exponential'
          BooleanKeyword
      InterfaceDeclaration
        ExportKeyword
        Identifier: ' TradeReport'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' ReportBase'
        PropertySignature
          Identifier: '
		type'
          LiteralType
            StringLiteral
        PropertySignature
          Identifier: '
		startQuant'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Quantifier'
        PropertySignature
          Identifier: '
		endQuant'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Quantifier'
      InterfaceDeclaration
        ExportKeyword
        Identifier: ' SelfReport'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' ReportBase'
        PropertySignature
          Identifier: '
		type'
          LiteralType
            StringLiteral
        PropertySignature
          Identifier: '
		/**
		 * An unbounded quantifier that can reach itself.
		 */
		quant'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Quantifier'
        PropertySignature
          Identifier: '
		/**
		 * A parent quantifier of [[`quant`]].
		 *
		 * The maximum of this quantifier is at least 2.
		 *
		 * This is guaranteed to be not the same quantifier as [[`quant`]].
		 */
		parentQuant'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Quantifier'
      InterfaceDeclaration
        ExportKeyword
        Identifier: ' MoveReport'
        HeritageClause
          ExpressionWithTypeArguments
            Identifier: ' ReportBase'
        PropertySignature
          Identifier: '
		type'
          LiteralType
            StringLiteral
        PropertySignature
          Identifier: '
		/**
		 * The unbounded quantifier that caused this report.
		 */
		quant'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Quantifier'
        PropertySignature
          Identifier: '
		/**
		 * This type can never cause exponential backtracking.
		 */
		exponential'
          LiteralType
            FalseKeyword
      TypeAliasDeclaration
        ExportKeyword
        Identifier: ' Report'
        UnionType
          TypeReference
            Identifier: ' TradeReport'
          TypeReference
            Identifier: ' MoveReport'
          TypeReference
            Identifier: ' SelfReport'
      InterfaceDeclaration
        ExportKeyword
        Identifier: ' Literal'
        PropertySignature
          Identifier: '
		source'
          StringKeyword
        PropertySignature
          Identifier: '
		flags'
          StringKeyword
      InterfaceDeclaration
        ExportKeyword
        Identifier: ' ParsedLiteral'
        PropertySignature
          Identifier: '
		pattern'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Pattern'
        PropertySignature
          Identifier: '
		flags'
          TypeReference
            QualifiedName
              Identifier: ' AST'
              Identifier: 'Flags'
      InterfaceDeclaration
        ExportKeyword
        Identifier: ' AnalysisOptions'
        PropertySignature
          Identifier: '
		/**
		 * The maximum number of reports to be returned.
		 *
		 * @default Infinity
		 */
		maxReports'
          QuestionToken
          NumberKeyword
        PropertySignature
          Identifier: '
		/**
		 * A record of allowed report types. All reports of a type that is mapped to `false` will be omitted.
		 *
		 * By default, all report types are allowed.
		 */
		reportTypes'
          QuestionToken
          TypeReference
            Identifier: ' Partial'
            TypeReference
              Identifier: 'Record'
              IndexedAccessType
                TypeReference
                  Identifier: 'Report'
                LiteralType
                  StringLiteral
              BooleanKeyword
        PropertySignature
          Identifier: '
		/**
		 * Whether the analyser is allowed to assume that a rejecting suffix can always be found.
		 *
		 * To exploit ambiguity in quantifiers, it is necessary to force the regex engine to go through all possible paths.
		 * This can only be done by finding a suffix that causes the exploitable part of analysed regex to reject the input
		 * string. If such a suffix cannot be found, the regex is not exploitable.
		 *
		 * If this option is set to `false`, a heuristic will be used to determine whether a rejecting suffix can be found.
		 * This will prevent reporting false positives - non-exploitable quantifiers.
		 *
		 * The heuristic makes the assumption that the regex is used as is - that the regex is not modified or used to
		 * construct other regexes. If this assumption is not met, the heuristic will prevent the reporting of potential
		 * true positives.
		 *
		 * By setting this option to `true`, the heuristic will not be used and all reports are assumed to be true
		 * positives.
		 *
		 * @default false
		 */
		assumeRejectingSuffix'
          QuestionToken
          BooleanKeyword
      FunctionDeclaration
        ExportKeyword
        Identifier: ' analyse'
        Parameter
          Identifier: '
		input'
          UnionType
            TypeReference
              Identifier: ' Readonly'
              TypeReference
                Identifier: 'Literal'
            TypeReference
              Identifier: ' Readonly'
              TypeReference
                Identifier: 'ParsedLiteral'
        Parameter
          Identifier: '
		options'
          QuestionToken
          TypeReference
            Identifier: ' Readonly'
            TypeReference
              Identifier: 'AnalysisOptions'
        TypeReference
          Identifier: ' AnalysisResult'
