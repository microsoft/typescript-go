import * as fs from "node:fs";
import * as path from "node:path";

const compilerFolder = "./internal/compiler";

/** @type {Record<string, {package: string, members?: boolean, rename?: string}>} */
const refactorMapping = {
    "NodeId": {
        package: "ast",
        members: false,
    },
    "MergeId": {
        package: "ast",
        members: false,
    },
    "SymbolId": {
        package: "ast",
        members: false,
    },
    "Symbol": {
        package: "ast",
        members: false,
    },
    "SymbolTable": {
        package: "ast",
        members: false,
    },
    /*"ScriptTarget": {
        package: "core",
    },
    "LanguageVariant": {
        package: "core",
    },
    "ScriptKind": {
        package: "core",
    },
    "SyntaxKind": {
        package: "ast",
        rename: "Kind"
    },
    "NodeFlags": {
        package: "ast",
    },
    "SymbolFlags": {
        package: "ast",
    },
    "CheckFlags": {
        package: "ast",
    },*/
    // "Tristate": {
    //     package: "tristate",
    // } // wasn't ported following the same pattern
}

// A list of every type or public value defined in ast.go
const astNames = [
    "Node", "NodeData",
    "Statement", "Declaration", "Expression", "TypeNode", "TypeElement", "ClassElement", "NamedMember", "ObjectLiteralElement", "BlockOrExpression", "AccessExpression", "DeclarationName", "ModuleName", "ModuleExportName", "PropertyName", "ModuleBody", "ForInitializer", "ModuleReference", "NamedImportBindings", "NamedExportBindings", "MemberName", "EntityName", "BindingName", "ModifierLike", "JsxChild", "JsxAttributeLike", "JsxAttributeValue", "JsxTagNameExpression", "ClassLikeDeclaration", "AccessorDeclaration", "LiteralLikeNode", "LiteralExpression", "UnionOrIntersectionTypeNode", "TemplateLiteralLikeNode", "TemplateMiddleOrTail", "TemplateLiteral", "TypePredicateParameterName", "ImportAttributeName", "LeftHandSideExpression", "IdentifierNode", "ModifierListNode", "TokenNode", "TemplateHeadNode", "TemplateMiddleNode", "TemplateTailNode", "TemplateSpanNode", "TemplateLiteralTypeSpanNode", "BlockNode", "CatchClauseNode", "CaseBlockNode", "CaseOrDefaultClauseNode", "VariableDeclarationNode", "VariableDeclarationListNode", "BindingElementNode", "TypeParameterListNode", "TypeArgumentListNode", "TypeParameterDeclarationNode", "ParameterDeclarationNode", "HeritageClauseNode", "ExpressionWithTypeArgumentsNode", "EnumMemberNode", "ImportClauseNode", "ImportAttributesNode", "ImportAttributeNode", "ImportSpecifierNode", "ExportSpecifierNode", "JsxAttributesNode", "JsxOpeningElementNode", "JsxClosingElementNode", "JsxOpeningFragmentNode", "JsxClosingFragmentNode",
    "DeclarationBase", "IsDeclarationNode",
    "ExportableBase",
    "ModifiersBase",
    "LocalsContainerBase",
    "IsLocalsContainer",
    "FunctionLikeBase",
    "BodyBase",
    "FunctionLikeWithBodyBase",
    "FlowNodeBase",
    "Token",
    "Identifier",
    "IsIdentifier",
    "PrivateIdentifier",
    "IsPrivateIdentifier",
    "QualifiedName",
    "IsQualifiedName",
    "TypeParameterDeclaration",
    "IsTypeParameterDeclaration",
    "ComputedPropertyName",
    "IsComputedPropertyName",
    "Decorator",
    "IsDecorator",
    "ModifierList",
    "StatementBase",
    "EmptyStatement",
    "IsEmptyStatement",
    "IfStatement",
    "DoStatement",
    "WhileStatement",
    "ForStatement",
    "ForInOrOfStatement",
    "IsForInOrOfStatement",
    "BreakStatement",
    "ContinueStatement",
    "ReturnStatement",
    "WithStatement",
    "SwitchStatement",
    "CaseBlock",
    "CaseOrDefaultClause",
    "ThrowStatement",
    "TryStatement",
    "CatchClause",
    "DebuggerStatement",
    "LabeledStatement",
    "ExpressionStatement",
    "IsExpressionStatement",
    "Block",
    "IsBlock",
    "VariableStatement",
    "IsVariableStatement",
    "VariableDeclaration",
    "IsVariableDeclaration",
    "VariableDeclarationList",
    "IsVariableDeclarationList",
    "BindingPattern",
    "IsObjectBindingPattern",
    "IsArrayBindingPattern",
    "ParameterDeclaration",
    "IsParameter",
    "BindingElement",
    "IsBindingElement",
    "MissingDeclaration",
    "FunctionDeclaration",
    "IsFunctionDeclaration",
    "ClassLikeBase",
    "ClassDeclaration",
    "IsClassDeclaration",
    "ClassExpression",
    "IsClassExpression",
    "HeritageClause",
    "IsHeritageClause",
    "InterfaceDeclaration",
    "IsInterfaceDeclaration",
    "TypeAliasDeclaration",
    "IsTypeAliasDeclaration",
    "EnumMember",
    "EnumDeclaration",
    "IsEnumDeclaration",
    "ModuleBlock",
    "IsModuleBlock",
    "ModuleDeclaration",
    "IsModuleDeclaration",
    "ImportEqualsDeclaration",
    "IsImportEqualsDeclaration",
    "ImportDeclaration",
    "IsImportDeclaration",
    "ImportSpecifier",
    "IsImportSpecifier",
    "ExternalModuleReference",
    "IsExternalModuleReference",
    "ImportClause",
    "NamespaceImport",
    "IsNamespaceImport",
    "NamedImports",
    "IsNamedImports",
    "ExportAssignment",
    "IsExportAssignment",
    "NamespaceExportDeclaration",
    "IsNamespaceExportDeclaration",
    "ExportDeclaration",
    "IsExportDeclaration",
    "NamespaceExport",
    "IsNamespaceExport",
    "NamedExports",
    "ExportSpecifier",
    "IsExportSpecifier",
    "TypeElementBase",
    "ClassElementBase",
    "NamedMemberBase",
    "CallSignatureDeclaration",
    "IsCallSignatureDeclaration",
    "ConstructSignatureDeclaration",
    "IsConstructSignatureDeclaration",
    "ConstructorDeclaration",
    "IsConstructorDeclaration",
    "AccessorDeclarationBase",
    "IsAccessorDeclaration",
    "GetAccessorDeclaration",
    "IsGetAccessorDeclaration",
    "SetAccessorDeclaration",
    "IsSetAccessorDeclaration",
    "IndexSignatureDeclaration",
    "IsIndexSignatureDeclaration",
    "MethodSignatureDeclaration",
    "IsMethodSignatureDeclaration",
    "MethodDeclaration",
    "IsMethodDeclaration",
    "PropertySignatureDeclaration",
    "IsPropertySignatureDeclaration",
    "PropertyDeclaration",
    "IsPropertyDeclaration",
    "SemicolonClassElement",
    "ClassStaticBlockDeclaration",
    "IsClassStaticBlockDeclaration",
    "TypeParameterList",
    "IsTypeParameterList",
    "ExpressionBase",
    "OmittedExpression",
    "KeywordExpression",
    "LiteralLikeBase",
    "StringLiteral",
    "IsStringLiteral",
    "NumericLiteral",
    "BigIntLiteral",
    "RegularExpressionLiteral",
    "NoSubstitutionTemplateLiteral",
    "BinaryExpression",
    "PrefixUnaryExpression",
    "IsPrefixUnaryExpression",
    "PostfixUnaryExpression",
    "YieldExpression",
    "ArrowFunction",
    "IsArrowFunction",
    "FunctionExpression",
    "IsFunctionExpression",
    "AsExpression",
    "SatisfiesExpression",
    "ConditionalExpression",
    "PropertyAccessExpression",
    "IsPropertyAccessExpression",
    "ElementAccessExpression",
    "IsElementAccessExpression",
    "CallExpression",
    "IsCallExpression",
    "NewExpression",
    "IsNewExpression",
    "MetaProperty",
    "IsMetaProperty",
    "NonNullExpression",
    "SpreadElement",
    "IsSpreadElement",
    "TemplateExpression",
    "TemplateSpan",
    "IsTemplateSpan",
    "TaggedTemplateExpression",
    "ParenthesizedExpression",
    "IsParenthesizedExpression",
    "ArrayLiteralExpression",
    "IsArrayLiteralExpression",
    "ObjectLiteralExpression",
    "IsObjectLiteralExpression",
    "ObjectLiteralElementBase",
    "SpreadAssignment",
    "PropertyAssignment",
    "IsPropertyAssignment",
    "ShorthandPropertyAssignment",
    "IsShorthandPropertyAssignment",
    "DeleteExpression",
    "TypeOfExpression",
    "IsTypeOfExpression",
    "VoidExpression",
    "AwaitExpression",
    "TypeAssertion",
    "TypeNodeBase",
    "KeywordTypeNode",
    "UnionOrIntersectionTypeNodeBase",
    "UnionTypeNode",
    "IntersectionTypeNode",
    "ConditionalTypeNode",
    "IsConditionalTypeNode",
    "TypeOperatorNode",
    "IsTypeOperatorNode",
    "InferTypeNode",
    "ArrayTypeNode",
    "IndexedAccessTypeNode",
    "IsIndexedAccessTypeNode",
    "TypeArgumentList",
    "TypeReferenceNode",
    "IsTypeReferenceNode",
    "ExpressionWithTypeArguments",
    "LiteralTypeNode",
    "IsLiteralTypeNode",
    "ThisTypeNode",
    "IsThisTypeNode",
    "TypePredicateNode",
    "IsTypePredicateNode",
    "ImportTypeNode",
    "IsImportTypeNode",
    "ImportAttribute",
    "ImportAttributes",
    "TypeQueryNode",
    "IsTypeQueryNode",
    "MappedTypeNode",
    "IsMappedTypeNode",
    "TypeLiteralNode",
    "TupleTypeNode",
    "NamedTupleMember",
    "IsNamedTupleMember",
    "OptionalTypeNode",
    "RestTypeNode",
    "ParenthesizedTypeNode",
    "IsParenthesizedTypeNode",
    "FunctionOrConstructorTypeNodeBase",
    "FunctionTypeNode",
    "IsFunctionTypeNode",
    "ConstructorTypeNode",
    "IsConstructorTypeNode",
    "TemplateLiteralLikeBase",
    "TemplateHead",
    "TemplateMiddle",
    "TemplateTail",
    "TemplateLiteralTypeNode",
    "TemplateLiteralTypeSpan",
    "JsxElement",
    "JsxAttributes",
    "IsJsxAttributes",
    "JsxNamespacedName",
    "IsJsxNamespacedName",
    "JsxOpeningElement",
    "IsJsxOpeningElement",
    "JsxSelfClosingElement",
    "IsJsxSelfClosingElement",
    "JsxFragment",
    "JsxOpeningFragment",
    "IsJsxOpeningFragment",
    "JsxClosingFragment",
    "JsxAttribute",
    "IsJsxAttribute",
    "JsxSpreadAttribute",
    "JsxClosingElement",
    "JsxExpression",
    "JsxText",
    "JSDocNonNullableType",
    "JSDocNullableType",
    "PatternAmbientModule",
    "SourceFile",
    "IsSourceFile",
]
for (const n of astNames) {
    refactorMapping[n] = { package: "ast", members: false };
}

const enums = Object.keys(refactorMapping);

const entries = fs.readdirSync(compilerFolder, {recursive: true});

outer: for (const entry of entries) {
    if (!entry.endsWith(".go")) continue;

    const localPath = path.join(compilerFolder, entry);
    console.log(localPath)
    let file = fs.readFileSync(localPath, {encoding: "utf-8"});

    for (const e of enums) {
        const newRootName = refactorMapping[e].rename || e;
        // replace bare references to the type with `package.type`
        file = file.replaceAll(new RegExp(`(\\W)${e}(\\W)`, "g"), (_, prefix, postfix) => `${prefix}${refactorMapping[e].package}.${newRootName}${postfix}`);
        // Replace all member references with `package.member`
        if (refactorMapping[e].members !== false) { 
            file = file.replaceAll(new RegExp(`(\\W)${e}(\\w+)`, "g"), (_, prefix, postfix) => `${prefix}${refactorMapping[e].package}.${newRootName}${postfix}`);
        }
    }
/*
    // Do tristate bespoke like

    // replace bare references to Tristate with `Tristate.Type`
    file = file.replaceAll(/(\W)Tristate(\W)/g, (_, prefix, postfix) => prefix+"core.Tristate"+postfix);
    // And member references to `tristate.Member`
    for (const member of ["TSUnknown", "TSTrue", "TSFalse"]) {
        file = file.replaceAll(new RegExp(`(\\W)${member}(\\W)`, "g"), (_, prefix, postfix) => `${prefix}core.${member}${postfix}`);
    }
*/
    fs.writeFileSync(localPath, file);
}