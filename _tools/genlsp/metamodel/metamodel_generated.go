// Code generated by generate.sh; DO NOT EDIT.

// This file was generated from JSON Schema using quicktype, do not modify it directly.
// To parse and unparse this JSON data, add this code to your project and do:
//
//    metaModel, err := UnmarshalMetaModel(bytes)
//    bytes, err = metaModel.Marshal()

package metamodel

import (
	"bytes"
	"errors"
)

import "encoding/json"

func UnmarshalMetaModel(data []byte) (MetaModel, error) {
	var r MetaModel
	err := json.Unmarshal(data, &r)
	return r, err
}

func (r *MetaModel) Marshal() ([]byte, error) {
	return json.Marshal(r)
}

// The actual meta model.
type MetaModel struct {
	// The enumerations.
	Enumerations []Enumeration `json:"enumerations"`
	// Additional meta data.
	MetaData MetaData `json:"metaData"`
	// The notifications.
	Notifications []Notification `json:"notifications"`
	// The requests.
	Requests []Request `json:"requests"`
	// The structures.
	Structures []Structure `json:"structures"`
	// The type aliases.
	TypeAliases []TypeAlias `json:"typeAliases"`
}

// Defines an enumeration.
type Enumeration struct {
	// Whether the enumeration is deprecated or not. If deprecated the property contains the
	// deprecation message.
	Deprecated *string `json:"deprecated,omitempty"`
	// An optional documentation.
	Documentation *string `json:"documentation,omitempty"`
	// The name of the enumeration.
	Name string `json:"name"`
	// Whether this is a proposed enumeration. If omitted, the enumeration is final.
	Proposed *bool `json:"proposed,omitempty"`
	// Since when (release number) this enumeration is available. Is undefined if not known.
	Since *string `json:"since,omitempty"`
	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty"`
	// Whether the enumeration supports custom values (e.g. values which are not part of the set
	// defined in `values`). If omitted no custom values are supported.
	SupportsCustomValues *bool `json:"supportsCustomValues,omitempty"`
	// The type of the elements.
	Type EnumerationType `json:"type"`
	// The enum values.
	Values []EnumerationEntry `json:"values"`
}

// The type of the elements.
type EnumerationType struct {
	Kind TypeKind `json:"kind"`
	Name Name     `json:"name"`
}

// Defines an enumeration entry.
type EnumerationEntry struct {
	// Whether the enum entry is deprecated or not. If deprecated the property contains the
	// deprecation message.
	Deprecated *string `json:"deprecated,omitempty"`
	// An optional documentation.
	Documentation *string `json:"documentation,omitempty"`
	// The name of the enum item.
	Name string `json:"name"`
	// Whether this is a proposed enumeration entry. If omitted, the enumeration entry is final.
	Proposed *bool `json:"proposed,omitempty"`
	// Since when (release number) this enumeration entry is available. Is undefined if not
	// known.
	Since *string `json:"since,omitempty"`
	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty"`
	// The value.
	Value *ValueValue `json:"value"`
}

// Additional meta data.
type MetaData struct {
	// The protocol version.
	Version string `json:"version"`
}

// Represents a LSP notification
type Notification struct {
	// Whether the notification is deprecated or not. If deprecated the property contains the
	// deprecation message.
	Deprecated *string `json:"deprecated,omitempty"`
	// An optional documentation;
	Documentation *string `json:"documentation,omitempty"`
	// The direction in which this notification is sent in the protocol.
	MessageDirection MessageDirection `json:"messageDirection"`
	// The notifications's method name.
	Method string `json:"method"`
	// The parameter type(s) if any.
	Params *ParamsUnion `json:"params"`
	// Whether this is a proposed notification. If omitted the notification is final.
	Proposed *bool `json:"proposed,omitempty"`
	// Optional a dynamic registration method if it different from the notifications's method.
	RegistrationMethod *string `json:"registrationMethod,omitempty"`
	// Optional registration options if the notification supports dynamic registration.
	RegistrationOptions *TypeElement `json:"registrationOptions,omitempty"`
	// Since when (release number) this notification is available. Is undefined if not known.
	Since *string `json:"since,omitempty"`
	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty"`
	// The type name of the notifications if any.
	TypeName *string `json:"typeName,omitempty"`
}

// Represents an object property.
type Property struct {
	// Whether the property is deprecated or not. If deprecated the property contains the
	// deprecation message.
	Deprecated *string `json:"deprecated,omitempty"`
	// An optional documentation.
	Documentation *string `json:"documentation,omitempty"`
	// The property name;
	Name string `json:"name"`
	// Whether the property is optional. If omitted, the property is mandatory.
	Optional *bool `json:"optional,omitempty"`
	// Whether this is a proposed property. If omitted, the structure is final.
	Proposed *bool `json:"proposed,omitempty"`
	// Since when (release number) this property is available. Is undefined if not known.
	Since *string `json:"since,omitempty"`
	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty"`
	// The type of the property
	Type TypeElement `json:"type"`
}

// The type of the property
//
// Optional registration options if the notification supports dynamic registration.
//
// An optional error data type.
//
// Optional partial result type if the request supports partial result reporting.
//
// Optional registration options if the request supports dynamic registration.
//
// The result type.
//
// The aliased type.
//
// Represents a base type like `string` or `DocumentUri`.
//
// Represents a reference to another type (e.g. `TextDocument`). This is either a
// `Structure`, a `Enumeration` or a `TypeAlias` in the same meta model.
//
// Represents an array type (e.g. `TextDocument[]`).
//
// Represents a JSON object map (e.g. `interface Map<K extends string | integer, V> { [key:
// K] => V; }`).
//
// Represents an `and`type (e.g. TextDocumentParams & WorkDoneProgressParams`).
//
// Represents an `or` type (e.g. `Location | LocationLink`).
//
// Represents a `tuple` type (e.g. `[integer, integer]`).
//
// Represents a literal structure (e.g. `property: { start: uinteger; end: uinteger; }`).
//
// Represents a string literal type (e.g. `kind: 'rename'`).
//
// Represents a boolean literal type (e.g. `kind: true`).
//
// Defines an unnamed structure of an object literal.
type ValueType struct {
	// Represents an integer literal type (e.g. `kind: 1`).
	Kind    *TypeKindEnum `json:"kind,omitempty"`
	Name    *string       `json:"name,omitempty"`
	Element *TypeElement  `json:"element,omitempty"`
	Key     *MapKeyType   `json:"key,omitempty"`
	Value   *TypeValue    `json:"value"`
	Items   []TypeElement `json:"items,omitempty"`
	// Whether the literal is deprecated or not. If deprecated the property contains the
	// deprecation message.
	Deprecated *string `json:"deprecated,omitempty"`
	// An optional documentation.
	Documentation *string `json:"documentation,omitempty"`
	// The properties.
	Properties []Property `json:"properties,omitempty"`
	// Whether this is a proposed structure. If omitted, the structure is final.
	Proposed *bool `json:"proposed,omitempty"`
	// Since when (release number) this structure is available. Is undefined if not known.
	Since *string `json:"since,omitempty"`
	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty"`
}

// The type of the property
//
// Optional registration options if the notification supports dynamic registration.
//
// An optional error data type.
//
// Optional partial result type if the request supports partial result reporting.
//
// Optional registration options if the request supports dynamic registration.
//
// The result type.
//
// The aliased type.
//
// Represents a base type like `string` or `DocumentUri`.
//
// Represents a reference to another type (e.g. `TextDocument`). This is either a
// `Structure`, a `Enumeration` or a `TypeAlias` in the same meta model.
//
// Represents an array type (e.g. `TextDocument[]`).
//
// Represents a JSON object map (e.g. `interface Map<K extends string | integer, V> { [key:
// K] => V; }`).
//
// Represents an `and`type (e.g. TextDocumentParams & WorkDoneProgressParams`).
//
// Represents an `or` type (e.g. `Location | LocationLink`).
//
// Represents a `tuple` type (e.g. `[integer, integer]`).
//
// Represents a literal structure (e.g. `property: { start: uinteger; end: uinteger; }`).
//
// Represents a string literal type (e.g. `kind: 'rename'`).
//
// Represents a boolean literal type (e.g. `kind: true`).
type TypeElement struct {
	// Represents an integer literal type (e.g. `kind: 1`).
	Kind    TypeKindEnum  `json:"kind"`
	Name    *string       `json:"name,omitempty"`
	Element *TypeElement  `json:"element,omitempty"`
	Key     *MapKeyType   `json:"key,omitempty"`
	Value   *TypeValue    `json:"value"`
	Items   []TypeElement `json:"items,omitempty"`
}

// Represents a type that can be used as a key in a map type. If a reference type is used
// then the type must either resolve to a `string` or `integer` type. (e.g. `type
// ChangeAnnotationIdentifier === string`).
//
// Represents a reference to another type (e.g. `TextDocument`). This is either a
// `Structure`, a `Enumeration` or a `TypeAlias` in the same meta model.
type MapKeyType struct {
	Kind MapKeyTypeKind `json:"kind"`
	Name string         `json:"name"`
}

// Represents a base type like `string` or `DocumentUri`.
//
// Represents a reference to another type (e.g. `TextDocument`). This is either a
// `Structure`, a `Enumeration` or a `TypeAlias` in the same meta model.
//
// Represents an array type (e.g. `TextDocument[]`).
//
// Represents a JSON object map (e.g. `interface Map<K extends string | integer, V> { [key:
// K] => V; }`).
//
// Represents an `and`type (e.g. TextDocumentParams & WorkDoneProgressParams`).
//
// Represents an `or` type (e.g. `Location | LocationLink`).
//
// Represents a `tuple` type (e.g. `[integer, integer]`).
//
// Represents a literal structure (e.g. `property: { start: uinteger; end: uinteger; }`).
//
// Represents a string literal type (e.g. `kind: 'rename'`).
//
// Represents a boolean literal type (e.g. `kind: true`).
type Type struct {
	// Represents an integer literal type (e.g. `kind: 1`).
	Kind    TypeKindEnum  `json:"kind"`
	Name    *string       `json:"name,omitempty"`
	Element *TypeElement  `json:"element,omitempty"`
	Key     *MapKeyType   `json:"key,omitempty"`
	Value   *TypeValue    `json:"value"`
	Items   []TypeElement `json:"items,omitempty"`
}

// Represents a LSP request
type Request struct {
	// Whether the request is deprecated or not. If deprecated the property contains the
	// deprecation message.
	Deprecated *string `json:"deprecated,omitempty"`
	// An optional documentation;
	Documentation *string `json:"documentation,omitempty"`
	// An optional error data type.
	ErrorData *TypeElement `json:"errorData,omitempty"`
	// The direction in which this request is sent in the protocol.
	MessageDirection MessageDirection `json:"messageDirection"`
	// The request's method name.
	Method string `json:"method"`
	// The parameter type(s) if any.
	Params *ParamsUnion `json:"params"`
	// Optional partial result type if the request supports partial result reporting.
	PartialResult *TypeElement `json:"partialResult,omitempty"`
	// Whether this is a proposed feature. If omitted the feature is final.
	Proposed *bool `json:"proposed,omitempty"`
	// Optional a dynamic registration method if it different from the request's method.
	RegistrationMethod *string `json:"registrationMethod,omitempty"`
	// Optional registration options if the request supports dynamic registration.
	RegistrationOptions *TypeElement `json:"registrationOptions,omitempty"`
	// The result type.
	Result TypeElement `json:"result"`
	// Since when (release number) this request is available. Is undefined if not known.
	Since *string `json:"since,omitempty"`
	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty"`
	// The type name of the request if any.
	TypeName *string `json:"typeName,omitempty"`
}

// Defines the structure of an object literal.
type Structure struct {
	// Whether the structure is deprecated or not. If deprecated the property contains the
	// deprecation message.
	Deprecated *string `json:"deprecated,omitempty"`
	// An optional documentation;
	Documentation *string `json:"documentation,omitempty"`
	// Structures extended from. This structures form a polymorphic type hierarchy.
	Extends []TypeElement `json:"extends,omitempty"`
	// Structures to mix in. The properties of these structures are `copied` into this
	// structure. Mixins don't form a polymorphic type hierarchy in LSP.
	Mixins []TypeElement `json:"mixins,omitempty"`
	// The name of the structure.
	Name string `json:"name"`
	// The properties.
	Properties []Property `json:"properties"`
	// Whether this is a proposed structure. If omitted, the structure is final.
	Proposed *bool `json:"proposed,omitempty"`
	// Since when (release number) this structure is available. Is undefined if not known.
	Since *string `json:"since,omitempty"`
	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty"`
}

// Defines a type alias. (e.g. `type Definition = Location | LocationLink`)
type TypeAlias struct {
	// Whether the type alias is deprecated or not. If deprecated the property contains the
	// deprecation message.
	Deprecated *string `json:"deprecated,omitempty"`
	// An optional documentation.
	Documentation *string `json:"documentation,omitempty"`
	// The name of the type alias.
	Name string `json:"name"`
	// Whether this is a proposed type alias. If omitted, the type alias is final.
	Proposed *bool `json:"proposed,omitempty"`
	// Since when (release number) this structure is available. Is undefined if not known.
	Since *string `json:"since,omitempty"`
	// All since tags in case there was more than one tag. Is undefined if not known.
	SinceTags []string `json:"sinceTags,omitempty"`
	// The aliased type.
	Type TypeElement `json:"type"`
}

type TypeKind string

const (
	PurpleBase TypeKind = "base"
)

type Name string

const (
	Integer  Name = "integer"
	String   Name = "string"
	Uinteger Name = "uinteger"
)

// The direction in which this notification is sent in the protocol.
//
// Indicates in which direction a message is sent in the protocol.
//
// The direction in which this request is sent in the protocol.
type MessageDirection string

const (
	Both           MessageDirection = "both"
	ClientToServer MessageDirection = "clientToServer"
	ServerToClient MessageDirection = "serverToClient"
)

type MapKeyTypeKind string

const (
	FluffyBase      MapKeyTypeKind = "base"
	PurpleReference MapKeyTypeKind = "reference"
)

type TypeKindEnum string

const (
	And             TypeKindEnum = "and"
	Array           TypeKindEnum = "array"
	BooleanLiteral  TypeKindEnum = "booleanLiteral"
	FluffyReference TypeKindEnum = "reference"
	IntegerLiteral  TypeKindEnum = "integerLiteral"
	Literal         TypeKindEnum = "literal"
	Map             TypeKindEnum = "map"
	Or              TypeKindEnum = "or"
	StringLiteral   TypeKindEnum = "stringLiteral"
	TentacledBase   TypeKindEnum = "base"
	Tuple           TypeKindEnum = "tuple"
)

// The value.
type ValueValue struct {
	Double *float64
	String *string
}

func (x *ValueValue) UnmarshalJSON(data []byte) error {
	object, err := unmarshalUnion(data, nil, &x.Double, nil, &x.String, false, nil, false, nil, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
	}
	return nil
}

func (x *ValueValue) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, x.Double, nil, x.String, false, nil, false, nil, false, nil, false, nil, false)
}

type ParamsUnion struct {
	Type             *Type
	TypeElementArray []TypeElement
}

func (x *ParamsUnion) UnmarshalJSON(data []byte) error {
	x.TypeElementArray = nil
	x.Type = nil
	var c Type
	object, err := unmarshalUnion(data, nil, nil, nil, nil, true, &x.TypeElementArray, true, &c, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
		x.Type = &c
	}
	return nil
}

func (x *ParamsUnion) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, nil, nil, nil, x.TypeElementArray != nil, x.TypeElementArray, x.Type != nil, x.Type, false, nil, false, nil, false)
}

type TypeValue struct {
	Bool      *bool
	Double    *float64
	String    *string
	ValueType *ValueType
}

func (x *TypeValue) UnmarshalJSON(data []byte) error {
	x.ValueType = nil
	var c ValueType
	object, err := unmarshalUnion(data, nil, &x.Double, &x.Bool, &x.String, false, nil, true, &c, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
		x.ValueType = &c
	}
	return nil
}

func (x *TypeValue) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, x.Double, x.Bool, x.String, false, nil, x.ValueType != nil, x.ValueType, false, nil, false, nil, false)
}

func unmarshalUnion(data []byte, pi **int64, pf **float64, pb **bool, ps **string, haveArray bool, pa interface{}, haveObject bool, pc interface{}, haveMap bool, pm interface{}, haveEnum bool, pe interface{}, nullable bool) (bool, error) {
	if pi != nil {
		*pi = nil
	}
	if pf != nil {
		*pf = nil
	}
	if pb != nil {
		*pb = nil
	}
	if ps != nil {
		*ps = nil
	}

	dec := json.NewDecoder(bytes.NewReader(data))
	dec.UseNumber()
	tok, err := dec.Token()
	if err != nil {
		return false, err
	}

	switch v := tok.(type) {
	case json.Number:
		if pi != nil {
			i, err := v.Int64()
			if err == nil {
				*pi = &i
				return false, nil
			}
		}
		if pf != nil {
			f, err := v.Float64()
			if err == nil {
				*pf = &f
				return false, nil
			}
			return false, errors.New("Unparsable number")
		}
		return false, errors.New("Union does not contain number")
	case float64:
		return false, errors.New("Decoder should not return float64")
	case bool:
		if pb != nil {
			*pb = &v
			return false, nil
		}
		return false, errors.New("Union does not contain bool")
	case string:
		if haveEnum {
			return false, json.Unmarshal(data, pe)
		}
		if ps != nil {
			*ps = &v
			return false, nil
		}
		return false, errors.New("Union does not contain string")
	case nil:
		if nullable {
			return false, nil
		}
		return false, errors.New("Union does not contain null")
	case json.Delim:
		if v == '{' {
			if haveObject {
				return true, json.Unmarshal(data, pc)
			}
			if haveMap {
				return false, json.Unmarshal(data, pm)
			}
			return false, errors.New("Union does not contain object")
		}
		if v == '[' {
			if haveArray {
				return false, json.Unmarshal(data, pa)
			}
			return false, errors.New("Union does not contain array")
		}
		return false, errors.New("Cannot handle delimiter")
	}
	return false, errors.New("Cannot unmarshal union")
}

func marshalUnion(pi *int64, pf *float64, pb *bool, ps *string, haveArray bool, pa interface{}, haveObject bool, pc interface{}, haveMap bool, pm interface{}, haveEnum bool, pe interface{}, nullable bool) ([]byte, error) {
	if pi != nil {
		return json.Marshal(*pi)
	}
	if pf != nil {
		return json.Marshal(*pf)
	}
	if pb != nil {
		return json.Marshal(*pb)
	}
	if ps != nil {
		return json.Marshal(*ps)
	}
	if haveArray {
		return json.Marshal(pa)
	}
	if haveObject {
		return json.Marshal(pc)
	}
	if haveMap {
		return json.Marshal(pm)
	}
	if haveEnum {
		return json.Marshal(pe)
	}
	if nullable {
		return json.Marshal(nil)
	}
	return nil, errors.New("Union must not be null")
}
