import type {
    MetaModelSchema,
    Type,
} from "./metaModelSchema.mts";

import fs from "node:fs";
import path from "node:path";
import url from "node:url";

const __filename = url.fileURLToPath(new URL(import.meta.url));
const __dirname = path.dirname(__filename);

const out = process.argv[2];
if (!out) {
    console.error("Usage: node generate.mts <output file>");
    process.exit(1);
}

const metaModelPath = path.resolve(__dirname, "metaModel.json");

const model: MetaModelSchema = JSON.parse(fs.readFileSync(metaModelPath, "utf-8"));

let parts: string[] = [];
let indentLevel = 0;

function indent() {
    indentLevel++;
}

function dedent() {
    indentLevel--;
}

function write(s: string) {
    parts.push(s);
}

function writeLine(s: string) {
    startLine(s);
    write("\n");
}

function startLine(s: string) {
    parts.push("\t".repeat(indentLevel));
    write(s);
}

function finishLine(s: string) {
    write(s);
    write("\n");
}

function writeDocumentation(doc: string | undefined) {
    if (doc) {
        const lines = doc.split("\n");
        for (const line of lines) {
            startLine("// ");
            finishLine(line);
        }
    }
}

function writeDeprecation(deprecated: string | undefined) {
    if (deprecated) {
        writeLine("//");
        startLine("// Deprecated: ");
        finishLine(deprecated);
    }
}

function titleCase(s: string): string {
    return s.charAt(0).toUpperCase() + s.slice(1);
}

function writeTypeElement(t: Type) {
    switch (t.kind) {
        case "reference":
            write(t.name);
            break;
        case "base":
            switch (t.name) {
                case "integer":
                    write("int32");
                    break;
                case "uinteger":
                    write("uint32");
                    break;
                case "string":
                    write("string");
                    break;
                case "boolean":
                    write("bool");
                    break;
                case "URI":
                    write("URI");
                    break;
                case "DocumentUri":
                    write("DocumentUri");
                    break;
                case "decimal":
                    write("float64");
                    break;
                default:
                    write("TODO_base_" + t.name);
                    break;
            }
            break;
        case "array":
            write("[]");
            writeTypeElement(t.element);
            break;
        case "stringLiteral":
            write("string");
            break;
        case "map":
            write("map[");
            write(t.key.name);
            write("]");

            const vt = t.value;
            switch (vt.kind) {
                case "reference":
                    write(vt.name);
                    break;
                case "array":
                    write("[]");
                    writeTypeElement(vt.element);
                    break;
                case "or":
                    write("TODO_map_value_or_" + vt.items.length);
                    break;
                default:
                    write("TODO_map_value_" + vt.kind);
                    break;
            }
            break;
        case "or":
            write("TODO_or_" + t.items.length);
            break;
        default:
            write("TODO_" + t.kind);
            break;
    }
}

// Generation

writeLine("// Code generated by genlsp; DO NOT EDIT.");
writeLine("");
writeLine("package lsproto2");
writeLine("");
writeLine("// Meta model version " + model.metaData.version);
writeLine("");

writeLine("type URI string\n");
writeLine("type DocumentUri string\n");
writeLine("type Method string\n");

writeLine("");

for (const t of model.structures) {
    writeDocumentation(t.documentation);
    writeDeprecation(t.deprecated);

    writeLine("type " + t.name + " struct {");
    indent();

    for (const e of t.extends ?? []) {
        if (e.kind !== "reference") {
            throw new Error("Unexpected extends kind: " + e.kind);
        }
        writeLine(e.name);
    }
    for (const m of t.mixins ?? []) {
        if (m.kind !== "reference") {
            throw new Error("Unexpected mixin kind: " + m.kind);
        }
        writeLine(m.name);
    }

    for (const p of t.properties) {
        writeDocumentation(p.documentation);
        writeDeprecation(p.deprecated);

        startLine(titleCase(p.name) + " ");

        if (p.optional) {
            write("*");
        }

        writeTypeElement(p.type);

        finishLine(' `json:"' + p.name + '"`');
    }

    dedent();
    writeLine("}");
    writeLine("\n");
}

for (const t of model.enumerations) {
    writeDocumentation(t.documentation);
    writeDeprecation(t.deprecated);

    writeLine("type " + t.name + " int");
    writeLine("\n");
}

for (const t of model.typeAliases) {
    writeDocumentation(t.documentation);
    writeDeprecation(t.deprecated);

    startLine("type " + t.name + " = ");
    writeTypeElement(t.type);
    writeLine("\n");
}

function methodNameToIdentifier(method: string): string {
    return method.split("/").map(v => v === "$" ? "" : titleCase(v)).join("");
}

for (const t of model.requests) {
    writeDocumentation(t.documentation);
    writeDeprecation(t.deprecated);
    writeLine("const MethodRequest" + methodNameToIdentifier(t.method) + ' Method = "' + t.method + '"\n');
}

for (const t of model.notifications) {
    writeDocumentation(t.documentation);
    writeDeprecation(t.deprecated);
    writeLine("const MethodNotification" + methodNameToIdentifier(t.method) + ' Method = "' + t.method + '"\n');
}

fs.writeFileSync(out, parts.join(""));
