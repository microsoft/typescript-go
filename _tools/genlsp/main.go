package main

import (
	"bytes"
	_ "embed"
	"encoding/json"
	"flag"
	"os"
	"strings"

	"github.com/microsoft/typescript-go/_tools/genlsp/metamodel"
)

//go:embed metaModel.json
var rawMetaModel []byte

func main() {
	out := flag.String("out", "", "output file")
	flag.Parse()

	if *out == "" {
		panic("missing -out")
	}

	var model metamodel.MetaModel
	if err := json.Unmarshal(rawMetaModel, &model); err != nil {
		panic(err)
	}

	var buf bytes.Buffer

	buf.WriteString("// Code generated by genlsp; DO NOT EDIT.\n")
	buf.WriteString("\n")
	buf.WriteString("package lsproto2\n")
	buf.WriteString("\n")
	buf.WriteString("// Meta model version " + model.MetaData.Version + "\n")
	buf.WriteString("\n")

	for _, t := range model.Structures {
		if t.Documentation != nil {
			lines := strings.Split(*t.Documentation, "\n")
			for _, line := range lines {
				buf.WriteString("// " + line + "\n")
			}
		}

		if t.Deprecated != nil {
			buf.WriteString("// Deprecated: " + *t.Deprecated + "\n")
		}

		buf.WriteString("type " + t.Name + " struct {\n")

		for _, e := range t.Extends {
			buf.WriteString("\t" + *e.Name + "\n")
		}
		for _, m := range t.Mixins {
			buf.WriteString("\t" + *m.Name + "\n")
		}

		for _, p := range t.Properties {
			if p.Documentation != nil {
				lines := strings.Split(*p.Documentation, "\n")
				for _, line := range lines {
					buf.WriteString("\t// " + line + "\n")
				}
			}

			if p.Deprecated != nil {
				buf.WriteString("\t// Deprecated: " + *p.Deprecated + "\n")
			}

			// TODO(jakebailey): better uppercasing (e.g. URI)
			buf.WriteString("\t" + strings.Title(p.Name) + " ")

			switch p.Type.Kind {
			case metamodel.FluffyReference:
				buf.WriteString("*" + *p.Type.Name)
			default:
				buf.WriteString("TODO_" + string(p.Type.Kind))
			}

			buf.WriteString(" `json:\"" + p.Name + "\"`\n")
		}

		buf.WriteString("}\n")
		buf.WriteString("\n")
	}

	// for _, t := range model.Enumerations {
	// 	buf.WriteString("type " + t.Name + " int\n")
	// }

	// for _, t := range model.Requests {
	// 	fmt.Println(t.Method)
	// }

	// for _, t := range model.Notifications {
	// 	fmt.Println(t.Method)
	// }

	if err := os.WriteFile(*out, buf.Bytes(), 0o644); err != nil {
		panic(err)
	}
}

var supportedMethods = map[string]bool{
	"initialize":  true,
	"initialized": true,
	"shutdown":    true,
	"exit":        true,

	"$/cancelRequest": true,
	"$/setTrace":      true,

	"textDocument/didOpen":   true,
	"textDocument/didChange": true,
	"textDocument/didClose":  true,
	"textDocument/didSave":   true,

	"textDocument/publishDiagnostics": true,
	"textDocument/diagnostics":        true,

	"textDocument/hover": true,

	"textDocument/completion": true,
	"completionItem/resolve":  true,
}
