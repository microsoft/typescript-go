package main

import (
	"bytes"
	_ "embed"
	"encoding/json"
	"flag"
	"go/format"
	"os"
	"strings"

	"github.com/microsoft/typescript-go/_tools/genlsp/metamodel"
)

//go:embed metaModel.json
var rawMetaModel []byte

func main() {
	out := flag.String("out", "", "output file")
	flag.Parse()

	if *out == "" {
		panic("missing -out")
	}

	g := generator{}
	g.generate()

	b := g.buf.Bytes()
	b, err := format.Source(b)
	if err != nil {
		panic(err)
	}

	if err := os.WriteFile(*out, b, 0o644); err != nil {
		panic(err)
	}
}

type generator struct {
	model metamodel.MetaModel

	buf         bytes.Buffer
	indentCount int
}

func (g *generator) generate() {
	if err := json.Unmarshal(rawMetaModel, &g.model); err != nil {
		panic(err)
	}

	g.writeLine("// Code generated by genlsp; DO NOT EDIT.")
	g.writeLine("")
	g.writeLine("package lsproto2")
	g.writeLine("")
	g.writeLine("// Meta model version " + g.model.MetaData.Version)
	g.writeLine("")

	g.writeLine("type URI string\n")
	g.writeLine("type DocumentUri string\n")

	for _, t := range g.model.Structures {
		g.writeDocumentation(t.Documentation)
		g.writeDeprecation(t.Deprecated)

		g.writeLine("type " + t.Name + " struct {")
		g.indent()

		for _, e := range t.Extends {
			g.writeLine(*e.Name)
		}
		for _, m := range t.Mixins {
			g.writeLine(*m.Name)
		}

		for _, p := range t.Properties {
			g.writeDocumentation(p.Documentation)
			g.writeDeprecation(p.Deprecated)

			// TODO(jakebailey): better uppercasing (e.g. URI)
			g.startLine(strings.Title(p.Name) + " ")

			if p.Optional != nil && *p.Optional {
				g.write("*")
			}

			g.writeTypeElement(&p.Type)

			g.finishLine(" `json:\"" + p.Name + "\"`")
		}

		g.dedent()
		g.writeLine("}")
		g.writeLine("")
	}

	for _, t := range g.model.Enumerations {
		g.writeDocumentation(t.Documentation)
		g.writeDeprecation(t.Deprecated)

		g.writeLine("type " + t.Name + " int")
		g.writeLine("")
	}

	for _, t := range g.model.TypeAliases {
		g.writeDocumentation(t.Documentation)
		g.writeDeprecation(t.Deprecated)

		g.startLine("type " + t.Name + " = ")
		g.writeTypeElement(&t.Type)
		g.finishLine("")
	}

	// for _, t := range g.model.Requests {
	// 	if t.Params
	// }

	// for _, t := range g.model.Notifications {
	// 	fmt.Println(t.Method)
	// }
}

func (g *generator) writeTypeElement(t *metamodel.TypeElement) {
	switch t.Kind {
	case metamodel.FluffyReference:
		g.write(*t.Name)
	case metamodel.TentacledBase:
		switch *t.Name {
		case "integer":
			g.write("int32")
		case "uinteger":
			g.write("uint32")
		case "string":
			g.write("string")
		case "boolean":
			g.write("bool")
		case "URI":
			g.write("URI")
		case "DocumentUri":
			g.write("DocumentUri")
		case "decimal":
			g.write("float64")
		default:
			g.write("TODO_base_" + *t.Name)
		}
	case metamodel.Array:
		g.write("[]")
		g.writeTypeElement(t.Element)
	case metamodel.StringLiteral:
		g.write("string")
	case metamodel.Map:
		g.write("map[")
		g.write(t.Key.Name)
		g.write("]")

		vt := t.Value.ValueType
		switch *vt.Kind {
		case metamodel.FluffyReference:
			g.write(*vt.Name)
		case metamodel.Array:
			g.write("[]")
			g.writeTypeElement(vt.Element)
		default:
			g.write("TODO_map_value_" + string(*vt.Kind))
		}
	default:
		g.write("TODO_" + string(t.Kind))
	}
}

func (g *generator) writeDocumentation(doc *string) {
	if doc != nil {
		lines := strings.Split(*doc, "\n")
		for _, line := range lines {
			g.startLine("// ")
			g.finishLine(line)
		}
	}
}

func (g *generator) writeDeprecation(deprecated *string) {
	if deprecated != nil {
		g.startLine("// Deprecated: ")
		g.finishLine(*deprecated)
	}
}

func (g *generator) startLine(s string) {
	for range g.indentCount {
		g.buf.WriteString("\t")
	}
	g.buf.WriteString(s)
}

func (g *generator) finishLine(s string) {
	g.buf.WriteString(s)
	g.buf.WriteString("\n")
}

func (g *generator) writeLine(line string) {
	g.startLine(line)
	g.buf.WriteString("\n")
}

func (g *generator) write(s string) {
	g.buf.WriteString(s)
}

func (g *generator) indent() {
	g.indentCount++
}

func (g *generator) dedent() {
	g.indentCount--
}
